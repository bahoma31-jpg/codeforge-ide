[
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\app\\layout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\app\\page.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\agent-panel-enhanced.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'useState' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 17,
        "column": 17,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 17,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'useCallback' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 17,
        "column": 27,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 17,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'Brain' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 20,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 20,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'lastEvent' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 190,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 190,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\n/**\n * CodeForge IDE â€” Enhanced Agent Panel (Phase 9)\n * Extends the agent chat panel with OODA status bar and mode indicator.\n *\n * This component wraps the existing agent-panel.tsx functionality\n * and adds a visual OODA integration layer on top.\n *\n * New features:\n * - Mode indicator (Chat / Self-Improve / Hybrid)\n * - OODA status bar with phase progress\n * - Quick toggle for OODA auto-detection\n * - Token usage display for OODA cycles\n */\n\nimport React, { useState, useCallback } from 'react';\nimport type { OODAMode, OODAAgentEvent } from '@/lib/agent/agent-service-ooda';\nimport {\n  Brain,\n  MessageSquare,\n  RefreshCw,\n  Zap,\n  Eye,\n  Compass,\n  ClipboardList,\n  Play,\n  CheckCircle,\n  AlertTriangle,\n  ToggleLeft,\n  ToggleRight,\n} from 'lucide-react';\n\n// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ninterface OODAStatusBarProps {\n  mode: OODAMode;\n  isOODAReady: boolean;\n  autoDetect: boolean;\n  onToggleAutoDetect: (enabled: boolean) => void;\n  currentPhase?: string;\n  tokenUsage?: number;\n  lastEvent?: OODAAgentEvent;\n}\n\ninterface OODAPhaseIndicatorProps {\n  currentPhase: string;\n}\n\n// â”€â”€â”€ Phase Icons & Labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst PHASE_CONFIG: Record<\n  string,\n  {\n    icon: React.ReactNode;\n    label: string;\n    labelAr: string;\n    color: string;\n  }\n> = {\n  OBSERVE: {\n    icon: <Eye size={12} />,\n    label: 'Observe',\n    labelAr: 'Ø±ØµØ¯',\n    color: '#89b4fa',\n  },\n  ORIENT: {\n    icon: <Compass size={12} />,\n    label: 'Orient',\n    labelAr: 'ØªØ­Ù„ÙŠÙ„',\n    color: '#cba6f7',\n  },\n  DECIDE: {\n    icon: <ClipboardList size={12} />,\n    label: 'Decide',\n    labelAr: 'Ù‚Ø±Ø§Ø±',\n    color: '#f9e2af',\n  },\n  ACT: {\n    icon: <Play size={12} />,\n    label: 'Act',\n    labelAr: 'ØªÙ†ÙÙŠØ°',\n    color: '#fab387',\n  },\n  VERIFY: {\n    icon: <CheckCircle size={12} />,\n    label: 'Verify',\n    labelAr: 'ØªØ­Ù‚Ù‚',\n    color: '#a6e3a1',\n  },\n  READY: {\n    icon: <CheckCircle size={12} />,\n    label: 'Ready',\n    labelAr: 'Ø¬Ø§Ù‡Ø²',\n    color: '#a6e3a1',\n  },\n  ERROR: {\n    icon: <AlertTriangle size={12} />,\n    label: 'Error',\n    labelAr: 'Ø®Ø·Ø£',\n    color: '#f38ba8',\n  },\n};\n\nconst MODE_CONFIG: Record<\n  OODAMode,\n  {\n    icon: React.ReactNode;\n    label: string;\n    color: string;\n    bg: string;\n  }\n> = {\n  chat: {\n    icon: <MessageSquare size={12} />,\n    label: 'Ù…Ø­Ø§Ø¯Ø«Ø©',\n    color: '#89b4fa',\n    bg: '#89b4fa',\n  },\n  'self-improve': {\n    icon: <RefreshCw size={12} />,\n    label: 'ØªØ­Ø³ÙŠÙ† Ø°Ø§ØªÙŠ',\n    color: '#a6e3a1',\n    bg: '#a6e3a1',\n  },\n  hybrid: {\n    icon: <Zap size={12} />,\n    label: 'Ù‡Ø¬ÙŠÙ†',\n    color: '#cba6f7',\n    bg: '#cba6f7',\n  },\n};\n\n// â”€â”€â”€ OODA Phase Indicator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction OODAPhaseIndicator({ currentPhase }: OODAPhaseIndicatorProps) {\n  const phases = ['OBSERVE', 'ORIENT', 'DECIDE', 'ACT', 'VERIFY'];\n  const currentIdx = phases.indexOf(currentPhase);\n\n  return (\n    <div className=\"flex items-center gap-1\">\n      {phases.map((phase, idx) => {\n        const config = PHASE_CONFIG[phase];\n        const isActive = idx === currentIdx;\n        const isPast = idx < currentIdx;\n        const opacity = isActive ? 1 : isPast ? 0.6 : 0.2;\n\n        return (\n          <React.Fragment key={phase}>\n            <div\n              className=\"flex items-center gap-0.5 transition-all duration-300\"\n              style={{ opacity }}\n              title={`${config.labelAr} (${config.label})`}\n            >\n              <span style={{ color: config.color }}>{config.icon}</span>\n              {isActive && (\n                <span\n                  className=\"text-[9px] font-medium\"\n                  style={{ color: config.color }}\n                >\n                  {config.labelAr}\n                </span>\n              )}\n            </div>\n            {idx < phases.length - 1 && (\n              <div\n                className=\"w-3 h-px transition-all duration-300\"\n                style={{\n                  backgroundColor: isPast ? config.color : '#313244',\n                  opacity: isPast ? 0.6 : 0.3,\n                }}\n              />\n            )}\n          </React.Fragment>\n        );\n      })}\n    </div>\n  );\n}\n\n// â”€â”€â”€ OODA Status Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport function OODAStatusBar({\n  mode,\n  isOODAReady,\n  autoDetect,\n  onToggleAutoDetect,\n  currentPhase,\n  tokenUsage,\n  lastEvent,\n}: OODAStatusBarProps) {\n  const modeConfig = MODE_CONFIG[mode];\n\n  return (\n    <div className=\"flex items-center justify-between px-3 py-1.5 bg-[#11111b] border-b border-[#313244] text-[10px]\">\n      {/* Left: Mode indicator */}\n      <div className=\"flex items-center gap-2\">\n        {/* Mode badge */}\n        <div\n          className=\"flex items-center gap-1 px-2 py-0.5 rounded-full\"\n          style={{\n            backgroundColor: `${modeConfig.bg}15`,\n            color: modeConfig.color,\n          }}\n        >\n          {modeConfig.icon}\n          <span className=\"font-medium\">{modeConfig.label}</span>\n        </div>\n\n        {/* OODA readiness dot */}\n        {isOODAReady ? (\n          <div className=\"flex items-center gap-1 text-[#a6e3a1]\">\n            <span className=\"w-1.5 h-1.5 rounded-full bg-[#a6e3a1] animate-pulse\" />\n            <span>OODA</span>\n          </div>\n        ) : (\n          <div className=\"flex items-center gap-1 text-[#6c7086]\">\n            <span className=\"w-1.5 h-1.5 rounded-full bg-[#6c7086]\" />\n            <span>OODA ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„</span>\n          </div>\n        )}\n      </div>\n\n      {/* Center: Phase indicator (when in self-improve mode) */}\n      {mode === 'self-improve' && currentPhase && (\n        <OODAPhaseIndicator currentPhase={currentPhase} />\n      )}\n\n      {/* Right: Auto-detect toggle + tokens */}\n      <div className=\"flex items-center gap-3\">\n        {/* Token usage */}\n        {tokenUsage !== undefined && tokenUsage > 0 && (\n          <span className=\"text-[#6c7086]\">\n            ğŸª™ {tokenUsage.toLocaleString()}\n          </span>\n        )}\n\n        {/* Auto-detect toggle */}\n        <button\n          onClick={() => onToggleAutoDetect(!autoDetect)}\n          className=\"flex items-center gap-1 text-[#6c7086] hover:text-[#cdd6f4] transition-colors\"\n          title={\n            autoDetect ? 'Ø§Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…ÙØ¹Ù‘Ù„' : 'Ø§Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ø¹Ø·Ù‘Ù„'\n          }\n        >\n          {autoDetect ? (\n            <ToggleRight size={14} className=\"text-[#a6e3a1]\" />\n          ) : (\n            <ToggleLeft size={14} />\n          )}\n          <span>ØªÙ„Ù‚Ø§Ø¦ÙŠ</span>\n        </button>\n      </div>\n    </div>\n  );\n}\n\n// â”€â”€â”€ Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport { OODAPhaseIndicator };\nexport type { OODAStatusBarProps, OODAPhaseIndicatorProps };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\agent-panel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\agent-settings.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'ProviderId' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 23,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 23,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'modelId' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 509,
        "column": 37,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 509,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\n/**\n * CodeForge IDE â€” Agent Settings v2.0 (Phase 9)\n * Settings panel for configuring the AI agent:\n * provider selection, API key, model, temperature, language,\n * GitHub PAT, and NEW: Groq/OODA integration with ModelSelector.\n *\n * v2.0 Changes:\n *   - Replaced static <select> with ModelSelector component for Groq\n *   - Added OODA Self-Improve section with Groq API key\n *   - Added OODA status indicator\n *   - Backward compatible: non-Groq providers still use legacy dropdown\n */\n\nimport React, { useState } from 'react';\nimport { useAgentStore } from '@/lib/stores/agent-store';\nimport {\n  getAllProviders,\n  getProvider,\n  validateApiKeyFormat,\n} from '@/lib/agent/providers';\nimport type { ProviderId } from '@/lib/agent/types';\nimport { ModelSelector } from './model-selector';\nimport {\n  Settings,\n  Eye,\n  EyeOff,\n  ExternalLink,\n  CheckCircle2,\n  XCircle,\n  Globe,\n  Cpu,\n  Key,\n  Thermometer,\n  Languages,\n  Github,\n  Brain,\n  Zap,\n  RefreshCw,\n} from 'lucide-react';\n\ninterface AgentSettingsProps {\n  isOpen: boolean;\n  onClose: () => void;\n  /** Optional: Groq API key for OODA (can be separate from main provider key) */\n  groqApiKey?: string;\n  onGroqApiKeyChange?: (key: string) => void;\n  /** Optional: OODA readiness status */\n  isOODAReady?: boolean;\n  /** Optional: OODA model */\n  oodaModel?: string;\n}\n\nexport function AgentSettings({\n  isOpen,\n  onClose,\n  groqApiKey: externalGroqKey,\n  onGroqApiKeyChange,\n  isOODAReady = false,\n  oodaModel,\n}: AgentSettingsProps) {\n  const {\n    config,\n    setProvider,\n    setApiKey,\n    setModel,\n    setGitHubToken,\n    updateConfig,\n  } = useAgentStore();\n  const [showApiKey, setShowApiKey] = useState(false);\n  const [showGithubToken, setShowGithubToken] = useState(false);\n  const [showGroqKey, setShowGroqKey] = useState(false);\n  const [tempApiKey, setTempApiKey] = useState(config.apiKey);\n  const [tempGithubToken, setTempGithubToken] = useState(\n    config.githubToken || ''\n  );\n  const [tempGroqKey, setTempGroqKey] = useState(externalGroqKey || '');\n  const [activeTab, setActiveTab] = useState<'provider' | 'ooda'>('provider');\n\n  if (!isOpen) return null;\n\n  const providers = getAllProviders();\n  const currentProvider = getProvider(config.provider);\n  const isKeyValid = validateApiKeyFormat(config.provider, tempApiKey);\n  const isGithubTokenValid = tempGithubToken.length > 20;\n  const isGroqKeyValid =\n    tempGroqKey.startsWith('gsk_') && tempGroqKey.length > 20;\n  const isGroqProvider = config.provider === 'groq';\n\n  const handleSaveApiKey = () => {\n    setApiKey(tempApiKey);\n  };\n\n  const handleSaveGithubToken = () => {\n    setGitHubToken(tempGithubToken);\n  };\n\n  const handleSaveGroqKey = () => {\n    onGroqApiKeyChange?.(tempGroqKey);\n  };\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center\">\n      {/* Backdrop */}\n      <div className=\"absolute inset-0 bg-black/60\" onClick={onClose} />\n\n      {/* Dialog */}\n      <div className=\"relative w-[520px] max-h-[90vh] bg-[#1e1e2e] rounded-2xl border border-[#313244] shadow-2xl overflow-hidden\">\n        {/* Header */}\n        <div className=\"flex items-center justify-between px-5 py-4 border-b border-[#313244]\">\n          <div className=\"flex items-center gap-2\">\n            <Settings size={18} className=\"text-[#89b4fa]\" />\n            <h2 className=\"text-sm font-semibold text-[#cdd6f4]\">\n              Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ÙˆÙƒÙŠÙ„ Ø§Ù„Ø°ÙƒÙŠ\n            </h2>\n          </div>\n          <button\n            onClick={onClose}\n            className=\"text-[#6c7086] hover:text-[#cdd6f4] transition-colors\"\n          >\n            âœ•\n          </button>\n        </div>\n\n        {/* Tab Navigation */}\n        <div className=\"flex border-b border-[#313244]\">\n          <button\n            onClick={() => setActiveTab('provider')}\n            className={`flex-1 px-4 py-2.5 text-xs font-medium transition-colors flex items-center justify-center gap-1.5 ${\n              activeTab === 'provider'\n                ? 'text-[#89b4fa] border-b-2 border-[#89b4fa] bg-[#89b4fa]/5'\n                : 'text-[#6c7086] hover:text-[#cdd6f4]'\n            }`}\n          >\n            <Cpu size={12} />\n            Ø§Ù„Ù…Ø²ÙˆØ¯ ÙˆØ§Ù„Ù†Ù…ÙˆØ°Ø¬\n          </button>\n          <button\n            onClick={() => setActiveTab('ooda')}\n            className={`flex-1 px-4 py-2.5 text-xs font-medium transition-colors flex items-center justify-center gap-1.5 ${\n              activeTab === 'ooda'\n                ? 'text-[#a6e3a1] border-b-2 border-[#a6e3a1] bg-[#a6e3a1]/5'\n                : 'text-[#6c7086] hover:text-[#cdd6f4]'\n            }`}\n          >\n            <Brain size={12} />\n            Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠ (OODA)\n            {isOODAReady && (\n              <span className=\"w-1.5 h-1.5 rounded-full bg-[#a6e3a1] animate-pulse\" />\n            )}\n          </button>\n        </div>\n\n        {/* Content */}\n        <div className=\"px-5 py-4 space-y-5 overflow-y-auto max-h-[calc(90vh-160px)]\">\n          {/* â•â•â• TAB 1: Provider & Model â•â•â• */}\n          {activeTab === 'provider' && (\n            <>\n              {/* Provider Selection */}\n              <div>\n                <label className=\"flex items-center gap-1.5 text-xs font-medium text-[#cdd6f4] mb-2\">\n                  <Globe size={12} className=\"text-[#89b4fa]\" />\n                  Ø§Ù„Ù…Ø²ÙˆØ¯ (Provider)\n                </label>\n                <div className=\"grid grid-cols-2 gap-2\">\n                  {providers.map((p) => (\n                    <button\n                      key={p.id}\n                      onClick={() => {\n                        setProvider(p.id);\n                        setTempApiKey('');\n                      }}\n                      className={`p-3 rounded-xl border text-left transition-all ${\n                        config.provider === p.id\n                          ? 'border-[#89b4fa] bg-[#89b4fa]/10'\n                          : 'border-[#313244] bg-[#181825] hover:border-[#45475a]'\n                      }`}\n                    >\n                      <div className=\"text-sm font-medium text-[#cdd6f4]\">\n                        {p.name}\n                      </div>\n                      <div className=\"text-[10px] text-[#6c7086] mt-0.5\">\n                        {p.description}\n                      </div>\n                    </button>\n                  ))}\n                </div>\n              </div>\n\n              {/* API Key */}\n              <div>\n                <label className=\"flex items-center gap-1.5 text-xs font-medium text-[#cdd6f4] mb-2\">\n                  <Key size={12} className=\"text-[#f9e2af]\" />\n                  Ù…ÙØªØ§Ø­ API\n                  <a\n                    href={currentProvider.apiKeyUrl}\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                    className=\"text-[#89b4fa] hover:underline flex items-center gap-0.5\"\n                  >\n                    <ExternalLink size={10} />\n                    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙØªØ§Ø­\n                  </a>\n                </label>\n                <div className=\"flex gap-2\">\n                  <div className=\"flex-1 relative\">\n                    <input\n                      type={showApiKey ? 'text' : 'password'}\n                      value={tempApiKey}\n                      onChange={(e) => setTempApiKey(e.target.value)}\n                      placeholder={currentProvider.apiKeyPlaceholder}\n                      className=\"w-full px-3 py-2 rounded-lg bg-[#313244] text-[#cdd6f4] text-sm font-mono placeholder:text-[#45475a] outline-none focus:ring-1 focus:ring-[#89b4fa]/50\"\n                      dir=\"ltr\"\n                    />\n                    <button\n                      onClick={() => setShowApiKey(!showApiKey)}\n                      className=\"absolute left-2 top-1/2 -translate-y-1/2 text-[#6c7086] hover:text-[#cdd6f4]\"\n                    >\n                      {showApiKey ? <EyeOff size={14} /> : <Eye size={14} />}\n                    </button>\n                  </div>\n                  <button\n                    onClick={handleSaveApiKey}\n                    disabled={!tempApiKey}\n                    className=\"px-4 py-2 rounded-lg bg-[#89b4fa] text-[#1e1e2e] text-xs font-medium hover:bg-[#89b4fa]/80 disabled:opacity-30 transition-colors\"\n                  >\n                    Ø­ÙØ¸\n                  </button>\n                </div>\n                {tempApiKey && (\n                  <div\n                    className={`flex items-center gap-1 mt-1.5 text-[10px] ${isKeyValid ? 'text-[#a6e3a1]' : 'text-[#f38ba8]'}`}\n                  >\n                    {isKeyValid ? (\n                      <CheckCircle2 size={10} />\n                    ) : (\n                      <XCircle size={10} />\n                    )}\n                    {isKeyValid\n                      ? 'ØµÙŠØºØ© Ø§Ù„Ù…ÙØªØ§Ø­ ØµØ­ÙŠØ­Ø©'\n                      : 'ØµÙŠØºØ© Ø§Ù„Ù…ÙØªØ§Ø­ ØºÙŠØ± ØµØ­ÙŠØ­Ø©'}\n                  </div>\n                )}\n              </div>\n\n              {/* GitHub Personal Access Token */}\n              <div>\n                <label className=\"flex items-center gap-1.5 text-xs font-medium text-[#cdd6f4] mb-2\">\n                  <Github size={12} className=\"text-[#cba6f7]\" />\n                  GitHub Token\n                  <a\n                    href=\"https://github.com/settings/tokens/new?scopes=repo,read:org&description=CodeForge+IDE+Agent\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                    className=\"text-[#89b4fa] hover:underline flex items-center gap-0.5\"\n                  >\n                    <ExternalLink size={10} />\n                    Ø¥Ù†Ø´Ø§Ø¡ ØªÙˆÙƒÙ†\n                  </a>\n                </label>\n                <div className=\"flex gap-2\">\n                  <div className=\"flex-1 relative\">\n                    <input\n                      type={showGithubToken ? 'text' : 'password'}\n                      value={tempGithubToken}\n                      onChange={(e) => setTempGithubToken(e.target.value)}\n                      placeholder=\"ghp_... Ø£Ùˆ github_pat_...\"\n                      className=\"w-full px-3 py-2 rounded-lg bg-[#313244] text-[#cdd6f4] text-sm font-mono placeholder:text-[#45475a] outline-none focus:ring-1 focus:ring-[#cba6f7]/50\"\n                      dir=\"ltr\"\n                    />\n                    <button\n                      onClick={() => setShowGithubToken(!showGithubToken)}\n                      className=\"absolute left-2 top-1/2 -translate-y-1/2 text-[#6c7086] hover:text-[#cdd6f4]\"\n                    >\n                      {showGithubToken ? (\n                        <EyeOff size={14} />\n                      ) : (\n                        <Eye size={14} />\n                      )}\n                    </button>\n                  </div>\n                  <button\n                    onClick={handleSaveGithubToken}\n                    disabled={!tempGithubToken}\n                    className=\"px-4 py-2 rounded-lg bg-[#cba6f7] text-[#1e1e2e] text-xs font-medium hover:bg-[#cba6f7]/80 disabled:opacity-30 transition-colors\"\n                  >\n                    Ø­ÙØ¸\n                  </button>\n                </div>\n                {tempGithubToken && (\n                  <div\n                    className={`flex items-center gap-1 mt-1.5 text-[10px] ${isGithubTokenValid ? 'text-[#a6e3a1]' : 'text-[#f38ba8]'}`}\n                  >\n                    {isGithubTokenValid ? (\n                      <CheckCircle2 size={10} />\n                    ) : (\n                      <XCircle size={10} />\n                    )}\n                    {isGithubTokenValid\n                      ? 'ØªÙˆÙƒÙ† GitHub ØµØ§Ù„Ø­'\n                      : 'Ø§Ù„ØªÙˆÙƒÙ† Ù‚ØµÙŠØ± Ø¬Ø¯Ø§Ù‹'}\n                  </div>\n                )}\n                <p className=\"text-[9px] text-[#45475a] mt-1.5\">\n                  ÙŠØ³ØªØ®Ø¯Ù… Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªÙˆØ¯Ø¹Ø§ØªØŒ Ø±ÙØ¹ Ù…Ù„ÙØ§ØªØŒ Ø¥Ù†Ø´Ø§Ø¡ ÙØ±ÙˆØ¹ Ùˆ Pull Requests\n                  Ø¹Ù„Ù‰ GitHub. Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:{' '}\n                  <span className=\"text-[#89b4fa] font-mono\">repo</span>\n                </p>\n              </div>\n\n              {/* Model Selection â€” Enhanced for Groq */}\n              <div>\n                <label className=\"flex items-center gap-1.5 text-xs font-medium text-[#cdd6f4] mb-2\">\n                  <Cpu size={12} className=\"text-[#a6e3a1]\" />\n                  Ø§Ù„Ù†Ù…ÙˆØ°Ø¬\n                  {isGroqProvider && (\n                    <span className=\"text-[9px] text-[#a6e3a1] bg-[#a6e3a1]/10 px-1.5 py-0.5 rounded-full\">\n                      14 Ù†Ù…ÙˆØ°Ø¬ Ù…ØªØ§Ø­\n                    </span>\n                  )}\n                </label>\n\n                {isGroqProvider ? (\n                  /* â•â•â• NEW: ModelSelector for Groq â•â•â• */\n                  <ModelSelector\n                    selectedModel={config.model}\n                    onModelChange={(modelId) => setModel(modelId)}\n                    disabled={!config.apiKey}\n                  />\n                ) : (\n                  /* Legacy dropdown for other providers */\n                  <select\n                    value={config.model}\n                    onChange={(e) => setModel(e.target.value)}\n                    className=\"w-full px-3 py-2 rounded-lg bg-[#313244] text-[#cdd6f4] text-sm outline-none focus:ring-1 focus:ring-[#89b4fa]/50 appearance-none cursor-pointer\"\n                  >\n                    {currentProvider.models.map((m) => (\n                      <option key={m.id} value={m.id}>\n                        {m.name} ({(m.contextWindow / 1000).toFixed(0)}K\n                        context)\n                      </option>\n                    ))}\n                  </select>\n                )}\n              </div>\n\n              {/* Temperature */}\n              <div>\n                <label className=\"flex items-center justify-between text-xs font-medium text-[#cdd6f4] mb-2\">\n                  <span className=\"flex items-center gap-1.5\">\n                    <Thermometer size={12} className=\"text-[#fab387]\" />\n                    Ø¯Ø±Ø¬Ø© Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ (Temperature)\n                  </span>\n                  <span className=\"font-mono text-[#89b4fa]\">\n                    {config.temperature}\n                  </span>\n                </label>\n                <input\n                  type=\"range\"\n                  min=\"0\"\n                  max=\"1\"\n                  step=\"0.1\"\n                  value={config.temperature}\n                  onChange={(e) =>\n                    updateConfig({ temperature: parseFloat(e.target.value) })\n                  }\n                  className=\"w-full accent-[#89b4fa]\"\n                />\n                <div className=\"flex justify-between text-[9px] text-[#45475a] mt-1\">\n                  <span>Ø¯Ù‚ÙŠÙ‚ (0.0)</span>\n                  <span>Ø¥Ø¨Ø¯Ø§Ø¹ÙŠ (1.0)</span>\n                </div>\n              </div>\n\n              {/* Language */}\n              <div>\n                <label className=\"flex items-center gap-1.5 text-xs font-medium text-[#cdd6f4] mb-2\">\n                  <Languages size={12} className=\"text-[#cba6f7]\" />\n                  Ù„ØºØ© Ø§Ù„ØªÙˆØ§ØµÙ„\n                </label>\n                <div className=\"flex gap-2\">\n                  <button\n                    onClick={() => updateConfig({ language: 'ar' })}\n                    className={`flex-1 py-2 rounded-lg text-xs font-medium transition-colors ${\n                      config.language === 'ar'\n                        ? 'bg-[#89b4fa] text-[#1e1e2e]'\n                        : 'bg-[#313244] text-[#6c7086] hover:text-[#cdd6f4]'\n                    }`}\n                  >\n                    Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©\n                  </button>\n                  <button\n                    onClick={() => updateConfig({ language: 'en' })}\n                    className={`flex-1 py-2 rounded-lg text-xs font-medium transition-colors ${\n                      config.language === 'en'\n                        ? 'bg-[#89b4fa] text-[#1e1e2e]'\n                        : 'bg-[#313244] text-[#6c7086] hover:text-[#cdd6f4]'\n                    }`}\n                  >\n                    English\n                  </button>\n                </div>\n              </div>\n            </>\n          )}\n\n          {/* â•â•â• TAB 2: OODA Self-Improvement â•â•â• */}\n          {activeTab === 'ooda' && (\n            <>\n              {/* OODA Status Card */}\n              <div\n                className={`p-4 rounded-xl border ${\n                  isOODAReady\n                    ? 'border-[#a6e3a1]/30 bg-[#a6e3a1]/5'\n                    : 'border-[#f38ba8]/30 bg-[#f38ba8]/5'\n                }`}\n              >\n                <div className=\"flex items-center gap-3\">\n                  <div\n                    className={`w-10 h-10 rounded-xl flex items-center justify-center ${\n                      isOODAReady ? 'bg-[#a6e3a1]/20' : 'bg-[#f38ba8]/20'\n                    }`}\n                  >\n                    {isOODAReady ? (\n                      <RefreshCw size={20} className=\"text-[#a6e3a1]\" />\n                    ) : (\n                      <Brain size={20} className=\"text-[#f38ba8]\" />\n                    )}\n                  </div>\n                  <div>\n                    <div className=\"text-sm font-medium text-[#cdd6f4]\">\n                      {isOODAReady ? 'Ù…Ø­Ø±Ùƒ OODA Ù†Ø´Ø· âœ¨' : 'Ù…Ø­Ø±Ùƒ OODA ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„'}\n                    </div>\n                    <div className=\"text-[10px] text-[#6c7086]\">\n                      {isOODAReady\n                        ? `Ø§Ù„Ù†Ù…ÙˆØ°Ø¬: ${oodaModel || 'llama-3.3-70b-versatile'}`\n                        : 'Ø£Ø¶Ù Ù…ÙØªØ§Ø­ Groq API Ù„ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠ'}\n                    </div>\n                  </div>\n                </div>\n              </div>\n\n              {/* Groq API Key */}\n              <div>\n                <label className=\"flex items-center gap-1.5 text-xs font-medium text-[#cdd6f4] mb-2\">\n                  <Zap size={12} className=\"text-[#f9e2af]\" />\n                  Ù…ÙØªØ§Ø­ Groq API\n                  <a\n                    href=\"https://console.groq.com/keys\"\n                    target=\"_blank\"\n                    rel=\"noopener noreferrer\"\n                    className=\"text-[#89b4fa] hover:underline flex items-center gap-0.5\"\n                  >\n                    <ExternalLink size={10} />\n                    Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙØªØ§Ø­ Ù…Ø¬Ø§Ù†ÙŠ\n                  </a>\n                </label>\n                <div className=\"flex gap-2\">\n                  <div className=\"flex-1 relative\">\n                    <input\n                      type={showGroqKey ? 'text' : 'password'}\n                      value={tempGroqKey}\n                      onChange={(e) => setTempGroqKey(e.target.value)}\n                      placeholder=\"gsk_...\"\n                      className=\"w-full px-3 py-2 rounded-lg bg-[#313244] text-[#cdd6f4] text-sm font-mono placeholder:text-[#45475a] outline-none focus:ring-1 focus:ring-[#f9e2af]/50\"\n                      dir=\"ltr\"\n                    />\n                    <button\n                      onClick={() => setShowGroqKey(!showGroqKey)}\n                      className=\"absolute left-2 top-1/2 -translate-y-1/2 text-[#6c7086] hover:text-[#cdd6f4]\"\n                    >\n                      {showGroqKey ? <EyeOff size={14} /> : <Eye size={14} />}\n                    </button>\n                  </div>\n                  <button\n                    onClick={handleSaveGroqKey}\n                    disabled={!tempGroqKey}\n                    className=\"px-4 py-2 rounded-lg bg-[#f9e2af] text-[#1e1e2e] text-xs font-medium hover:bg-[#f9e2af]/80 disabled:opacity-30 transition-colors\"\n                  >\n                    ØªÙØ¹ÙŠÙ„\n                  </button>\n                </div>\n                {tempGroqKey && (\n                  <div\n                    className={`flex items-center gap-1 mt-1.5 text-[10px] ${isGroqKeyValid ? 'text-[#a6e3a1]' : 'text-[#f38ba8]'}`}\n                  >\n                    {isGroqKeyValid ? (\n                      <CheckCircle2 size={10} />\n                    ) : (\n                      <XCircle size={10} />\n                    )}\n                    {isGroqKeyValid\n                      ? 'ØµÙŠØºØ© Ø§Ù„Ù…ÙØªØ§Ø­ ØµØ­ÙŠØ­Ø©'\n                      : 'Ø§Ù„Ù…ÙØªØ§Ø­ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨Ù€ gsk_'}\n                  </div>\n                )}\n              </div>\n\n              {/* OODA Model Selector */}\n              {isOODAReady && (\n                <div>\n                  <label className=\"flex items-center gap-1.5 text-xs font-medium text-[#cdd6f4] mb-2\">\n                    <Brain size={12} className=\"text-[#a6e3a1]\" />\n                    Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠ\n                  </label>\n                  <ModelSelector\n                    selectedModel={oodaModel || 'llama-3.3-70b-versatile'}\n                    onModelChange={(modelId) => {\n                      // This will be handled by the parent component\n                      // through the OODABridge configuration\n                    }}\n                    showDetails={true}\n                  />\n                </div>\n              )}\n\n              {/* How it works */}\n              <div className=\"p-3 rounded-xl bg-[#181825] border border-[#313244]\">\n                <div className=\"text-[10px] font-medium text-[#6c7086] mb-2\">\n                  ÙƒÙŠÙ ÙŠØ¹Ù…Ù„ Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠØŸ\n                </div>\n                <div className=\"space-y-1.5\">\n                  {[\n                    {\n                      icon: 'ğŸ‘ï¸',\n                      label: 'Ø±ØµØ¯',\n                      desc: 'ÙŠÙƒØªØ´Ù Ø§Ù„Ù…Ø´ÙƒÙ„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù…Ù† ÙˆØµÙÙƒ',\n                    },\n                    {\n                      icon: 'ğŸ§­',\n                      label: 'ØªØ­Ù„ÙŠÙ„',\n                      desc: 'ÙŠØ­Ù„Ù„ Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ø¬Ø°Ø±ÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ',\n                    },\n                    {\n                      icon: 'ğŸ“‹',\n                      label: 'Ù‚Ø±Ø§Ø±',\n                      desc: 'ÙŠÙƒØªØ¨ Ø®Ø·Ø© Ø¥ØµÙ„Ø§Ø­ Ù…Ø¹ ÙƒÙˆØ¯ Ø¬Ø§Ù‡Ø²',\n                    },\n                    {\n                      icon: 'âš¡',\n                      label: 'ØªÙ†ÙÙŠØ°',\n                      desc: 'ÙŠØ·Ø¨Ù‚ Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ù…Ø¹ Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©',\n                    },\n                    {\n                      icon: 'âœ…',\n                      label: 'ØªØ­Ù‚Ù‚',\n                      desc: 'ÙŠÙØ­Øµ 6 ÙØ­ÙˆØµØ§Øª Ø¢Ù„ÙŠØ© Ù„Ù„ØªØ£ÙƒØ¯',\n                    },\n                  ].map((step) => (\n                    <div key={step.label} className=\"flex items-center gap-2\">\n                      <span className=\"text-xs\">{step.icon}</span>\n                      <span className=\"text-[10px] text-[#cdd6f4] font-medium w-10\">\n                        {step.label}\n                      </span>\n                      <span className=\"text-[10px] text-[#6c7086]\">\n                        {step.desc}\n                      </span>\n                    </div>\n                  ))}\n                </div>\n              </div>\n\n              {/* Sync hint */}\n              {config.provider === 'groq' && (\n                <div className=\"flex items-center gap-2 p-2 rounded-lg bg-[#89b4fa]/10 border border-[#89b4fa]/20\">\n                  <Zap size={12} className=\"text-[#89b4fa]\" />\n                  <span className=\"text-[10px] text-[#89b4fa]\">\n                    ØªÙ„Ù…ÙŠØ­: Ø§Ù„Ù…Ø²ÙˆØ¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù‡Ùˆ Groq â€” ÙŠÙ…ÙƒÙ† Ù…Ø´Ø§Ø±ÙƒØ© Ù†ÙØ³ Ø§Ù„Ù…ÙØªØ§Ø­ Ù…Ø¹\n                    Ù…Ø­Ø±Ùƒ OODA\n                  </span>\n                </div>\n              )}\n            </>\n          )}\n        </div>\n\n        {/* Footer */}\n        <div className=\"px-5 py-3 border-t border-[#313244] bg-[#181825]\">\n          <button\n            onClick={onClose}\n            className=\"w-full py-2 rounded-lg bg-[#313244] hover:bg-[#45475a] text-[#cdd6f4] text-xs font-medium transition-colors\"\n          >\n            Ø¥ØºÙ„Ø§Ù‚\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\agent-toggle-button.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\approval-dialog.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\audit-log-viewer.tsx",
    "messages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'logger'. Either include it or remove the dependency array.",
        "line": 120,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 120,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [logger]",
            "fix": { "range": [3759, 3761], "text": "[logger]" }
          }
        ]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useMemo has a missing dependency: 'logger'. Either include it or remove the dependency array.",
        "line": 136,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 136,
        "endColumn": 67,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [logger, filterTool, filterRisk, filterSuccess, searchQuery]",
            "fix": {
              "range": [4302, 4363],
              "text": "[logger, filterTool, filterRisk, filterSuccess, searchQuery]"
            }
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\n/**\n * CodeForge IDE â€” Audit Log Viewer\n * React component for browsing, filtering, and exporting agent audit logs.\n */\n\nimport React, { useState, useEffect, useMemo } from 'react';\nimport {\n  getAuditLogger,\n  type AuditLogEntryEnhanced,\n  type AuditLogStats,\n} from '@/lib/agent/audit-logger';\n\n// â”€â”€â”€ Risk Level Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction RiskBadge({ level }: { level?: string }) {\n  const colors: Record<string, string> = {\n    auto: 'bg-green-500/20 text-green-400',\n    notify: 'bg-yellow-500/20 text-yellow-400',\n    confirm: 'bg-red-500/20 text-red-400',\n  };\n  return (\n    <span\n      className={`px-2 py-0.5 rounded text-xs font-mono ${colors[level || 'auto'] || colors.auto}`}\n    >\n      {level || 'auto'}\n    </span>\n  );\n}\n\n// â”€â”€â”€ Status Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction StatusBadge({ entry }: { entry: AuditLogEntryEnhanced }) {\n  if (!entry.approved) {\n    return (\n      <span className=\"px-2 py-0.5 rounded text-xs bg-red-500/20 text-red-400\">\n        Ù…Ø±ÙÙˆØ¶\n      </span>\n    );\n  }\n  if (entry.result?.success) {\n    return (\n      <span className=\"px-2 py-0.5 rounded text-xs bg-green-500/20 text-green-400\">\n        Ù†Ø¬Ø­ âœ“\n      </span>\n    );\n  }\n  if (entry.result && !entry.result.success) {\n    return (\n      <span className=\"px-2 py-0.5 rounded text-xs bg-red-500/20 text-red-400\">\n        ÙØ´Ù„ âœ—\n      </span>\n    );\n  }\n  return (\n    <span className=\"px-2 py-0.5 rounded text-xs bg-gray-500/20 text-gray-400\">\n      â€”\n    </span>\n  );\n}\n\n// â”€â”€â”€ Stats Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction StatsPanel({ stats }: { stats: AuditLogStats }) {\n  const successRate =\n    stats.totalOperations > 0\n      ? Math.round((stats.successCount / stats.totalOperations) * 100)\n      : 0;\n\n  return (\n    <div className=\"grid grid-cols-2 md:grid-cols-4 gap-3 mb-4\">\n      <div className=\"bg-[#1e1e2e] rounded-lg p-3 border border-[#313244]\">\n        <div className=\"text-2xl font-bold text-white\">\n          {stats.totalOperations}\n        </div>\n        <div className=\"text-xs text-gray-400\">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª</div>\n      </div>\n      <div className=\"bg-[#1e1e2e] rounded-lg p-3 border border-[#313244]\">\n        <div className=\"text-2xl font-bold text-green-400\">{successRate}%</div>\n        <div className=\"text-xs text-gray-400\">Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø¬Ø§Ø­</div>\n      </div>\n      <div className=\"bg-[#1e1e2e] rounded-lg p-3 border border-[#313244]\">\n        <div className=\"text-2xl font-bold text-yellow-400\">\n          {stats.rejectedCount}\n        </div>\n        <div className=\"text-xs text-gray-400\">Ù…Ø±ÙÙˆØ¶Ø©</div>\n      </div>\n      <div className=\"bg-[#1e1e2e] rounded-lg p-3 border border-[#313244]\">\n        <div className=\"text-2xl font-bold text-blue-400\">\n          {stats.averageDuration}ms\n        </div>\n        <div className=\"text-xs text-gray-400\">Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø¯Ø©</div>\n      </div>\n    </div>\n  );\n}\n\n// â”€â”€â”€ Main Component â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport function AuditLogViewer() {\n  const logger = getAuditLogger();\n  const [entries, setEntries] = useState<AuditLogEntryEnhanced[]>([]);\n  const [stats, setStats] = useState<AuditLogStats | null>(null);\n  const [filterTool, setFilterTool] = useState<string>('');\n  const [filterRisk, setFilterRisk] = useState<string>('');\n  const [filterSuccess, setFilterSuccess] = useState<string>('');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [expandedId, setExpandedId] = useState<string | null>(null);\n  const [showStats, setShowStats] = useState(true);\n\n  // Load and subscribe\n  useEffect(() => {\n    const refresh = () => {\n      setEntries(logger.getAll());\n      setStats(logger.getStats());\n    };\n    refresh();\n    return logger.subscribe(refresh);\n  }, []);\n\n  // Get unique tool names for filter dropdown\n  const toolNames = useMemo(() => {\n    const names = new Set(entries.map((e) => e.toolName));\n    return Array.from(names).sort();\n  }, [entries]);\n\n  // Apply filters\n  const filteredEntries = useMemo(() => {\n    return logger.filter({\n      toolName: filterTool || undefined,\n      riskLevel: (filterRisk as 'auto' | 'notify' | 'confirm') || undefined,\n      success: filterSuccess === '' ? undefined : filterSuccess === 'true',\n      searchQuery: searchQuery || undefined,\n    });\n  }, [entries, filterTool, filterRisk, filterSuccess, searchQuery]);\n\n  const formatTime = (ts: number) => {\n    const d = new Date(ts);\n    return d.toLocaleString('ar-DZ', {\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      day: '2-digit',\n      month: '2-digit',\n    });\n  };\n\n  return (\n    <div className=\"flex flex-col h-full bg-[#11111b] text-white p-4 overflow-y-auto\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between mb-4\">\n        <h2 className=\"text-lg font-bold flex items-center gap-2\">\n          ğŸ“‹ Ø³Ø¬Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª (Audit Log)\n        </h2>\n        <div className=\"flex gap-2\">\n          <button\n            onClick={() => setShowStats(!showStats)}\n            className=\"px-3 py-1 text-xs rounded bg-[#313244] hover:bg-[#45475a] transition-colors\"\n          >\n            {showStats ? 'Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª' : 'Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª'}\n          </button>\n          <button\n            onClick={() => logger.downloadExport('json')}\n            className=\"px-3 py-1 text-xs rounded bg-blue-600/30 text-blue-400 hover:bg-blue-600/50 transition-colors\"\n          >\n            ğŸ“¥ JSON\n          </button>\n          <button\n            onClick={() => logger.downloadExport('csv')}\n            className=\"px-3 py-1 text-xs rounded bg-green-600/30 text-green-400 hover:bg-green-600/50 transition-colors\"\n          >\n            ğŸ“¥ CSV\n          </button>\n          <button\n            onClick={() => {\n              if (confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù ÙƒÙ„ Ø§Ù„Ø³Ø¬Ù„Ø§ØªØŸ')) logger.clear();\n            }}\n            className=\"px-3 py-1 text-xs rounded bg-red-600/30 text-red-400 hover:bg-red-600/50 transition-colors\"\n          >\n            ğŸ—‘ï¸ Ù…Ø³Ø­\n          </button>\n        </div>\n      </div>\n\n      {/* Stats */}\n      {showStats && stats && <StatsPanel stats={stats} />}\n\n      {/* Filters */}\n      <div className=\"flex flex-wrap gap-2 mb-4\">\n        <input\n          type=\"text\"\n          placeholder=\"ğŸ” Ø¨Ø­Ø«...\"\n          value={searchQuery}\n          onChange={(e) => setSearchQuery(e.target.value)}\n          className=\"flex-1 min-w-[150px] px-3 py-1.5 text-sm bg-[#1e1e2e] border border-[#313244] rounded focus:border-blue-500 focus:outline-none\"\n        />\n        <select\n          value={filterTool}\n          onChange={(e) => setFilterTool(e.target.value)}\n          className=\"px-2 py-1.5 text-sm bg-[#1e1e2e] border border-[#313244] rounded\"\n        >\n          <option value=\"\">ÙƒÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Øª</option>\n          {toolNames.map((name) => (\n            <option key={name} value={name}>\n              {name}\n            </option>\n          ))}\n        </select>\n        <select\n          value={filterRisk}\n          onChange={(e) => setFilterRisk(e.target.value)}\n          className=\"px-2 py-1.5 text-sm bg-[#1e1e2e] border border-[#313244] rounded\"\n        >\n          <option value=\"\">ÙƒÙ„ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª</option>\n          <option value=\"auto\">ğŸŸ¢ auto</option>\n          <option value=\"notify\">ğŸŸ¡ notify</option>\n          <option value=\"confirm\">ğŸ”´ confirm</option>\n        </select>\n        <select\n          value={filterSuccess}\n          onChange={(e) => setFilterSuccess(e.target.value)}\n          className=\"px-2 py-1.5 text-sm bg-[#1e1e2e] border border-[#313244] rounded\"\n        >\n          <option value=\"\">ÙƒÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</option>\n          <option value=\"true\">âœ“ Ù†Ø§Ø¬Ø­</option>\n          <option value=\"false\">âœ— ÙØ§Ø´Ù„</option>\n        </select>\n      </div>\n\n      {/* Results count */}\n      <div className=\"text-xs text-gray-500 mb-2\">\n        Ø¹Ø±Ø¶ {filteredEntries.length} Ù…Ù† {entries.length} Ø¹Ù…Ù„ÙŠØ©\n      </div>\n\n      {/* Entries List */}\n      <div className=\"flex-1 space-y-1\">\n        {filteredEntries.length === 0 ? (\n          <div className=\"text-center text-gray-500 py-12\">\n            <div className=\"text-4xl mb-2\">ğŸ“‹</div>\n            <div>Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù…Ù„ÙŠØ§Øª Ù…Ø³Ø¬Ù„Ø© Ø¨Ø¹Ø¯</div>\n          </div>\n        ) : (\n          filteredEntries.map((entry) => (\n            <div\n              key={entry.id}\n              className=\"bg-[#1e1e2e] border border-[#313244] rounded-lg overflow-hidden hover:border-[#45475a] transition-colors cursor-pointer\"\n              onClick={() =>\n                setExpandedId(expandedId === entry.id ? null : entry.id)\n              }\n            >\n              {/* Row Summary */}\n              <div className=\"flex items-center gap-3 px-3 py-2\">\n                <span className=\"text-xs text-gray-500 font-mono w-[110px] shrink-0\">\n                  {formatTime(entry.timestamp)}\n                </span>\n                <span className=\"font-mono text-sm text-blue-400 w-[200px] shrink-0 truncate\">\n                  {entry.toolName}\n                </span>\n                <span className=\"text-xs text-gray-400 flex-1 truncate\">\n                  {entry.summary}\n                </span>\n                <RiskBadge level={entry.riskLevel} />\n                <StatusBadge entry={entry} />\n                {entry.duration && (\n                  <span className=\"text-xs text-gray-500 w-[60px] text-right\">\n                    {entry.duration}ms\n                  </span>\n                )}\n              </div>\n\n              {/* Expanded Details */}\n              {expandedId === entry.id && (\n                <div className=\"border-t border-[#313244] px-3 py-2 bg-[#181825] text-xs\">\n                  <div className=\"grid grid-cols-2 gap-2 mb-2\">\n                    <div>\n                      <span className=\"text-gray-500\">ID:</span>{' '}\n                      <span className=\"font-mono\">{entry.id.slice(0, 8)}</span>\n                    </div>\n                    <div>\n                      <span className=\"text-gray-500\">Session:</span>{' '}\n                      <span className=\"font-mono\">{entry.sessionId}</span>\n                    </div>\n                    <div>\n                      <span className=\"text-gray-500\">Category:</span>{' '}\n                      {entry.category}\n                    </div>\n                    <div>\n                      <span className=\"text-gray-500\">Approved by:</span>{' '}\n                      {entry.approvedBy}\n                    </div>\n                  </div>\n                  <div className=\"mb-2\">\n                    <span className=\"text-gray-500\">Arguments:</span>\n                    <pre className=\"mt-1 p-2 bg-[#11111b] rounded overflow-x-auto text-green-300\">\n                      {JSON.stringify(entry.args, null, 2)}\n                    </pre>\n                  </div>\n                  {entry.result && (\n                    <div>\n                      <span className=\"text-gray-500\">Result:</span>\n                      <pre\n                        className={`mt-1 p-2 bg-[#11111b] rounded overflow-x-auto ${entry.result.success ? 'text-green-300' : 'text-red-300'}`}\n                      >\n                        {JSON.stringify(entry.result, null, 2)}\n                      </pre>\n                    </div>\n                  )}\n                </div>\n              )}\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default AuditLogViewer;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\chat-input.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'Paperclip' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 10,
        "column": 25,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 10,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\n/**\n * CodeForge IDE â€” Chat Input\n * Input component with send button, keyboard shortcuts,\n * and quick action buttons.\n */\n\nimport React, { useState, useRef, useCallback } from 'react';\nimport { Send, Loader2, Paperclip, Sparkles } from 'lucide-react';\n\ninterface ChatInputProps {\n  onSend: (message: string) => Promise<void>;\n  isProcessing: boolean;\n  isConfigured: boolean;\n}\n\nconst QUICK_ACTIONS = [\n  {\n    label: 'Ø§Ø´Ø±Ø­ Ø§Ù„ÙƒÙˆØ¯',\n    prompt: 'Ø§Ø´Ø±Ø­ Ù„ÙŠ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…ÙØªÙˆØ­ Ø­Ø§Ù„ÙŠØ§Ù‹',\n  },\n  { label: 'Ø£ØµÙ„Ø­ Ø§Ù„Ø®Ø·Ø£', prompt: 'Ù‡Ù†Ø§Ùƒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙƒÙˆØ¯ØŒ Ø³Ø§Ø¹Ø¯Ù†ÙŠ ÙÙŠ Ø¥ØµÙ„Ø§Ø­Ù‡' },\n  { label: 'Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø´Ø±ÙˆØ¹', prompt: 'Ø§Ø¹Ø±Ø¶ Ù„ÙŠ Ø¨Ù†ÙŠØ© Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ø­Ø§Ù„ÙŠ' },\n  { label: 'Ø£Ù†Ø´Ø¦ Ù…Ù„Ù', prompt: 'Ø£Ù†Ø´Ø¦ Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ø³Ù… ' },\n];\n\nexport function ChatInput({\n  onSend,\n  isProcessing,\n  isConfigured,\n}: ChatInputProps) {\n  const [input, setInput] = useState('');\n  const [showQuickActions, setShowQuickActions] = useState(false);\n  const textareaRef = useRef<HTMLTextAreaElement>(null);\n\n  const handleSend = useCallback(async () => {\n    const trimmed = input.trim();\n    if (!trimmed || isProcessing || !isConfigured) return;\n\n    setInput('');\n    setShowQuickActions(false);\n\n    // Reset textarea height\n    if (textareaRef.current) {\n      textareaRef.current.style.height = 'auto';\n    }\n\n    await onSend(trimmed);\n  }, [input, isProcessing, isConfigured, onSend]);\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      // Enter to send, Shift+Enter for new line\n      if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        handleSend();\n      }\n    },\n    [handleSend]\n  );\n\n  const handleInput = useCallback(\n    (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n      setInput(e.target.value);\n\n      // Auto-resize\n      const textarea = e.target;\n      textarea.style.height = 'auto';\n      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';\n    },\n    []\n  );\n\n  const handleQuickAction = useCallback((prompt: string) => {\n    setInput(prompt);\n    setShowQuickActions(false);\n    textareaRef.current?.focus();\n  }, []);\n\n  return (\n    <div className=\"border-t border-[#313244] bg-[#181825]\">\n      {/* Quick Actions */}\n      {showQuickActions && (\n        <div className=\"px-3 pt-2 flex flex-wrap gap-1.5\">\n          {QUICK_ACTIONS.map((action) => (\n            <button\n              key={action.label}\n              onClick={() => handleQuickAction(action.prompt)}\n              className=\"px-2.5 py-1 rounded-full bg-[#313244] hover:bg-[#45475a] text-[10px] text-[#cdd6f4] transition-colors\"\n            >\n              {action.label}\n            </button>\n          ))}\n        </div>\n      )}\n\n      {/* Input Area */}\n      <div className=\"flex items-end gap-2 p-3\">\n        <button\n          onClick={() => setShowQuickActions(!showQuickActions)}\n          className={`flex-shrink-0 p-2 rounded-lg transition-colors ${\n            showQuickActions\n              ? 'bg-[#89b4fa]/20 text-[#89b4fa]'\n              : 'text-[#6c7086] hover:text-[#cdd6f4] hover:bg-[#313244]'\n          }`}\n          title=\"Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø³Ø±ÙŠØ¹Ø©\"\n        >\n          <Sparkles size={16} />\n        </button>\n\n        <div className=\"flex-1 relative\">\n          <textarea\n            ref={textareaRef}\n            value={input}\n            onChange={handleInput}\n            onKeyDown={handleKeyDown}\n            placeholder={\n              isConfigured\n                ? 'Ø§ÙƒØªØ¨ Ø±Ø³Ø§Ù„ØªÙƒ... (Enter Ù„Ù„Ø¥Ø±Ø³Ø§Ù„)'\n                : 'Ø£Ø¹Ø¯ Ø¥Ø¹Ø¯Ø§Ø¯ Ù…ÙØªØ§Ø­ API Ø£ÙˆÙ„Ø§Ù‹...'\n            }\n            disabled={!isConfigured || isProcessing}\n            rows={1}\n            className=\"w-full px-3 py-2 rounded-xl bg-[#313244] text-[#cdd6f4] text-sm placeholder:text-[#45475a] resize-none outline-none focus:ring-1 focus:ring-[#89b4fa]/50 disabled:opacity-50 disabled:cursor-not-allowed\"\n            style={{ maxHeight: '120px' }}\n            dir=\"auto\"\n          />\n        </div>\n\n        <button\n          onClick={handleSend}\n          disabled={!input.trim() || isProcessing || !isConfigured}\n          className=\"flex-shrink-0 p-2 rounded-lg bg-[#89b4fa] text-[#1e1e2e] hover:bg-[#89b4fa]/80 disabled:opacity-30 disabled:cursor-not-allowed transition-colors\"\n          title=\"Ø¥Ø±Ø³Ø§Ù„ (Enter)\"\n        >\n          {isProcessing ? (\n            <Loader2 size={16} className=\"animate-spin\" />\n          ) : (\n            <Send size={16} />\n          )}\n        </button>\n      </div>\n\n      {/* Keyboard shortcut hint */}\n      <div className=\"px-3 pb-2 text-[9px] text-[#45475a] text-center\">\n        Enter Ù„Ù„Ø¥Ø±Ø³Ø§Ù„ â€¢ Shift+Enter Ù„Ø³Ø·Ø± Ø¬Ø¯ÙŠØ¯\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\chat-message.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\markdown-renderer.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'TextSegment' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 33,
        "column": 8,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 33,
        "endColumn": 19
      },
      {
        "ruleId": "@next/next/no-img-element",
        "severity": 1,
        "message": "Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element",
        "line": 284,
        "column": 11,
        "nodeType": "JSXOpeningElement",
        "endLine": 289,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\n/**\n * CodeForge IDE â€” Markdown Renderer v2.1\n * React component that renders parsed markdown tokens.\n * Catppuccin Mocha themed. Supports copy-to-clipboard for code blocks,\n * clickable file paths (open in editor), and clickable repo names\n * (load file tree in sidebar).\n *\n * v2.1 â€” Fixed RepoNameLink to use auth-store instead of deleted\n *         localStorage key. Owner is now resolved from useAuthStore\n *         user.login (already available after sign-in).\n */\n\nimport React, { useState, useCallback } from 'react';\nimport {\n  Copy,\n  Check,\n  FileCode2,\n  ExternalLink,\n  FolderGit2,\n  Loader2,\n} from 'lucide-react';\nimport {\n  parseMarkdown,\n  parseInline,\n  cleanAIContent,\n  type MarkdownToken,\n  type InlineSegment,\n} from '@/lib/utils/markdown-parser';\nimport {\n  parseFilePathsFromText,\n  type TextSegment,\n} from '@/lib/utils/file-path-detect';\nimport { useEditorStore } from '@/lib/stores/editor-store';\nimport { useAuthStore } from '@/lib/stores/auth-store';\n\n// â”€â”€â”€ Main Renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ninterface MarkdownRendererProps {\n  content: string;\n}\n\nexport function MarkdownRenderer({ content }: MarkdownRendererProps) {\n  const cleaned = cleanAIContent(content);\n  if (!cleaned) return null;\n\n  const tokens = parseMarkdown(cleaned);\n\n  return (\n    <div className=\"markdown-content space-y-2\">\n      {tokens.map((token, i) => (\n        <TokenRenderer key={i} token={token} />\n      ))}\n    </div>\n  );\n}\n\n// â”€â”€â”€ Token Renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction TokenRenderer({ token }: { token: MarkdownToken }) {\n  switch (token.type) {\n    case 'heading':\n      return <HeadingBlock level={token.level || 1} content={token.content} />;\n    case 'code_block':\n      return <CodeBlock code={token.content} language={token.language} />;\n    case 'blockquote':\n      return <BlockquoteBlock content={token.content} />;\n    case 'unordered_list':\n      return <UnorderedListBlock items={token.items || []} />;\n    case 'ordered_list':\n      return <OrderedListBlock items={token.items || []} />;\n    case 'task_list':\n      return <TaskListBlock items={token.items || []} />;\n    case 'hr':\n      return <hr className=\"border-[#313244] my-3\" />;\n    case 'paragraph':\n      return <ParagraphBlock content={token.content} />;\n    default:\n      return <ParagraphBlock content={token.content} />;\n  }\n}\n\n// â”€â”€â”€ Heading â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction HeadingBlock({ level, content }: { level: number; content: string }) {\n  const sizes: Record<number, string> = {\n    1: 'text-base font-bold text-[#cdd6f4] mt-3 mb-1',\n    2: 'text-sm font-bold text-[#cdd6f4] mt-2.5 mb-1',\n    3: 'text-sm font-semibold text-[#bac2de] mt-2 mb-0.5',\n    4: 'text-xs font-semibold text-[#bac2de] mt-1.5 mb-0.5',\n    5: 'text-xs font-medium text-[#a6adc8] mt-1',\n    6: 'text-xs font-medium text-[#a6adc8] mt-1',\n  };\n\n  return (\n    <div className={sizes[level] || sizes[3]}>\n      <InlineContent text={content} />\n    </div>\n  );\n}\n\n// â”€â”€â”€ Code Block â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction CodeBlock({ code, language }: { code: string; language?: string }) {\n  const [copied, setCopied] = useState(false);\n\n  const handleCopy = useCallback(() => {\n    navigator.clipboard.writeText(code).then(() => {\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2000);\n    });\n  }, [code]);\n\n  return (\n    <div className=\"rounded-lg border border-[#313244] bg-[#11111b] overflow-hidden my-2\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between px-3 py-1.5 bg-[#181825] border-b border-[#313244]\">\n        <span className=\"text-[10px] text-[#6c7086] font-mono\">\n          {language || 'code'}\n        </span>\n        <button\n          onClick={handleCopy}\n          className=\"flex items-center gap-1 text-[10px] text-[#6c7086] hover:text-[#cdd6f4] transition-colors\"\n          title=\"Ù†Ø³Ø®\"\n        >\n          {copied ? (\n            <>\n              <Check size={10} className=\"text-[#a6e3a1]\" />\n              <span className=\"text-[#a6e3a1]\">ØªÙ… Ø§Ù„Ù†Ø³Ø®</span>\n            </>\n          ) : (\n            <>\n              <Copy size={10} />\n              <span>Ù†Ø³Ø®</span>\n            </>\n          )}\n        </button>\n      </div>\n      {/* Code */}\n      <pre className=\"p-3 overflow-x-auto text-[11px] leading-relaxed font-mono text-[#cdd6f4]\">\n        <code>{code}</code>\n      </pre>\n    </div>\n  );\n}\n\n// â”€â”€â”€ Blockquote â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction BlockquoteBlock({ content }: { content: string }) {\n  return (\n    <div className=\"border-l-2 border-[#89b4fa]/50 pl-3 py-1 my-1.5 text-[#a6adc8]\">\n      <InlineContent text={content} />\n    </div>\n  );\n}\n\n// â”€â”€â”€ Lists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction UnorderedListBlock({ items }: { items: { content: string }[] }) {\n  return (\n    <ul className=\"space-y-0.5 my-1\">\n      {items.map((item, i) => (\n        <li key={i} className=\"flex items-start gap-1.5 text-sm\">\n          <span className=\"text-[#89b4fa] mt-1.5 text-[8px]\">â—</span>\n          <span className=\"flex-1\">\n            <InlineContent text={item.content} />\n          </span>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nfunction OrderedListBlock({ items }: { items: { content: string }[] }) {\n  return (\n    <ol className=\"space-y-0.5 my-1\">\n      {items.map((item, i) => (\n        <li key={i} className=\"flex items-start gap-1.5 text-sm\">\n          <span className=\"text-[#89b4fa] font-mono text-[11px] min-w-[1.2em] text-right mt-0.5\">\n            {i + 1}.\n          </span>\n          <span className=\"flex-1\">\n            <InlineContent text={item.content} />\n          </span>\n        </li>\n      ))}\n    </ol>\n  );\n}\n\nfunction TaskListBlock({\n  items,\n}: {\n  items: { content: string; checked?: boolean }[];\n}) {\n  return (\n    <ul className=\"space-y-0.5 my-1\">\n      {items.map((item, i) => (\n        <li key={i} className=\"flex items-start gap-1.5 text-sm\">\n          <span className=\"mt-0.5\">\n            {item.checked ? (\n              <span className=\"text-[#a6e3a1]\">â˜‘</span>\n            ) : (\n              <span className=\"text-[#6c7086]\">â˜</span>\n            )}\n          </span>\n          <span\n            className={`flex-1 ${item.checked ? 'line-through text-[#6c7086]' : ''}`}\n          >\n            <InlineContent text={item.content} />\n          </span>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// â”€â”€â”€ Paragraph â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction ParagraphBlock({ content }: { content: string }) {\n  return (\n    <p className=\"text-sm leading-relaxed\">\n      <InlineContent text={content} />\n    </p>\n  );\n}\n\n// â”€â”€â”€ Inline Content Renderer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction InlineContent({ text }: { text: string }) {\n  const segments = parseInline(text);\n\n  return (\n    <>\n      {segments.map((seg, i) => (\n        <InlineSegmentRenderer key={i} segment={seg} />\n      ))}\n    </>\n  );\n}\n\nfunction InlineSegmentRenderer({ segment }: { segment: InlineSegment }) {\n  switch (segment.type) {\n    case 'bold':\n      return (\n        <strong className=\"font-semibold text-[#cdd6f4]\">\n          {segment.content}\n        </strong>\n      );\n\n    case 'italic':\n      return <em className=\"italic text-[#bac2de]\">{segment.content}</em>;\n\n    case 'bold_italic':\n      return (\n        <strong className=\"font-semibold italic text-[#cdd6f4]\">\n          {segment.content}\n        </strong>\n      );\n\n    case 'strikethrough':\n      return <del className=\"text-[#6c7086]\">{segment.content}</del>;\n\n    case 'code':\n      return <SmartInlineCode code={segment.content} />;\n\n    case 'link':\n      return (\n        <a\n          href={segment.href}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          className=\"inline-flex items-center gap-0.5 text-[#89b4fa] hover:underline\"\n        >\n          {segment.content}\n          <ExternalLink size={10} className=\"opacity-50\" />\n        </a>\n      );\n\n    case 'image':\n      return (\n        <span className=\"block my-2\">\n          <img\n            src={segment.content}\n            alt={segment.alt || ''}\n            className=\"max-w-full rounded-md border border-[#313244]\"\n            loading=\"lazy\"\n          />\n        </span>\n      );\n\n    case 'text':\n    default:\n      return <TextWithFilePaths text={segment.content} />;\n  }\n}\n\n// â”€â”€â”€ Smart Inline Code (detects repos + file paths) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/**\n * Detects if inline code is:\n * 1. A GitHub repo (owner/repo pattern) â†’ clickable repo button\n * 2. A file path (src/index.ts pattern) â†’ clickable file button\n * 3. Plain code â†’ renders as styled <code>\n */\nfunction SmartInlineCode({ code }: { code: string }) {\n  // Pattern 1: owner/repo (e.g., bahoma31-jpg/secoderepo)\n  const ownerRepoMatch = code.match(/^([a-zA-Z0-9_.-]+)\\/([a-zA-Z0-9_.-]+)$/);\n  if (ownerRepoMatch && !code.includes('/') === false) {\n    const owner = ownerRepoMatch[1];\n    const repo = ownerRepoMatch[2];\n    // Distinguish from file paths: repos don't have file extensions typically\n    const hasExtension = /\\.[a-zA-Z0-9]{1,10}$/.test(repo);\n    if (!hasExtension && !code.startsWith('./') && !code.startsWith('../')) {\n      return (\n        <RepoNameLink\n          owner={owner}\n          repo={repo}\n          displayText={code}\n          isInlineCode\n        />\n      );\n    }\n  }\n\n  // Pattern 2: file path detection\n  const segments = parseFilePathsFromText(code);\n  const isFilePath =\n    segments.length === 1 &&\n    segments[0].type === 'filepath' &&\n    segments[0].filePath;\n\n  if (isFilePath && segments[0].filePath) {\n    return (\n      <FilePathLink\n        filePath={segments[0].filePath}\n        language={segments[0].language || 'plaintext'}\n        displayText={code}\n        isInlineCode\n      />\n    );\n  }\n\n  // Pattern 3: standalone repo name (no slash, no extension, no spaces)\n  // Only if it looks like a simple identifier that could be a repo name\n  // We check context from the store to see if this matches a known repo\n  if (\n    /^[a-zA-Z0-9][a-zA-Z0-9_.-]*$/.test(code) &&\n    !code.includes(' ') &&\n    code.length > 1 &&\n    code.length < 100\n  ) {\n    const hasExtension = /\\.[a-zA-Z0-9]{1,10}$/.test(code);\n    // Exclude common code tokens like 'true', 'false', 'null', 'undefined', etc.\n    const codeKeywords = [\n      'true',\n      'false',\n      'null',\n      'undefined',\n      'none',\n      'nil',\n      'void',\n      'return',\n      'const',\n      'let',\n      'var',\n      'function',\n      'class',\n      'import',\n      'export',\n      'async',\n      'await',\n      'if',\n      'else',\n      'for',\n      'while',\n      'break',\n      'continue',\n      'switch',\n      'case',\n      'default',\n      'try',\n      'catch',\n      'finally',\n      'throw',\n      'new',\n      'this',\n      'self',\n      'super',\n      'main',\n      'string',\n      'number',\n      'boolean',\n      'object',\n      'array',\n      'int',\n      'float',\n      'double',\n      'char',\n      'auto',\n      'notify',\n      'confirm',\n    ];\n    if (!hasExtension && !codeKeywords.includes(code.toLowerCase())) {\n      return <MaybeRepoLink name={code} />;\n    }\n  }\n\n  return (\n    <code className=\"px-1.5 py-0.5 rounded bg-[#181825] text-[#f9e2af] text-[11px] font-mono border border-[#313244]/50\">\n      {code}\n    </code>\n  );\n}\n\n// â”€â”€â”€ Maybe Repo Link (checks context to decide) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/**\n * Renders a potential repo name. Checks if the surrounding chat context\n * mentions GitHub/repos. If so, renders as a clickable repo button.\n * Otherwise renders as plain inline code.\n */\nfunction MaybeRepoLink({ name }: { name: string }) {\n  // We render as a repo-styled button that attempts to load the repo on click.\n  // If it fails (404), it just shows as plain text. This is a progressive approach.\n  return <RepoNameLink owner=\"\" repo={name} displayText={name} isInlineCode />;\n}\n\n// â”€â”€â”€ Clickable Repo Name â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/**\n * Clickable repository name button.\n * When clicked, loads the repo's file tree into the sidebar.\n * If owner is empty, resolves from auth-store (user.login).\n */\nfunction RepoNameLink({\n  owner,\n  repo,\n  displayText,\n  isInlineCode,\n}: {\n  owner: string;\n  repo: string;\n  displayText: string;\n  isInlineCode: boolean;\n}) {\n  const loadRepoTree = useEditorStore((s) => s.loadRepoTree);\n  const authUser = useAuthStore((s) => s.user);\n  const [loading, setLoading] = useState(false);\n  const [failed, setFailed] = useState(false);\n\n  const handleClick = async () => {\n    if (failed) return; // Don't retry if already failed\n    setLoading(true);\n    try {\n      // Resolve owner: use provided owner, or fall back to auth-store user.login\n      const resolvedOwner = owner || authUser?.login || null;\n\n      if (!resolvedOwner) {\n        console.warn('[RepoNameLink] No owner: user not signed in');\n        setFailed(true);\n        return;\n      }\n\n      await loadRepoTree(resolvedOwner, repo);\n    } catch (error) {\n      console.error('[MarkdownRenderer] Failed to load repo:', repo, error);\n      setFailed(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // If it failed, render as plain code (not a repo after all)\n  if (failed) {\n    return (\n      <code className=\"px-1.5 py-0.5 rounded bg-[#181825] text-[#f9e2af] text-[11px] font-mono border border-[#313244]/50\">\n        {displayText}\n      </code>\n    );\n  }\n\n  return (\n    <button\n      onClick={handleClick}\n      disabled={loading}\n      title={`ÙØªØ­ Ù…Ø³ØªÙˆØ¯Ø¹ ${owner ? owner + '/' : ''}${repo} ÙÙŠ Ø´Ø¬Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª`}\n      className={`inline-flex items-center gap-1 rounded transition-all cursor-pointer\n        ${\n          isInlineCode\n            ? 'px-1.5 py-0.5 bg-[#181825] text-[11px] font-mono border border-[#313244]/50 hover:border-[#cba6f7]/40 hover:bg-[#cba6f7]/10 hover:text-[#cba6f7]'\n            : 'text-[#cba6f7] hover:underline text-sm'\n        }\n        ${loading ? 'opacity-50' : ''}\n      `}\n    >\n      {loading ? (\n        <Loader2 size={10} className=\"shrink-0 animate-spin\" />\n      ) : (\n        <FolderGit2 size={10} className=\"shrink-0\" />\n      )}\n      <span>{displayText}</span>\n    </button>\n  );\n}\n\n// â”€â”€â”€ File Path Detection in Plain Text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction TextWithFilePaths({ text }: { text: string }) {\n  if (!text) return null;\n\n  const segments = parseFilePathsFromText(text);\n  if (segments.every((s) => s.type === 'text')) {\n    return <span>{text}</span>;\n  }\n\n  return (\n    <>\n      {segments.map((segment, i) => {\n        if (segment.type === 'filepath' && segment.filePath) {\n          return (\n            <FilePathLink\n              key={i}\n              filePath={segment.filePath}\n              language={segment.language || 'plaintext'}\n              displayText={segment.value}\n              isInlineCode={false}\n            />\n          );\n        }\n        return <span key={i}>{segment.value}</span>;\n      })}\n    </>\n  );\n}\n\n// â”€â”€â”€ Clickable File Path â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction FilePathLink({\n  filePath,\n  language,\n  displayText,\n  isInlineCode,\n}: {\n  filePath: string;\n  language: string;\n  displayText: string;\n  isInlineCode: boolean;\n}) {\n  const openFileFromPath = useEditorStore((s) => s.openFileFromPath);\n  const [loading, setLoading] = useState(false);\n\n  const handleClick = async () => {\n    setLoading(true);\n    try {\n      await openFileFromPath(filePath, language);\n    } catch (error) {\n      console.error('[MarkdownRenderer] Failed to open:', filePath, error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <button\n      onClick={handleClick}\n      disabled={loading}\n      title={`ÙØªØ­ ${filePath}`}\n      className={`inline-flex items-center gap-0.5 rounded transition-all cursor-pointer\n        ${\n          isInlineCode\n            ? 'px-1.5 py-0.5 bg-[#181825] text-[11px] font-mono border border-[#313244]/50 hover:border-[#89b4fa]/40 hover:bg-[#89b4fa]/10 hover:text-[#89b4fa]'\n            : 'text-[#89b4fa] hover:underline text-sm'\n        }\n        ${loading ? 'opacity-50' : ''}\n      `}\n    >\n      <FileCode2 size={10} className=\"shrink-0\" />\n      <span>{displayText}</span>\n    </button>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\model-selector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\notify-toast.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\agent\\tool-call-status.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'Github' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 28,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 28,
        "endColumn": 9
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\n/**\n * CodeForge IDE â€” Tool Call Status v2.0\n * Live indicator showing the current tool being executed.\n * Now covers ALL 45 tools (fs_*, git_*, github_*, utility).\n * Shows risk level badge during execution.\n */\n\nimport React from 'react';\nimport type { ToolCall } from '@/lib/agent/types';\nimport {\n  Loader2,\n  FileCode,\n  FolderOpen,\n  Search,\n  FilePlus,\n  FileEdit,\n  FolderPlus,\n  FileX,\n  ArrowRightLeft,\n  Move,\n  GitBranch,\n  GitCommit,\n  GitPullRequest,\n  GitMerge,\n  Upload,\n  Github,\n  Eye,\n  ListTree,\n  Code,\n  MessageSquare,\n  Tag,\n  Trash2,\n  PlusCircle,\n  Database,\n  User,\n  Lightbulb,\n  Wrench,\n  BookOpen,\n  Bug,\n} from 'lucide-react';\n\ninterface ToolCallStatusProps {\n  toolCall: ToolCall;\n}\n\n// â”€â”€â”€ Icon Map (by tool name) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst TOOL_ICONS: Record<string, React.ReactNode> = {\n  // FS Tools\n  fs_list_files: <FolderOpen size={12} />,\n  fs_read_file: <FileCode size={12} />,\n  fs_search_files: <Search size={12} />,\n  fs_create_file: <FilePlus size={12} />,\n  fs_update_file: <FileEdit size={12} />,\n  fs_create_folder: <FolderPlus size={12} />,\n  fs_delete_file: <FileX size={12} />,\n  fs_rename_file: <ArrowRightLeft size={12} />,\n  fs_move_file: <Move size={12} />,\n\n  // Git Tools\n  git_status: <GitBranch size={12} />,\n  git_diff: <Code size={12} />,\n  git_log: <ListTree size={12} />,\n  git_stage: <Upload size={12} />,\n  git_commit: <GitCommit size={12} />,\n  git_push: <Upload size={12} />,\n  git_create_branch: <GitBranch size={12} />,\n  git_create_pr: <GitPullRequest size={12} />,\n\n  // GitHub: Repo\n  github_create_repo: <PlusCircle size={12} />,\n  github_delete_repo: <Trash2 size={12} />,\n  github_list_repos: <Database size={12} />,\n  github_get_repo_info: <Eye size={12} />,\n  github_search_repos: <Search size={12} />,\n  github_get_user_info: <User size={12} />,\n\n  // GitHub: Files\n  github_push_file: <Upload size={12} />,\n  github_push_files: <Upload size={12} />,\n  github_read_file: <FileCode size={12} />,\n  github_edit_file: <FileEdit size={12} />,\n  github_delete_file: <FileX size={12} />,\n  github_list_files: <FolderOpen size={12} />,\n\n  // GitHub: Branches\n  github_create_branch: <GitBranch size={12} />,\n  github_list_branches: <ListTree size={12} />,\n  github_delete_branch: <Trash2 size={12} />,\n\n  // GitHub: PRs\n  github_create_pull_request: <GitPullRequest size={12} />,\n  github_list_pull_requests: <ListTree size={12} />,\n  github_get_pull_request: <Eye size={12} />,\n  github_merge_pull_request: <GitMerge size={12} />,\n\n  // GitHub: Issues\n  github_create_issue: <Tag size={12} />,\n  github_list_issues: <ListTree size={12} />,\n  github_update_issue: <FileEdit size={12} />,\n  github_add_comment: <MessageSquare size={12} />,\n\n  // GitHub: Search & History\n  github_search_code: <Search size={12} />,\n  github_get_commit_history: <GitCommit size={12} />,\n\n  // Utility\n  get_project_context: <Lightbulb size={12} />,\n  explain_code: <BookOpen size={12} />,\n  suggest_fix: <Bug size={12} />,\n};\n\n// â”€â”€â”€ Label Map (Arabic) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst TOOL_LABELS: Record<string, string> = {\n  // FS\n  fs_list_files: 'Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„ÙØ§Øª...',\n  fs_read_file: 'Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù...',\n  fs_search_files: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«...',\n  fs_create_file: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù...',\n  fs_update_file: 'Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù...',\n  fs_create_folder: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯...',\n  fs_delete_file: 'Ø¬Ø§Ø±ÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù...',\n  fs_rename_file: 'Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ³Ù…ÙŠØ©...',\n  fs_move_file: 'Ø¬Ø§Ø±ÙŠ Ù†Ù‚Ù„ Ø§Ù„Ù…Ù„Ù...',\n\n  // Git\n  git_status: 'Ø¬Ø§Ø±ÙŠ ÙØ­Øµ Ø­Ø§Ù„Ø© Git...',\n  git_diff: 'Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª...',\n  git_log: 'Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ø³Ø¬Ù„...',\n  git_stage: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ¬Ù‡ÙŠØ² Ù„Ù„Ø­ÙØ¸...',\n  git_commit: 'Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª...',\n  git_push: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¯ÙØ¹ Ù„Ù€ GitHub...',\n  git_create_branch: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ ÙØ±Ø¹...',\n  git_create_pr: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ PR...',\n\n  // GitHub: Repo\n  github_create_repo: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªÙˆØ¯Ø¹...',\n  github_delete_repo: 'Ø¬Ø§Ø±ÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹...',\n  github_list_repos: 'Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹Ø§Øª...',\n  github_get_repo_info: 'Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹...',\n  github_search_repos: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªÙˆØ¯Ø¹Ø§Øª...',\n  github_get_user_info: 'Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…...',\n\n  // GitHub: Files\n  github_push_file: 'Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ù…Ù„Ù...',\n  github_push_files: 'Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ù…Ù„ÙØ§Øª...',\n  github_read_file: 'Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù Ù…Ù† GitHub...',\n  github_edit_file: 'Ø¬Ø§Ø±ÙŠ ØªØ¹Ø¯ÙŠÙ„ Ù…Ù„Ù...',\n  github_delete_file: 'Ø¬Ø§Ø±ÙŠ Ø­Ø°Ù Ù…Ù„Ù Ù…Ù† GitHub...',\n  github_list_files: 'Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ Ù…Ù„ÙØ§Øª GitHub...',\n\n  // GitHub: Branches\n  github_create_branch: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ ÙØ±Ø¹...',\n  github_list_branches: 'Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ Ø§Ù„ÙØ±ÙˆØ¹...',\n  github_delete_branch: 'Ø¬Ø§Ø±ÙŠ Ø­Ø°Ù ÙØ±Ø¹...',\n\n  // GitHub: PRs\n  github_create_pull_request: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ PR...',\n  github_list_pull_requests: 'Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ PRs...',\n  github_get_pull_request: 'Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ ØªÙØ§ØµÙŠÙ„ PR...',\n  github_merge_pull_request: 'Ø¬Ø§Ø±ÙŠ Ø¯Ù…Ø¬ PR...',\n\n  // GitHub: Issues\n  github_create_issue: 'Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Issue...',\n  github_list_issues: 'Ø¬Ø§Ø±ÙŠ Ø¹Ø±Ø¶ Issues...',\n  github_update_issue: 'Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Issue...',\n  github_add_comment: 'Ø¬Ø§Ø±ÙŠ Ø¥Ø¶Ø§ÙØ© ØªØ¹Ù„ÙŠÙ‚...',\n\n  // GitHub: Search & History\n  github_search_code: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„ÙƒÙˆØ¯...',\n  github_get_commit_history: 'Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø³Ø¬Ù„ Ø§Ù„Ø­ÙØ¸...',\n\n  // Utility\n  get_project_context: 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹...',\n  explain_code: 'Ø¬Ø§Ø±ÙŠ Ø´Ø±Ø­ Ø§Ù„ÙƒÙˆØ¯...',\n  suggest_fix: 'Ø¬Ø§Ø±ÙŠ Ø§Ù‚ØªØ±Ø§Ø­ Ø¥ØµÙ„Ø§Ø­...',\n};\n\n// â”€â”€â”€ Risk Level Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction getRiskBadge(\n  toolName: string\n): { emoji: string; color: string } | null {\n  // CONFIRM (red)\n  const confirmTools = [\n    'fs_delete_file',\n    'git_push',\n    'git_create_pr',\n    'github_delete_file',\n    'github_push_files',\n    'github_merge_pull_request',\n    'github_delete_branch',\n    'github_create_repo',\n    'github_delete_repo',\n  ];\n  if (confirmTools.includes(toolName)) {\n    return {\n      emoji: 'ğŸ”´',\n      color: 'text-[#f38ba8] bg-[#f38ba8]/10 border-[#f38ba8]/30',\n    };\n  }\n\n  // NOTIFY (yellow)\n  const notifyTools = [\n    'fs_create_file',\n    'fs_update_file',\n    'fs_create_folder',\n    'fs_rename_file',\n    'fs_move_file',\n    'git_stage',\n    'git_commit',\n    'git_create_branch',\n    'github_push_file',\n    'github_edit_file',\n    'github_create_branch',\n    'github_create_pull_request',\n    'github_create_issue',\n    'github_update_issue',\n    'github_add_comment',\n  ];\n  if (notifyTools.includes(toolName)) {\n    return {\n      emoji: 'ğŸŸ¡',\n      color: 'text-[#f9e2af] bg-[#f9e2af]/10 border-[#f9e2af]/30',\n    };\n  }\n\n  // AUTO (green) â€” read-only, no badge needed in most cases\n  return null;\n}\n\n// â”€â”€â”€ Component â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport function ToolCallStatus({ toolCall }: ToolCallStatusProps) {\n  const toolName = toolCall.name || toolCall.toolName || 'unknown';\n  const icon = TOOL_ICONS[toolName] || <Wrench size={12} />;\n  const label = TOOL_LABELS[toolName] || `Ø¬Ø§Ø±ÙŠ ØªÙ†ÙÙŠØ° ${toolName}...`;\n  const riskBadge = getRiskBadge(toolName);\n\n  // Determine category color\n  let categoryColor = 'text-[#89b4fa] border-[#89b4fa]/20 bg-[#89b4fa]/5';\n  if (toolName.startsWith('github_'))\n    categoryColor = 'text-[#cba6f7] border-[#cba6f7]/20 bg-[#cba6f7]/5';\n  else if (toolName.startsWith('git_'))\n    categoryColor = 'text-[#fab387] border-[#fab387]/20 bg-[#fab387]/5';\n  else if (toolName.startsWith('fs_'))\n    categoryColor = 'text-[#89b4fa] border-[#89b4fa]/20 bg-[#89b4fa]/5';\n  else categoryColor = 'text-[#a6e3a1] border-[#a6e3a1]/20 bg-[#a6e3a1]/5';\n\n  return (\n    <div\n      className={`flex items-center gap-2 px-3 py-2 mx-2 rounded-lg border animate-pulse ${categoryColor}`}\n    >\n      <Loader2 size={14} className=\"animate-spin\" />\n      <span>{icon}</span>\n      <span className=\"text-xs flex-1\">{label}</span>\n      {riskBadge && (\n        <span\n          className={`text-[9px] px-1.5 py-0.5 rounded-full border font-medium ${riskBadge.color}`}\n        >\n          {riskBadge.emoji}\n        </span>\n      )}\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\a11y\\live-region.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\a11y\\skip-to-main.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\dialogs\\auth-dialog.tsx",
    "messages": [
      {
        "ruleId": "@next/next/no-img-element",
        "severity": 1,
        "message": "Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element",
        "line": 94,
        "column": 15,
        "nodeType": "JSXOpeningElement",
        "endLine": 98,
        "endColumn": 17
      },
      {
        "ruleId": "react/no-unescaped-entities",
        "severity": 2,
        "message": "`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.",
        "line": 190,
        "column": 26,
        "nodeType": "JSXText",
        "messageId": "unescapedEntityAlts",
        "suggestions": [
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&quot;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± &quot;Fine-grained\" Ø£Ùˆ \"Classic\""
            },
            "desc": "Replace with `&quot;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&ldquo;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± &ldquo;Fine-grained\" Ø£Ùˆ \"Classic\""
            },
            "desc": "Replace with `&ldquo;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&#34;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± &#34;Fine-grained\" Ø£Ùˆ \"Classic\""
            },
            "desc": "Replace with `&#34;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&rdquo;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± &rdquo;Fine-grained\" Ø£Ùˆ \"Classic\""
            },
            "desc": "Replace with `&rdquo;`."
          }
        ]
      },
      {
        "ruleId": "react/no-unescaped-entities",
        "severity": 2,
        "message": "`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.",
        "line": 190,
        "column": 39,
        "nodeType": "JSXText",
        "messageId": "unescapedEntityAlts",
        "suggestions": [
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&quot;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained&quot; Ø£Ùˆ \"Classic\""
            },
            "desc": "Replace with `&quot;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&ldquo;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained&ldquo; Ø£Ùˆ \"Classic\""
            },
            "desc": "Replace with `&ldquo;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&#34;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained&#34; Ø£Ùˆ \"Classic\""
            },
            "desc": "Replace with `&#34;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&rdquo;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained&rdquo; Ø£Ùˆ \"Classic\""
            },
            "desc": "Replace with `&rdquo;`."
          }
        ]
      },
      {
        "ruleId": "react/no-unescaped-entities",
        "severity": 2,
        "message": "`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.",
        "line": 190,
        "column": 44,
        "nodeType": "JSXText",
        "messageId": "unescapedEntityAlts",
        "suggestions": [
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&quot;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ &quot;Classic\""
            },
            "desc": "Replace with `&quot;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&ldquo;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ &ldquo;Classic\""
            },
            "desc": "Replace with `&ldquo;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&#34;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ &#34;Classic\""
            },
            "desc": "Replace with `&#34;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&rdquo;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ &rdquo;Classic\""
            },
            "desc": "Replace with `&rdquo;`."
          }
        ]
      },
      {
        "ruleId": "react/no-unescaped-entities",
        "severity": 2,
        "message": "`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.",
        "line": 190,
        "column": 52,
        "nodeType": "JSXText",
        "messageId": "unescapedEntityAlts",
        "suggestions": [
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&quot;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ \"Classic&quot;"
            },
            "desc": "Replace with `&quot;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&ldquo;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ \"Classic&ldquo;"
            },
            "desc": "Replace with `&ldquo;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&#34;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ \"Classic&#34;"
            },
            "desc": "Replace with `&#34;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&rdquo;" },
            "fix": {
              "range": [6023, 6055],
              "text": "Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ \"Classic&rdquo;"
            },
            "desc": "Replace with `&rdquo;`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” GitHub Auth Dialog\n * Professional sign-in modal using Personal Access Token.\n */\n\n'use client';\n\nimport { useState } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogDescription,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { useAuthStore } from '@/lib/stores/auth-store';\nimport { useNotificationStore } from '@/lib/stores/notification-store';\nimport {\n  Github,\n  Loader2,\n  Eye,\n  EyeOff,\n  ExternalLink,\n  LogOut,\n} from 'lucide-react';\n\ninterface AuthDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n}\n\nexport function AuthDialog({ open, onOpenChange }: AuthDialogProps) {\n  const [token, setToken] = useState('');\n  const [showToken, setShowToken] = useState(false);\n  const {\n    signIn,\n    signOut,\n    isLoading,\n    isAuthenticated,\n    user,\n    error,\n    clearError,\n  } = useAuthStore();\n  const { addNotification } = useNotificationStore();\n\n  const handleSignIn = async () => {\n    if (!token.trim()) return;\n    clearError();\n\n    try {\n      await signIn(token.trim());\n      addNotification({\n        type: 'success',\n        title: 'ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',\n        message: `Ù…Ø±Ø­Ø¨Ø§Ù‹ ${useAuthStore.getState().user?.name || useAuthStore.getState().user?.login}!`,\n        autoDismiss: true,\n      });\n      setToken('');\n      onOpenChange(false);\n    } catch {\n      // Error is handled by auth store\n    }\n  };\n\n  const handleSignOut = () => {\n    signOut();\n    addNotification({\n      type: 'info',\n      title: 'ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬',\n      message: 'ØªÙ… Ø­Ø°Ù Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù† Ø§Ù„Ù…ØªØµÙØ­.',\n      autoDismiss: true,\n    });\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-md\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            <Github className=\"h-5 w-5\" />\n            {isAuthenticated ? 'GitHub Account' : 'Sign in to GitHub'}\n          </DialogTitle>\n          <DialogDescription>\n            {isAuthenticated\n              ? 'Ø­Ø³Ø§Ø¨Ùƒ Ù…ØªØµÙ„ Ø¨Ù†Ø¬Ø§Ø­.'\n              : 'Ø£Ø¯Ø®Ù„ Personal Access Token Ù…Ù† GitHub Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹Ø§Øª.'}\n          </DialogDescription>\n        </DialogHeader>\n\n        {isAuthenticated && user ? (\n          <div className=\"space-y-4\">\n            <div className=\"flex items-center gap-3 rounded-lg border p-3\">\n              <img\n                src={user.avatar_url}\n                alt={user.login}\n                className=\"h-10 w-10 rounded-full\"\n              />\n              <div className=\"flex-1 min-w-0\">\n                <p className=\"font-medium truncate\">\n                  {user.name || user.login}\n                </p>\n                <p className=\"text-sm text-muted-foreground truncate\">\n                  @{user.login}\n                </p>\n              </div>\n            </div>\n            {user.bio && (\n              <p className=\"text-sm text-muted-foreground\">{user.bio}</p>\n            )}\n            <p className=\"text-xs text-muted-foreground\">\n              {user.public_repos} public repos\n            </p>\n            <div className=\"flex gap-2\">\n              <Button\n                variant=\"outline\"\n                className=\"flex-1\"\n                onClick={() => window.open(user.html_url, '_blank')}\n              >\n                <ExternalLink className=\"mr-2 h-4 w-4\" />\n                View Profile\n              </Button>\n              <Button\n                variant=\"destructive\"\n                className=\"flex-1\"\n                onClick={handleSignOut}\n              >\n                <LogOut className=\"mr-2 h-4 w-4\" />\n                Sign Out\n              </Button>\n            </div>\n          </div>\n        ) : (\n          <div className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <label htmlFor=\"gh-token\" className=\"text-sm font-medium\">\n                Personal Access Token\n              </label>\n              <div className=\"relative\">\n                <input\n                  id=\"gh-token\"\n                  type={showToken ? 'text' : 'password'}\n                  value={token}\n                  onChange={(e) => setToken(e.target.value)}\n                  onKeyDown={(e) => e.key === 'Enter' && handleSignIn()}\n                  placeholder=\"ghp_xxxxxxxxxxxx\"\n                  className=\"w-full rounded-md border bg-background px-3 py-2 pr-10 text-sm focus:outline-none focus:ring-2 focus:ring-ring\"\n                  autoComplete=\"off\"\n                  spellCheck={false}\n                />\n                <button\n                  type=\"button\"\n                  onClick={() => setShowToken(!showToken)}\n                  className=\"absolute right-2 top-1/2 -translate-y-1/2 p-1 text-muted-foreground hover:text-foreground\"\n                  aria-label={showToken ? 'Hide token' : 'Show token'}\n                >\n                  {showToken ? (\n                    <EyeOff className=\"h-4 w-4\" />\n                  ) : (\n                    <Eye className=\"h-4 w-4\" />\n                  )}\n                </button>\n              </div>\n            </div>\n\n            {error && <p className=\"text-sm text-destructive\">{error}</p>}\n\n            <Button\n              onClick={handleSignIn}\n              disabled={!token.trim() || isLoading}\n              className=\"w-full\"\n            >\n              {isLoading ? (\n                <>\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚â€¦\n                </>\n              ) : (\n                <>\n                  <Github className=\"mr-2 h-4 w-4\" />\n                  Sign In\n                </>\n              )}\n            </Button>\n\n            <div className=\"rounded-lg bg-muted p-3 space-y-1\">\n              <p className=\"text-xs font-medium\">ÙƒÙŠÙ ØªØ­ØµÙ„ Ø¹Ù„Ù‰ TokenØŸ</p>\n              <ol className=\"text-xs text-muted-foreground space-y-1 list-decimal list-inside\">\n                <li>Settings â†’ Developer settings â†’ Personal access tokens</li>\n                <li>Ø§Ø®ØªØ± \"Fine-grained\" Ø£Ùˆ \"Classic\"</li>\n                <li>\n                  ÙØ¹Ù‘Ù„ ØµÙ„Ø§Ø­ÙŠØ§Øª:{' '}\n                  <code className=\"bg-background px-1 rounded\">repo</code>\n                </li>\n              </ol>\n              <a\n                href=\"https://github.com/settings/tokens/new\"\n                target=\"_blank\"\n                rel=\"noopener noreferrer\"\n                className=\"inline-flex items-center gap-1 text-xs text-primary hover:underline mt-1\"\n              >\n                Ø¥Ù†Ø´Ø§Ø¡ Token Ø¬Ø¯ÙŠØ¯\n                <ExternalLink className=\"h-3 w-3\" />\n              </a>\n            </div>\n          </div>\n        )}\n      </DialogContent>\n    </Dialog>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\dialogs\\clone-dialog.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'CheckCircle' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 24,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 24,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Clone Repository Dialog\n * Professional clone modal with progress tracking.\n */\n\n'use client';\n\nimport { useState } from 'react';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogDescription,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { useAuthStore } from '@/lib/stores/auth-store';\nimport { useNotificationStore } from '@/lib/stores/notification-store';\nimport { cloneRepository } from '@/lib/services/github.service';\nimport {\n  GitBranch,\n  Loader2,\n  AlertCircle,\n  CheckCircle,\n  Github,\n} from 'lucide-react';\n\ninterface CloneDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n}\n\nexport function CloneDialog({ open, onOpenChange }: CloneDialogProps) {\n  const [repoUrl, setRepoUrl] = useState('');\n  const [branch, setBranch] = useState('');\n  const [isCloning, setIsCloning] = useState(false);\n  const [progress, setProgress] = useState({ msg: '', pct: 0 });\n  const [cloneError, setCloneError] = useState<string | null>(null);\n\n  const { token, isAuthenticated } = useAuthStore();\n  const { addNotification } = useNotificationStore();\n\n  /** Parse owner/repo from various URL formats */\n  const parseRepo = (input: string): { owner: string; repo: string } | null => {\n    // Handle: https://github.com/owner/repo(.git)\n    const urlMatch = input.match(\n      /github\\.com\\/([\\w.-]+)\\/([\\.\\w-]+?)(?:\\.git)?\\/?$/\n    );\n    if (urlMatch) return { owner: urlMatch[1], repo: urlMatch[2] };\n\n    // Handle: owner/repo\n    const shortMatch = input.match(/^([\\w.-]+)\\/([\\.\\w-]+)$/);\n    if (shortMatch) return { owner: shortMatch[1], repo: shortMatch[2] };\n\n    return null;\n  };\n\n  const handleClone = async () => {\n    if (!token) return;\n\n    const parsed = parseRepo(repoUrl.trim());\n    if (!parsed) {\n      setCloneError('Ø§Ù„ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©. Ø§Ø³ØªØ®Ø¯Ù…: owner/repo Ø£Ùˆ Ø±Ø§Ø¨Ø· GitHub ÙƒØ§Ù…Ù„');\n      return;\n    }\n\n    setIsCloning(true);\n    setCloneError(null);\n    setProgress({ msg: 'Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø®â€¦', pct: 0 });\n\n    try {\n      const result = await cloneRepository(\n        parsed.owner,\n        parsed.repo,\n        token,\n        branch || undefined,\n        (msg, pct) => setProgress({ msg, pct })\n      );\n\n      addNotification({\n        type: 'success',\n        title: 'ØªÙ… Ø§Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø® Ø¨Ù†Ø¬Ø§Ø­!',\n        message: `ØªÙ… Ø¬Ù„Ø¨ ${result.imported} Ù…Ù„Ù Ù…Ù† ${result.repoName}`,\n        autoDismiss: true,\n        dismissAfterMs: 6000,\n      });\n\n      setRepoUrl('');\n      setBranch('');\n      onOpenChange(false);\n    } catch (err) {\n      const msg = err instanceof Error ? err.message : 'ÙØ´Ù„ Ø§Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø®';\n      setCloneError(msg);\n    } finally {\n      setIsCloning(false);\n    }\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-lg\">\n        <DialogHeader>\n          <DialogTitle className=\"flex items-center gap-2\">\n            <GitBranch className=\"h-5 w-5\" />\n            Clone Repository\n          </DialogTitle>\n          <DialogDescription>\n            Ø§Ø³ØªÙ†Ø³Ø® Ù…Ø³ØªÙˆØ¯Ø¹ Ù…Ù† GitHub Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø­Ø±Ø±.\n          </DialogDescription>\n        </DialogHeader>\n\n        {!isAuthenticated ? (\n          <div className=\"rounded-lg border border-yellow-500/30 bg-yellow-500/5 p-4 space-y-2\">\n            <div className=\"flex items-center gap-2 text-yellow-500\">\n              <AlertCircle className=\"h-4 w-4\" />\n              <span className=\"font-medium text-sm\">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨</span>\n            </div>\n            <p className=\"text-xs text-muted-foreground\">\n              ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù€ GitHub Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø® Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹Ø§Øª.\n            </p>\n          </div>\n        ) : (\n          <div className=\"space-y-4\">\n            <div className=\"space-y-2\">\n              <label htmlFor=\"clone-url\" className=\"text-sm font-medium\">\n                Repository URL or owner/repo\n              </label>\n              <input\n                id=\"clone-url\"\n                value={repoUrl}\n                onChange={(e) => setRepoUrl(e.target.value)}\n                onKeyDown={(e) => e.key === 'Enter' && handleClone()}\n                placeholder=\"e.g. facebook/react or https://github.com/facebook/react\"\n                className=\"w-full rounded-md border bg-background px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-ring\"\n                disabled={isCloning}\n                autoFocus\n              />\n            </div>\n\n            <div className=\"space-y-2\">\n              <label htmlFor=\"clone-branch\" className=\"text-sm font-medium\">\n                Branch <span className=\"text-muted-foreground\">(optional)</span>\n              </label>\n              <input\n                id=\"clone-branch\"\n                value={branch}\n                onChange={(e) => setBranch(e.target.value)}\n                placeholder=\"default branch\"\n                className=\"w-full rounded-md border bg-background px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-ring\"\n                disabled={isCloning}\n              />\n            </div>\n\n            {cloneError && (\n              <div className=\"flex items-start gap-2 rounded-md bg-destructive/10 p-3 text-sm text-destructive\">\n                <AlertCircle className=\"mt-0.5 h-4 w-4 shrink-0\" />\n                <span>{cloneError}</span>\n              </div>\n            )}\n\n            {isCloning && (\n              <div className=\"space-y-2\">\n                <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n                  <Loader2 className=\"h-4 w-4 animate-spin\" />\n                  <span>{progress.msg}</span>\n                </div>\n                <div className=\"h-2 w-full rounded-full bg-muted overflow-hidden\">\n                  <div\n                    className=\"h-full rounded-full bg-primary transition-all duration-300\"\n                    style={{ width: `${progress.pct}%` }}\n                  />\n                </div>\n              </div>\n            )}\n\n            <Button\n              onClick={handleClone}\n              disabled={!repoUrl.trim() || isCloning}\n              className=\"w-full\"\n            >\n              {isCloning ? (\n                <>\n                  <Loader2 className=\"mr-2 h-4 w-4 animate-spin\" />\n                  Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø®â€¦ {progress.pct}%\n                </>\n              ) : (\n                <>\n                  <Github className=\"mr-2 h-4 w-4\" />\n                  Clone\n                </>\n              )}\n            </Button>\n          </div>\n        )}\n      </DialogContent>\n    </Dialog>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\editor\\editor-skeleton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\editor\\editor-tabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\editor\\monaco-editor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\editor\\monaco-wrapper.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\file-explorer\\file-context-menu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\file-explorer\\file-dialog.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\file-explorer\\file-tree-item.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\file-explorer\\file-tree.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\help\\keyboard-shortcuts-dialog.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\layout\\activity-bar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\layout\\editor-area.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\layout\\error-boundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\layout\\main-layout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\layout\\panel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\layout\\sidebar.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'width' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 41,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 41,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE - Sidebar v3.0\n * Dynamic sidebar that switches content based on active view.\n * Supports all 5 views: explorer, search, git, terminal, settings.\n *\n * v3.0 â€” Added GitHub repo tree support.\n *   When a repo is loaded (via chat click), shows its file tree\n *   fetched from GitHub API. Clicking files opens them in the editor.\n *   Falls back to local IndexedDB tree when no GitHub repo is loaded.\n */\n\n'use client';\n\nimport { useEffect, useState, useCallback } from 'react';\nimport {\n  ChevronRight,\n  ChevronDown,\n  FileText,\n  Folder,\n  FolderOpen,\n  FolderGit2,\n  Loader2,\n  RefreshCw,\n  X,\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { useUIStore } from '@/lib/stores/ui-store';\nimport { useFilesStore } from '@/lib/stores/files-store';\nimport { useEditorStore, type RepoFileNode } from '@/lib/stores/editor-store';\nimport type { FileNode } from '@/lib/db/schema';\nimport { FileContextMenu } from '@/components/codeforge/file-explorer/file-context-menu';\nimport { GitPanel } from '@/components/codeforge/panels/git-panel';\nimport { SettingsPanel } from '@/components/codeforge/panels/settings-panel';\nimport { SearchPanel } from '@/components/codeforge/panels/search-panel';\nimport { TerminalSidePanel } from '@/components/codeforge/panels/terminal-panel';\n\ninterface SidebarProps {\n  width?: number;\n}\n\nexport default function Sidebar({ width }: SidebarProps) {\n  const { sidebarVisible, activityBarView } = useUIStore();\n\n  // Local files store (IndexedDB)\n  const {\n    rootNodes,\n    isLoading: localLoading,\n    initialize: initFiles,\n  } = useFilesStore();\n  const { openFile } = useEditorStore();\n\n  // GitHub repo tree from editor store\n  const currentRepo = useEditorStore((s) => s.currentRepo);\n  const repoTree = useEditorStore((s) => s.repoTree);\n  const repoTreeLoading = useEditorStore((s) => s.repoTreeLoading);\n  const loadRepoTree = useEditorStore((s) => s.loadRepoTree);\n  const loadRepoTreeChildren = useEditorStore((s) => s.loadRepoTreeChildren);\n  const openRepoFile = useEditorStore((s) => s.openRepoFile);\n\n  // Local state for expanded folders\n  const [expandedLocal, setExpandedLocal] = useState<Set<string>>(new Set());\n  const [expandedRepo, setExpandedRepo] = useState<Set<string>>(new Set());\n  const [loadingDirs, setLoadingDirs] = useState<Set<string>>(new Set());\n\n  useEffect(() => {\n    initFiles();\n  }, [initFiles]);\n\n  // â”€â”€â”€ Local folder toggle â”€â”€â”€\n  const toggleLocalFolder = useCallback((folderId: string) => {\n    setExpandedLocal((prev) => {\n      const next = new Set(prev);\n      if (next.has(folderId)) next.delete(folderId);\n      else next.add(folderId);\n      return next;\n    });\n  }, []);\n\n  // â”€â”€â”€ Repo folder toggle (with lazy loading) â”€â”€â”€\n  const toggleRepoFolder = useCallback(\n    async (node: RepoFileNode) => {\n      const path = node.path;\n\n      // If not loaded yet, fetch children\n      if (!node.childrenLoaded) {\n        setLoadingDirs((prev) => new Set(prev).add(path));\n        try {\n          await loadRepoTreeChildren(path);\n        } catch (e) {\n          console.error('Failed to load:', path, e);\n        }\n        setLoadingDirs((prev) => {\n          const next = new Set(prev);\n          next.delete(path);\n          return next;\n        });\n      }\n\n      setExpandedRepo((prev) => {\n        const next = new Set(prev);\n        if (next.has(path)) next.delete(path);\n        else next.add(path);\n        return next;\n      });\n    },\n    [loadRepoTreeChildren]\n  );\n\n  // â”€â”€â”€ Open file from local IndexedDB â”€â”€â”€\n  const handleLocalFileClick = useCallback(\n    (node: FileNode) => {\n      if (node.type === 'file') {\n        openFile({\n          id: node.id,\n          name: node.name,\n          content: node.content || '',\n          language: node.language || 'plaintext',\n          path: node.path,\n        });\n      }\n    },\n    [openFile]\n  );\n\n  // â”€â”€â”€ Open file from GitHub repo â”€â”€â”€\n  const handleRepoFileClick = useCallback(\n    async (node: RepoFileNode) => {\n      if (node.type === 'file') {\n        await openRepoFile(node.path, node.name);\n      }\n    },\n    [openRepoFile]\n  );\n\n  if (!sidebarVisible) return null;\n\n  const viewTitles: Record<string, string> = {\n    explorer: 'Ø§Ù„Ù…Ø³ØªÙƒØ´Ù',\n    search: 'Ø§Ù„Ø¨Ø­Ø«',\n    git: 'Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…ØµØ¯Ø±',\n    terminal: 'Ø§Ù„Ø·Ø±ÙÙŠØ©',\n    settings: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',\n  };\n\n  const renderContent = () => {\n    switch (activityBarView) {\n      case 'git':\n        return <GitPanel />;\n      case 'search':\n        return <SearchPanel />;\n      case 'terminal':\n        return <TerminalSidePanel />;\n      case 'settings':\n        return <SettingsPanel />;\n      case 'explorer':\n      default:\n        return renderExplorer();\n    }\n  };\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // EXPLORER VIEW â€” combines GitHub repo tree + local tree\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  const renderExplorer = () => {\n    return (\n      <div className=\"flex flex-col h-full\">\n        {/* GitHub Repo Tree (if loaded) */}\n        {currentRepo && renderGitHubRepoTree()}\n\n        {/* Local File Tree (IndexedDB) */}\n        {!currentRepo && renderLocalTree()}\n      </div>\n    );\n  };\n\n  // â”€â”€â”€ GitHub Repo File Tree â”€â”€â”€\n  const renderGitHubRepoTree = () => {\n    return (\n      <div className=\"flex flex-col flex-1\">\n        {/* Repo header */}\n        <div className=\"flex items-center justify-between px-3 py-1.5 bg-accent/30 border-b\">\n          <div className=\"flex items-center gap-1.5 min-w-0\">\n            <FolderGit2 className=\"h-3.5 w-3.5 shrink-0 text-purple-400\" />\n            <span className=\"text-xs font-medium truncate text-foreground\">\n              {currentRepo!.owner}/{currentRepo!.repo}\n            </span>\n          </div>\n          <div className=\"flex items-center gap-0.5\">\n            <button\n              onClick={() =>\n                loadRepoTree(\n                  currentRepo!.owner,\n                  currentRepo!.repo,\n                  currentRepo!.branch\n                )\n              }\n              className=\"p-1 rounded hover:bg-accent text-muted-foreground hover:text-foreground transition-colors\"\n              title=\"ØªØ­Ø¯ÙŠØ«\"\n            >\n              <RefreshCw className=\"h-3 w-3\" />\n            </button>\n            <button\n              onClick={() => {\n                useEditorStore.setState({ currentRepo: null, repoTree: [] });\n                setExpandedRepo(new Set());\n              }}\n              className=\"p-1 rounded hover:bg-accent text-muted-foreground hover:text-foreground transition-colors\"\n              title=\"Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹\"\n            >\n              <X className=\"h-3 w-3\" />\n            </button>\n          </div>\n        </div>\n\n        {/* Tree content */}\n        <div className=\"flex-1 overflow-y-auto py-1\">\n          {repoTreeLoading ? (\n            <div className=\"flex items-center justify-center py-8\">\n              <Loader2 className=\"h-5 w-5 animate-spin text-muted-foreground\" />\n            </div>\n          ) : repoTree.length === 0 ? (\n            <div className=\"p-4 text-center text-xs text-muted-foreground\">\n              Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ ÙØ§Ø±Øº\n            </div>\n          ) : (\n            repoTree.map((node) => renderRepoNode(node, 0))\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  // â”€â”€â”€ Render a single repo node â”€â”€â”€\n  const renderRepoNode = (\n    node: RepoFileNode,\n    depth: number\n  ): React.ReactNode => {\n    const isDir = node.type === 'dir';\n    const isExpanded = expandedRepo.has(node.path);\n    const isLoadingDir = loadingDirs.has(node.path);\n\n    return (\n      <div key={node.path}>\n        <button\n          className={cn(\n            'flex w-full items-center gap-1 px-2 py-[3px] text-[13px] hover:bg-accent/50',\n            'focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring',\n            'transition-colors'\n          )}\n          style={{ paddingLeft: `${12 + depth * 16}px` }}\n          onClick={() => {\n            if (isDir) {\n              toggleRepoFolder(node);\n            } else {\n              handleRepoFileClick(node);\n            }\n          }}\n        >\n          {/* Expand/collapse icon for dirs */}\n          {isDir ? (\n            isLoadingDir ? (\n              <Loader2 className=\"h-3.5 w-3.5 shrink-0 animate-spin text-muted-foreground\" />\n            ) : isExpanded ? (\n              <ChevronDown className=\"h-3.5 w-3.5 shrink-0 text-muted-foreground\" />\n            ) : (\n              <ChevronRight className=\"h-3.5 w-3.5 shrink-0 text-muted-foreground\" />\n            )\n          ) : (\n            <span className=\"w-3.5 shrink-0\" />\n          )}\n\n          {/* File/folder icon */}\n          {isDir ? (\n            isExpanded ? (\n              <FolderOpen className=\"h-4 w-4 shrink-0 text-blue-400\" />\n            ) : (\n              <Folder className=\"h-4 w-4 shrink-0 text-blue-400\" />\n            )\n          ) : (\n            <FileText className=\"h-4 w-4 shrink-0 text-muted-foreground\" />\n          )}\n\n          {/* Name */}\n          <span className=\"truncate text-left\">{node.name}</span>\n        </button>\n\n        {/* Children */}\n        {isDir && isExpanded && node.children && node.children.length > 0 && (\n          <div>\n            {node.children.map((child) => renderRepoNode(child, depth + 1))}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // â”€â”€â”€ Local file tree (IndexedDB, fallback) â”€â”€â”€\n  const renderLocalTree = () => {\n    if (localLoading) {\n      return (\n        <div className=\"flex items-center justify-center py-8\">\n          <Loader2 className=\"h-5 w-5 animate-spin text-muted-foreground\" />\n        </div>\n      );\n    }\n\n    if (!rootNodes || rootNodes.length === 0) {\n      return (\n        <div className=\"p-4 text-center\">\n          <p className=\"text-sm text-muted-foreground\">\n            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª â€” Ø§ÙØªØ­ Ù…Ø¬Ù„Ø¯Ø§Ù‹ Ø£Ùˆ Ø§Ø³ØªÙ†Ø³Ø® Ù…Ø³ØªÙˆØ¯Ø¹Ø§Ù‹\n          </p>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"py-1\">\n        {sortNodes(rootNodes).map((node) => renderLocalNode(node, 0))}\n      </div>\n    );\n  };\n\n  const renderLocalNode = (\n    node: FileNode & { children?: FileNode[] },\n    depth: number\n  ): React.ReactNode => {\n    const isFolder = node.type === 'folder';\n    const isExpanded = expandedLocal.has(node.id);\n\n    return (\n      <FileContextMenu key={node.id} node={node}>\n        <div>\n          <button\n            className={cn(\n              'flex w-full items-center gap-1 px-2 py-[3px] text-[13px] hover:bg-accent/50',\n              'focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring'\n            )}\n            style={{ paddingLeft: `${12 + depth * 16}px` }}\n            onClick={() =>\n              isFolder ? toggleLocalFolder(node.id) : handleLocalFileClick(node)\n            }\n          >\n            {isFolder ? (\n              isExpanded ? (\n                <ChevronDown className=\"h-4 w-4 shrink-0 text-muted-foreground\" />\n              ) : (\n                <ChevronRight className=\"h-4 w-4 shrink-0 text-muted-foreground\" />\n              )\n            ) : (\n              <FileText className=\"h-4 w-4 shrink-0 text-muted-foreground\" />\n            )}\n            {isFolder && <Folder className=\"h-4 w-4 shrink-0 text-blue-400\" />}\n            <span className=\"truncate text-left\">{node.name}</span>\n          </button>\n          {isFolder && isExpanded && node.children && (\n            <div>\n              {sortNodes(node.children).map(\n                (child: FileNode & { children?: FileNode[] }) =>\n                  renderLocalNode(child, depth + 1)\n              )}\n            </div>\n          )}\n        </div>\n      </FileContextMenu>\n    );\n  };\n\n  return (\n    <div className=\"flex h-full flex-col border-r bg-[hsl(var(--cf-sidebar))]\">\n      <div className=\"border-b px-4 py-2\">\n        <h2 className=\"text-xs font-semibold uppercase tracking-wider text-muted-foreground\">\n          {viewTitles[activityBarView] || activityBarView}\n        </h2>\n      </div>\n      <div className=\"flex-1 overflow-y-auto\">{renderContent()}</div>\n    </div>\n  );\n}\n\n/** Sort nodes: folders first, then alphabetically */\nfunction sortNodes(nodes: FileNode[]): FileNode[] {\n  return [...nodes].sort((a, b) => {\n    if (a.type === 'folder' && b.type !== 'folder') return -1;\n    if (a.type !== 'folder' && b.type === 'folder') return 1;\n    return a.name.localeCompare(b.name);\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\layout\\status-bar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\notifications\\notification-badge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\notifications\\notification-center.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\notifications\\notification-toast.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\panels\\git-panel.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'FileText' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 21,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 21,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'pullProgress' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 56,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 56,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Git Source Control Panel\n * Professional source control UI with stage/unstage, commit, push, pull.\n */\n\n'use client';\n\nimport { useEffect, useCallback } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { useGitStore, type TrackedChange } from '@/lib/stores/git-store';\nimport { useAuthStore } from '@/lib/stores/auth-store';\nimport { useNotificationStore } from '@/lib/stores/notification-store';\nimport {\n  GitBranch,\n  Upload,\n  Download,\n  Plus,\n  Minus,\n  Edit3,\n  Trash2,\n  FileText,\n  Check,\n  CheckCheck,\n  XCircle,\n  Loader2,\n  AlertCircle,\n  RefreshCw,\n  Github,\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\n/** Status icon + color for each change type */\nfunction StatusBadge({ status }: { status: TrackedChange['status'] }) {\n  const config = {\n    modified: { icon: Edit3, color: 'text-yellow-500', label: 'M' },\n    added: { icon: Plus, color: 'text-green-500', label: 'A' },\n    deleted: { icon: Trash2, color: 'text-red-500', label: 'D' },\n  };\n  const { icon: Icon, color, label } = config[status];\n  return (\n    <span className={cn('flex items-center gap-1 text-xs font-mono', color)}>\n      <Icon className=\"h-3 w-3\" />\n      {label}\n    </span>\n  );\n}\n\nexport function GitPanel() {\n  const {\n    repoContext,\n    changes,\n    commitMessage,\n    isPushing,\n    isPulling,\n    pushProgress,\n    pullProgress,\n    lastPushResult,\n    error,\n    detectChanges,\n    stageFile,\n    unstageFile,\n    stageAll,\n    unstageAll,\n    setCommitMessage,\n    push,\n    pull,\n    clearError,\n  } = useGitStore();\n\n  const { isAuthenticated } = useAuthStore();\n  const { addNotification } = useNotificationStore();\n\n  // Auto-detect changes on mount and periodically\n  useEffect(() => {\n    detectChanges();\n    const interval = setInterval(detectChanges, 5000); // every 5s\n    return () => clearInterval(interval);\n  }, [detectChanges]);\n\n  const stagedChanges = changes.filter((c) => c.staged);\n  const unstagedChanges = changes.filter((c) => !c.staged);\n\n  const handlePush = useCallback(async () => {\n    try {\n      const result = await push();\n      addNotification({\n        type: 'success',\n        title: 'ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­!',\n        message: `Commit ${result.sha.slice(0, 7)}: ${result.files_changed} Ù…Ù„Ù`,\n        autoDismiss: true,\n        dismissAfterMs: 6000,\n      });\n    } catch (err) {\n      addNotification({\n        type: 'error',\n        title: 'ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹',\n        message: err instanceof Error ? err.message : 'Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹',\n        autoDismiss: false,\n      });\n    }\n  }, [push, addNotification]);\n\n  const handlePull = useCallback(async () => {\n    try {\n      await pull();\n      addNotification({\n        type: 'success',\n        title: 'ØªÙ… Ø§Ù„Ø³Ø­Ø¨ Ø¨Ù†Ø¬Ø§Ø­!',\n        message: 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ù† Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹.',\n        autoDismiss: true,\n      });\n    } catch (err) {\n      addNotification({\n        type: 'error',\n        title: 'ÙØ´Ù„ Ø§Ù„Ø³Ø­Ø¨',\n        message: err instanceof Error ? err.message : 'Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹',\n        autoDismiss: false,\n      });\n    }\n  }, [pull, addNotification]);\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {\n      e.preventDefault();\n      if (stagedChanges.length > 0 && commitMessage.trim()) {\n        handlePush();\n      }\n    }\n  };\n\n  // â”€â”€â”€ Not Connected â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  if (!isAuthenticated) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full p-6 text-center space-y-3\">\n        <Github className=\"h-10 w-10 text-muted-foreground\" />\n        <p className=\"text-sm text-muted-foreground\">\n          Ø³Ø¬Ù‘Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù€ GitHub Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Source Control\n        </p>\n      </div>\n    );\n  }\n\n  if (!repoContext) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full p-6 text-center space-y-3\">\n        <GitBranch className=\"h-10 w-10 text-muted-foreground\" />\n        <p className=\"text-sm text-muted-foreground\">\n          Ø§Ø³ØªÙ†Ø³Ø® Ù…Ø³ØªÙˆØ¯Ø¹Ø§Ù‹ Ù„ØªÙØ¹ÙŠÙ„ Source Control\n        </p>\n      </div>\n    );\n  }\n\n  // â”€â”€â”€ Connected â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  return (\n    <div className=\"flex flex-col h-full text-sm\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between border-b px-3 py-2\">\n        <div className=\"flex items-center gap-2\">\n          <GitBranch className=\"h-4 w-4 text-primary\" />\n          <span className=\"font-medium\">\n            {repoContext.owner}/{repoContext.repo}\n          </span>\n        </div>\n        <div className=\"flex items-center gap-1\">\n          <span className=\"text-xs text-muted-foreground bg-muted px-1.5 py-0.5 rounded\">\n            {repoContext.branch}\n          </span>\n          <Button\n            variant=\"ghost\"\n            size=\"icon\"\n            className=\"h-6 w-6\"\n            onClick={() => detectChanges()}\n            title=\"ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª\"\n          >\n            <RefreshCw className=\"h-3 w-3\" />\n          </Button>\n        </div>\n      </div>\n\n      {/* Error */}\n      {error && (\n        <div className=\"flex items-start gap-2 border-b bg-destructive/10 px-3 py-2\">\n          <AlertCircle className=\"mt-0.5 h-4 w-4 text-destructive shrink-0\" />\n          <div className=\"flex-1 text-xs text-destructive\">{error}</div>\n          <button\n            onClick={clearError}\n            className=\"text-destructive hover:text-destructive/80\"\n          >\n            <XCircle className=\"h-3 w-3\" />\n          </button>\n        </div>\n      )}\n\n      {/* Commit Message */}\n      <div className=\"border-b px-3 py-2 space-y-2\">\n        <textarea\n          value={commitMessage}\n          onChange={(e) => setCommitMessage(e.target.value)}\n          onKeyDown={handleKeyDown}\n          placeholder=\"Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù€ commit (Ctrl+Enter Ù„Ù„Ø¯ÙØ¹)\"\n          className=\"w-full resize-none rounded-md border bg-background px-2 py-1.5 text-xs focus:outline-none focus:ring-1 focus:ring-ring\"\n          rows={3}\n          disabled={isPushing}\n        />\n        <div className=\"flex gap-1\">\n          <Button\n            size=\"sm\"\n            className=\"flex-1 h-7 text-xs\"\n            onClick={handlePush}\n            disabled={\n              isPushing || stagedChanges.length === 0 || !commitMessage.trim()\n            }\n          >\n            {isPushing ? (\n              <>\n                <Loader2 className=\"mr-1 h-3 w-3 animate-spin\" />\n                {pushProgress.pct}%\n              </>\n            ) : (\n              <>\n                <Upload className=\"mr-1 h-3 w-3\" />\n                Commit & Push ({stagedChanges.length})\n              </>\n            )}\n          </Button>\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"h-7 text-xs\"\n            onClick={handlePull}\n            disabled={isPulling}\n            title=\"Ø³Ø­Ø¨ Ø¢Ø®Ø± Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª\"\n          >\n            {isPulling ? (\n              <Loader2 className=\"h-3 w-3 animate-spin\" />\n            ) : (\n              <Download className=\"h-3 w-3\" />\n            )}\n          </Button>\n        </div>\n\n        {/* Push Progress */}\n        {isPushing && (\n          <div className=\"space-y-1\">\n            <p className=\"text-xs text-muted-foreground\">{pushProgress.msg}</p>\n            <div className=\"h-1 w-full rounded-full bg-muted overflow-hidden\">\n              <div\n                className=\"h-full rounded-full bg-primary transition-all duration-300\"\n                style={{ width: `${pushProgress.pct}%` }}\n              />\n            </div>\n          </div>\n        )}\n\n        {/* Last Push Result */}\n        {lastPushResult && !isPushing && (\n          <div className=\"flex items-center gap-1 text-xs text-green-500\">\n            <Check className=\"h-3 w-3\" />\n            <span>Ø¢Ø®Ø± push: {lastPushResult.sha.slice(0, 7)}</span>\n          </div>\n        )}\n      </div>\n\n      {/* Changes List */}\n      <div className=\"flex-1 overflow-y-auto\">\n        {/* Staged Changes */}\n        {stagedChanges.length > 0 && (\n          <div>\n            <div className=\"flex items-center justify-between px-3 py-1.5 bg-muted/50\">\n              <span className=\"text-xs font-medium uppercase tracking-wide\">\n                Staged ({stagedChanges.length})\n              </span>\n              <button\n                onClick={unstageAll}\n                className=\"text-xs text-muted-foreground hover:text-foreground\"\n                title=\"Unstage All\"\n              >\n                <Minus className=\"h-3 w-3\" />\n              </button>\n            </div>\n            {stagedChanges.map((change) => (\n              <ChangeRow\n                key={change.path}\n                change={change}\n                onAction={() => unstageFile(change.path)}\n                actionIcon={<Minus className=\"h-3 w-3\" />}\n                actionTitle=\"Unstage\"\n              />\n            ))}\n          </div>\n        )}\n\n        {/* Unstaged Changes */}\n        {unstagedChanges.length > 0 && (\n          <div>\n            <div className=\"flex items-center justify-between px-3 py-1.5 bg-muted/50\">\n              <span className=\"text-xs font-medium uppercase tracking-wide\">\n                Changes ({unstagedChanges.length})\n              </span>\n              <button\n                onClick={stageAll}\n                className=\"text-xs text-muted-foreground hover:text-foreground\"\n                title=\"Stage All\"\n              >\n                <Plus className=\"h-3 w-3\" />\n              </button>\n            </div>\n            {unstagedChanges.map((change) => (\n              <ChangeRow\n                key={change.path}\n                change={change}\n                onAction={() => stageFile(change.path)}\n                actionIcon={<Plus className=\"h-3 w-3\" />}\n                actionTitle=\"Stage\"\n              />\n            ))}\n          </div>\n        )}\n\n        {/* No Changes */}\n        {changes.length === 0 && (\n          <div className=\"flex flex-col items-center justify-center py-12 text-center\">\n            <CheckCheck className=\"h-8 w-8 text-green-500 mb-2\" />\n            <p className=\"text-xs text-muted-foreground\">\n              Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª â€” ÙƒÙ„ Ø´ÙŠØ¡ Ù…Ø­Ø¯Ù‘Ø«\n            </p>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\n/* ------------------------------------------------------------------ */\n/*  Change Row Component                                               */\n/* ------------------------------------------------------------------ */\n\nfunction ChangeRow({\n  change,\n  onAction,\n  actionIcon,\n  actionTitle,\n}: {\n  change: TrackedChange;\n  onAction: () => void;\n  actionIcon: React.ReactNode;\n  actionTitle: string;\n}) {\n  const fileName = change.path.split('/').pop() || change.path;\n  const dirPath = change.path.split('/').slice(0, -1).join('/');\n\n  return (\n    <div className=\"group flex items-center gap-2 px-3 py-1 hover:bg-accent/50 cursor-pointer\">\n      <StatusBadge status={change.status} />\n      <div className=\"flex-1 min-w-0\">\n        <span className=\"text-xs truncate block\">{fileName}</span>\n        {dirPath && (\n          <span className=\"text-[10px] text-muted-foreground truncate block\">\n            {dirPath}\n          </span>\n        )}\n      </div>\n      <button\n        onClick={(e) => {\n          e.stopPropagation();\n          onAction();\n        }}\n        className=\"opacity-0 group-hover:opacity-100 p-0.5 rounded hover:bg-accent transition-opacity\"\n        title={actionTitle}\n      >\n        {actionIcon}\n      </button>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\panels\\search-panel.tsx",
    "messages": [
      {
        "ruleId": "react/no-unescaped-entities",
        "severity": 2,
        "message": "`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.",
        "line": 202,
        "column": 30,
        "nodeType": "JSXText",
        "messageId": "unescapedEntityAlts",
        "suggestions": [
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&quot;" },
            "fix": {
              "range": [6183, 6214],
              "text": "\n            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù€ &quot;"
            },
            "desc": "Replace with `&quot;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&ldquo;" },
            "fix": {
              "range": [6183, 6214],
              "text": "\n            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù€ &ldquo;"
            },
            "desc": "Replace with `&ldquo;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&#34;" },
            "fix": {
              "range": [6183, 6214],
              "text": "\n            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù€ &#34;"
            },
            "desc": "Replace with `&#34;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&rdquo;" },
            "fix": {
              "range": [6183, 6214],
              "text": "\n            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù€ &rdquo;"
            },
            "desc": "Replace with `&rdquo;`."
          }
        ]
      },
      {
        "ruleId": "react/no-unescaped-entities",
        "severity": 2,
        "message": "`\"` can be escaped with `&quot;`, `&ldquo;`, `&#34;`, `&rdquo;`.",
        "line": 202,
        "column": 38,
        "nodeType": "JSXText",
        "messageId": "unescapedEntityAlts",
        "suggestions": [
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&quot;" },
            "fix": { "range": [6221, 6233], "text": "&quot;\n          " },
            "desc": "Replace with `&quot;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&ldquo;" },
            "fix": { "range": [6221, 6233], "text": "&ldquo;\n          " },
            "desc": "Replace with `&ldquo;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&#34;" },
            "fix": { "range": [6221, 6233], "text": "&#34;\n          " },
            "desc": "Replace with `&#34;`."
          },
          {
            "messageId": "replaceWithAlt",
            "data": { "alt": "&rdquo;" },
            "fix": { "range": [6221, 6233], "text": "&rdquo;\n          " },
            "desc": "Replace with `&rdquo;`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\n/**\n * CodeForge IDE â€” Search Panel v1.0\n * File content search with regex support.\n * Searches across all project files in the local store.\n */\n\nimport React, { useState, useCallback, useRef } from 'react';\nimport {\n  Search,\n  FileText,\n  CaseSensitive,\n  Regex,\n  X,\n  Loader2,\n} from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport { useFilesStore } from '@/lib/stores/files-store';\nimport { useEditorStore } from '@/lib/stores/editor-store';\nimport type { FileNode } from '@/lib/db/schema';\n\ninterface SearchResult {\n  file: FileNode;\n  line: number;\n  content: string;\n  matchStart: number;\n  matchEnd: number;\n}\n\nexport function SearchPanel() {\n  const { fileTree } = useFilesStore();\n  const { openFile } = useEditorStore();\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState<SearchResult[]>([]);\n  const [isSearching, setIsSearching] = useState(false);\n  const [caseSensitive, setCaseSensitive] = useState(false);\n  const [useRegex, setUseRegex] = useState(false);\n  const [searchDone, setSearchDone] = useState(false);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  // Flatten file tree to get all files\n  const flattenFiles = useCallback((nodes: FileNode[]): FileNode[] => {\n    const files: FileNode[] = [];\n    const walk = (list: (FileNode & { children?: FileNode[] })[]) => {\n      for (const node of list) {\n        if (node.type === 'file') files.push(node);\n        if (node.children) walk(node.children);\n      }\n    };\n    walk(nodes as (FileNode & { children?: FileNode[] })[]);\n    return files;\n  }, []);\n\n  const handleSearch = useCallback(() => {\n    if (!query.trim() || !fileTree) return;\n\n    setIsSearching(true);\n    setSearchDone(false);\n\n    // Use setTimeout to avoid blocking the UI\n    setTimeout(() => {\n      const allFiles = flattenFiles(fileTree);\n      const found: SearchResult[] = [];\n\n      let pattern: RegExp;\n      try {\n        if (useRegex) {\n          pattern = new RegExp(query, caseSensitive ? 'g' : 'gi');\n        } else {\n          const escaped = query.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n          pattern = new RegExp(escaped, caseSensitive ? 'g' : 'gi');\n        }\n      } catch {\n        setIsSearching(false);\n        setSearchDone(true);\n        return;\n      }\n\n      for (const file of allFiles) {\n        if (!file.content) continue;\n        const lines = file.content.split('\\n');\n        for (let i = 0; i < lines.length; i++) {\n          const match = pattern.exec(lines[i]);\n          if (match) {\n            found.push({\n              file,\n              line: i + 1,\n              content: lines[i].trim(),\n              matchStart: match.index,\n              matchEnd: match.index + match[0].length,\n            });\n          }\n          pattern.lastIndex = 0; // Reset for next line\n        }\n        if (found.length > 200) break; // Limit results\n      }\n\n      setResults(found);\n      setIsSearching(false);\n      setSearchDone(true);\n    }, 50);\n  }, [query, fileTree, caseSensitive, useRegex, flattenFiles]);\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (e.key === 'Enter') handleSearch();\n    },\n    [handleSearch]\n  );\n\n  const openResult = useCallback(\n    (result: SearchResult) => {\n      openFile({\n        id: result.file.id,\n        name: result.file.name,\n        content: result.file.content || '',\n        language: result.file.language || 'plaintext',\n        path: result.file.path,\n      });\n    },\n    [openFile]\n  );\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Search input */}\n      <div className=\"p-2 border-b border-[#313244]\">\n        <div className=\"flex items-center gap-1 rounded-md border border-[#313244] bg-[#1e1e2e] px-2 py-1\">\n          <Search size={12} className=\"text-[#6c7086] shrink-0\" />\n          <input\n            ref={inputRef}\n            type=\"text\"\n            value={query}\n            onChange={(e) => setQuery(e.target.value)}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Ø§Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ù…Ù„ÙØ§Øª...\"\n            className=\"flex-1 bg-transparent text-xs text-[#cdd6f4] placeholder:text-[#45475a] focus:outline-none\"\n            dir=\"auto\"\n          />\n          {query && (\n            <button\n              onClick={() => {\n                setQuery('');\n                setResults([]);\n                setSearchDone(false);\n              }}\n              className=\"text-[#6c7086] hover:text-[#cdd6f4]\"\n            >\n              <X size={12} />\n            </button>\n          )}\n        </div>\n\n        {/* Options */}\n        <div className=\"flex items-center gap-1 mt-1.5\">\n          <button\n            onClick={() => setCaseSensitive(!caseSensitive)}\n            className={cn(\n              'flex items-center gap-1 rounded px-1.5 py-0.5 text-[10px] transition-colors',\n              caseSensitive\n                ? 'bg-[#89b4fa]/20 text-[#89b4fa]'\n                : 'text-[#6c7086] hover:text-[#cdd6f4]'\n            )}\n            title=\"Ø­Ø³Ø§Ø³ÙŠØ© Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ø­Ø±Ù\"\n          >\n            <CaseSensitive size={12} />\n            Aa\n          </button>\n          <button\n            onClick={() => setUseRegex(!useRegex)}\n            className={cn(\n              'flex items-center gap-1 rounded px-1.5 py-0.5 text-[10px] transition-colors',\n              useRegex\n                ? 'bg-[#89b4fa]/20 text-[#89b4fa]'\n                : 'text-[#6c7086] hover:text-[#cdd6f4]'\n            )}\n            title=\"ØªØ¹Ø¨ÙŠØ± Ù…Ù†ØªØ¸Ù… (Regex)\"\n          >\n            <Regex size={12} />\n            .*\n          </button>\n          <div className=\"flex-1\" />\n          {searchDone && (\n            <span className=\"text-[10px] text-[#6c7086]\">\n              {results.length} Ù†ØªÙŠØ¬Ø©\n            </span>\n          )}\n        </div>\n      </div>\n\n      {/* Results */}\n      <div className=\"flex-1 overflow-y-auto\">\n        {isSearching && (\n          <div className=\"flex items-center justify-center py-8\">\n            <Loader2 className=\"h-4 w-4 animate-spin text-[#6c7086]\" />\n          </div>\n        )}\n\n        {!isSearching && searchDone && results.length === 0 && (\n          <div className=\"p-4 text-center text-[11px] text-[#6c7086]\">\n            Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù€ \"{query}\"\n          </div>\n        )}\n\n        {!isSearching && results.length > 0 && (\n          <div className=\"py-1\">\n            {results.map((result, idx) => (\n              <button\n                key={`${result.file.id}-${result.line}-${idx}`}\n                onClick={() => openResult(result)}\n                className=\"flex w-full items-start gap-2 px-3 py-1.5 text-left hover:bg-[#313244]/50 transition-colors\"\n              >\n                <FileText\n                  size={12}\n                  className=\"text-[#6c7086] shrink-0 mt-0.5\"\n                />\n                <div className=\"min-w-0 flex-1\">\n                  <div className=\"flex items-center gap-1\">\n                    <span className=\"text-[10px] font-medium text-[#89b4fa] truncate\">\n                      {result.file.name}\n                    </span>\n                    <span className=\"text-[9px] text-[#45475a]\">\n                      :{result.line}\n                    </span>\n                  </div>\n                  <div\n                    className=\"text-[10px] font-mono text-[#a6adc8] truncate\"\n                    dir=\"ltr\"\n                  >\n                    {result.content.length > 100\n                      ? result.content.slice(0, 100) + '...'\n                      : result.content}\n                  </div>\n                </div>\n              </button>\n            ))}\n          </div>\n        )}\n\n        {!isSearching && !searchDone && (\n          <div className=\"p-4 text-center text-[11px] text-[#6c7086]\">\n            Ø§ÙƒØªØ¨ ÙƒÙ„Ù…Ø© Ø¨Ø­Ø« ÙˆØ§Ø¶ØºØ· Enter\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\panels\\self-improve-panel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\panels\\settings-panel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\panels\\terminal-panel.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'Terminal' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 11,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 11,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'ChevronDown' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 11,
        "column": 34,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 11,
        "endColumn": 45
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\n/**\n * CodeForge IDE â€” Terminal Panel (Sidebar) v1.0\n * Lightweight terminal placeholder for the sidebar.\n * Shows quick command execution and links to the full\n * terminal in the bottom panel.\n */\n\nimport React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { Terminal, Play, Trash2, ChevronDown, Info } from 'lucide-react';\nimport { cn } from '@/lib/utils';\n\ninterface CommandEntry {\n  id: string;\n  input: string;\n  output: string;\n  timestamp: number;\n  isError?: boolean;\n}\n\nexport function TerminalSidePanel() {\n  const [input, setInput] = useState('');\n  const [history, setHistory] = useState<CommandEntry[]>([]);\n  const [historyIndex, setHistoryIndex] = useState(-1);\n  const scrollRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (scrollRef.current) {\n      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n    }\n  }, [history]);\n\n  const executeCommand = useCallback((cmd: string) => {\n    const trimmed = cmd.trim();\n    if (!trimmed) return;\n\n    let output = '';\n    let isError = false;\n\n    // Simple built-in commands\n    switch (trimmed.toLowerCase()) {\n      case 'help':\n        output = [\n          'Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªÙˆÙØ±Ø©:',\n          '  help      â€” Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©',\n          '  clear     â€” Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Ø´Ø©',\n          '  date      â€” Ø§Ù„ØªØ§Ø±ÙŠØ® ÙˆØ§Ù„ÙˆÙ‚Øª',\n          '  whoami    â€” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…',\n          '  version   â€” Ø¥ØµØ¯Ø§Ø± CodeForge',\n          '',\n          'ğŸ’¡ Ù„Ù„ØªÙŠØ±Ù…Ù†Ø§Ù„ Ø§Ù„ÙƒØ§Ù…Ù„ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø³ÙÙ„ÙŠØ© (Terminal tab)',\n        ].join('\\n');\n        break;\n      case 'clear':\n        setHistory([]);\n        setInput('');\n        return;\n      case 'date':\n        output = new Date().toLocaleString('ar-DZ', {\n          dateStyle: 'full',\n          timeStyle: 'medium',\n        });\n        break;\n      case 'whoami':\n        try {\n          const user = localStorage.getItem('codeforge-github-user');\n          if (user) {\n            const parsed = JSON.parse(user);\n            output = `${parsed.login || 'unknown'} (${parsed.name || 'N/A'})`;\n          } else {\n            output = 'Ù„Ù… ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ â€” Ø£Ø¯Ø®Ù„ GitHub Token ÙÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª';\n          }\n        } catch {\n          output = 'ØºÙŠØ± Ù…ØªÙˆÙØ±';\n        }\n        break;\n      case 'version':\n        output = 'CodeForge IDE v1.0.0-alpha';\n        break;\n      default:\n        output = `Ø§Ù„Ø£Ù…Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ: ${trimmed}\\nØ§ÙƒØªØ¨ help Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªÙˆÙØ±Ø©`;\n        isError = true;\n    }\n\n    setHistory((prev) => [\n      ...prev,\n      {\n        id: crypto.randomUUID(),\n        input: trimmed,\n        output,\n        timestamp: Date.now(),\n        isError,\n      },\n    ]);\n    setInput('');\n    setHistoryIndex(-1);\n  }, []);\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (e.key === 'Enter') {\n        executeCommand(input);\n      } else if (e.key === 'ArrowUp') {\n        e.preventDefault();\n        const cmds = history.filter((h) => h.input);\n        if (cmds.length === 0) return;\n        const newIdx =\n          historyIndex < cmds.length - 1 ? historyIndex + 1 : historyIndex;\n        setHistoryIndex(newIdx);\n        setInput(cmds[cmds.length - 1 - newIdx]?.input || '');\n      } else if (e.key === 'ArrowDown') {\n        e.preventDefault();\n        if (historyIndex <= 0) {\n          setHistoryIndex(-1);\n          setInput('');\n        } else {\n          const cmds = history.filter((h) => h.input);\n          const newIdx = historyIndex - 1;\n          setHistoryIndex(newIdx);\n          setInput(cmds[cmds.length - 1 - newIdx]?.input || '');\n        }\n      }\n    },\n    [input, history, historyIndex, executeCommand]\n  );\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Header info */}\n      <div className=\"flex items-center gap-1.5 px-3 py-2 border-b border-[#313244] bg-[#181825]\">\n        <Info size={10} className=\"text-[#89b4fa]\" />\n        <span className=\"text-[10px] text-[#6c7086]\">\n          ØªÙŠØ±Ù…Ù†Ø§Ù„ Ù…Ø¨Ø³Ù‘Ø· â€” Ù„Ù„ØªÙŠØ±Ù…Ù†Ø§Ù„ Ø§Ù„ÙƒØ§Ù…Ù„ Ø§ÙØªØ­ Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„Ø³ÙÙ„ÙŠØ©\n        </span>\n      </div>\n\n      {/* Output area */}\n      <div\n        ref={scrollRef}\n        className=\"flex-1 overflow-y-auto p-2 font-mono text-[11px]\"\n        onClick={() => inputRef.current?.focus()}\n      >\n        {/* Welcome message */}\n        {history.length === 0 && (\n          <div className=\"text-[#6c7086] mb-2\">\n            <p>Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ CodeForge Terminal ğŸš€</p>\n            <p className=\"mt-1\">\n              Ø§ÙƒØªØ¨ <span className=\"text-[#a6e3a1]\">help</span> Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙˆØ§Ù…Ø±\n              Ø§Ù„Ù…ØªÙˆÙØ±Ø©\n            </p>\n          </div>\n        )}\n\n        {history.map((entry) => (\n          <div key={entry.id} className=\"mb-2\">\n            <div className=\"flex items-center gap-1\">\n              <span className=\"text-[#a6e3a1]\">â¯</span>\n              <span className=\"text-[#cdd6f4]\">{entry.input}</span>\n            </div>\n            <pre\n              className={cn(\n                'whitespace-pre-wrap mt-0.5 pl-3',\n                entry.isError ? 'text-[#f38ba8]' : 'text-[#a6adc8]'\n              )}\n            >\n              {entry.output}\n            </pre>\n          </div>\n        ))}\n      </div>\n\n      {/* Input */}\n      <div className=\"flex items-center gap-1 px-2 py-1.5 border-t border-[#313244] bg-[#181825]\">\n        <span className=\"text-[#a6e3a1] text-xs\">â¯</span>\n        <input\n          ref={inputRef}\n          type=\"text\"\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          onKeyDown={handleKeyDown}\n          placeholder=\"Ø£Ø¯Ø®Ù„ Ø£Ù…Ø±Ø§Ù‹...\"\n          className=\"flex-1 bg-transparent text-xs font-mono text-[#cdd6f4] placeholder:text-[#45475a] focus:outline-none\"\n          dir=\"ltr\"\n          autoFocus\n        />\n        <button\n          onClick={() => executeCommand(input)}\n          className=\"text-[#6c7086] hover:text-[#a6e3a1] transition-colors\"\n          title=\"ØªÙ†ÙÙŠØ°\"\n        >\n          <Play size={12} />\n        </button>\n        <button\n          onClick={() => setHistory([])}\n          className=\"text-[#6c7086] hover:text-[#f38ba8] transition-colors\"\n          title=\"Ù…Ø³Ø­\"\n        >\n          <Trash2 size={12} />\n        </button>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\skeletons\\file-tree-skeleton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\skeletons\\git-panel-skeleton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\source-control\\git-history-panel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\source-control\\git-output-panel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\status-bar\\status-bar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\terminal\\terminal-skeleton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\terminal\\terminal-wrapper.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\codeforge\\welcome\\welcome-screen.tsx",
    "messages": [
      {
        "ruleId": "@next/next/no-img-element",
        "severity": 1,
        "message": "Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element",
        "line": 282,
        "column": 17,
        "nodeType": "JSXOpeningElement",
        "endLine": 286,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "'use client';\n\nimport { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport {\n  FolderOpen,\n  GitBranch,\n  FileText,\n  Book,\n  Keyboard,\n  Github,\n  Clock,\n  Loader2,\n  User,\n} from 'lucide-react';\nimport { useEditorStore } from '@/lib/stores/editor-store';\nimport { useAuthStore } from '@/lib/stores/auth-store';\nimport { useNotificationStore } from '@/lib/stores/notification-store';\nimport { openFolder } from '@/lib/services/file-system.service';\nimport { AuthDialog } from '@/components/codeforge/dialogs/auth-dialog';\nimport { CloneDialog } from '@/components/codeforge/dialogs/clone-dialog';\n\n/** Docs that can be opened inside the editor */\nconst DOCS = {\n  architecture: {\n    name: 'architecture.md',\n    path: '/docs/architecture.md',\n    language: 'markdown',\n  },\n  git: {\n    name: 'git-integration.md',\n    path: '/docs/git-integration.md',\n    language: 'markdown',\n  },\n  shortcuts: {\n    name: 'keyboard-shortcuts.md',\n    path: '/docs/keyboard-shortcuts.md',\n    language: 'markdown',\n  },\n} as const;\n\nexport function WelcomeScreen() {\n  const { openFile } = useEditorStore();\n  const { addNotification } = useNotificationStore();\n  const { isAuthenticated, user, restoreSession } = useAuthStore();\n\n  const [authOpen, setAuthOpen] = useState(false);\n  const [cloneOpen, setCloneOpen] = useState(false);\n  const [isOpeningFolder, setIsOpeningFolder] = useState(false);\n\n  // Restore GitHub session on mount\n  useEffect(() => {\n    restoreSession();\n  }, [restoreSession]);\n\n  const handleOpenFolder = async () => {\n    setIsOpeningFolder(true);\n    try {\n      const result = await openFolder();\n      addNotification({\n        type: 'success',\n        title: 'ØªÙ… ÙØªØ­ Ø§Ù„Ù…Ø¬Ù„Ø¯',\n        message: `ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ ${result.imported} Ù…Ù„Ù Ù…Ù† \"${result.rootName}\"`,\n        autoDismiss: true,\n        dismissAfterMs: 5000,\n      });\n    } catch (err) {\n      if (err instanceof Error && err.message.includes('cancelled')) return;\n      addNotification({\n        type: 'error',\n        title: 'ÙØ´Ù„ ÙØªØ­ Ø§Ù„Ù…Ø¬Ù„Ø¯',\n        message: err instanceof Error ? err.message : 'Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹',\n        autoDismiss: false,\n      });\n    } finally {\n      setIsOpeningFolder(false);\n    }\n  };\n\n  const handleCloneRepository = () => {\n    if (!isAuthenticated) {\n      addNotification({\n        type: 'warning',\n        title: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø·Ù„ÙˆØ¨',\n        message: 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù€ GitHub Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø® Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹Ø§Øª.',\n        autoDismiss: true,\n        action: {\n          label: 'ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',\n          onClick: () => setAuthOpen(true),\n        },\n      });\n      return;\n    }\n    setCloneOpen(true);\n  };\n\n  const openDocInEditor = (doc: (typeof DOCS)[keyof typeof DOCS]) => {\n    openFile({\n      id: `doc-${doc.path}`,\n      name: doc.name,\n      content: `# ${doc.name}\\n\\nLoading documentation...`,\n      language: doc.language,\n      path: doc.path,\n    });\n  };\n\n  const recentProjects = [\n    {\n      name: 'my-project',\n      path: '/projects/my-project',\n      lastOpened: '2 hours ago',\n    },\n    { name: 'web-app', path: '/projects/web-app', lastOpened: '1 day ago' },\n    {\n      name: 'api-server',\n      path: '/projects/api-server',\n      lastOpened: '3 days ago',\n    },\n  ];\n\n  return (\n    <div className=\"flex items-center justify-center h-full bg-background\">\n      <div className=\"w-full max-w-4xl p-8 space-y-8\">\n        {/* Header */}\n        <div className=\"text-center space-y-4\">\n          <div className=\"flex items-center justify-center space-x-2\">\n            <svg\n              className=\"w-16 h-16\"\n              viewBox=\"0 0 100 100\"\n              fill=\"none\"\n              xmlns=\"http://www.w3.org/2000/svg\"\n            >\n              <rect\n                width=\"100\"\n                height=\"100\"\n                rx=\"20\"\n                fill=\"currentColor\"\n                className=\"text-primary\"\n              />\n              <path\n                d=\"M30 40 L50 60 L70 40\"\n                stroke=\"white\"\n                strokeWidth=\"8\"\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n              />\n            </svg>\n            <h1 className=\"text-4xl font-bold\">CodeForge IDE</h1>\n          </div>\n          <p className=\"text-xl text-muted-foreground\">\n            Ù…Ø­Ø±Ø± Ø£ÙƒÙˆØ§Ø¯ Ù…ØªÙƒØ§Ù…Ù„ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ Ù…Ø¹ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù€ Git\n          </p>\n        </div>\n\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n          {/* Quick Actions */}\n          <Card className=\"p-6 space-y-4\">\n            <h2 className=\"text-lg font-semibold flex items-center gap-2\">\n              <FileText className=\"w-5 h-5\" />\n              Quick Start\n            </h2>\n            <div className=\"space-y-2\">\n              <Button\n                variant=\"outline\"\n                className=\"w-full justify-start\"\n                onClick={handleOpenFolder}\n                disabled={isOpeningFolder}\n              >\n                {isOpeningFolder ? (\n                  <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\n                ) : (\n                  <FolderOpen className=\"w-4 h-4 mr-2\" />\n                )}\n                Open Folder\n              </Button>\n              <Button\n                variant=\"outline\"\n                className=\"w-full justify-start\"\n                onClick={handleCloneRepository}\n              >\n                <GitBranch className=\"w-4 h-4 mr-2\" />\n                Clone Repository\n              </Button>\n              <Button\n                variant=\"outline\"\n                className=\"w-full justify-start\"\n                onClick={() =>\n                  openFile({\n                    id: crypto.randomUUID(),\n                    name: 'untitled',\n                    content: '',\n                    language: 'plaintext',\n                    path: '/untitled',\n                  })\n                }\n              >\n                <FileText className=\"w-4 h-4 mr-2\" />\n                New File\n              </Button>\n            </div>\n          </Card>\n\n          {/* Recent Projects */}\n          <Card className=\"p-6 space-y-4\">\n            <h2 className=\"text-lg font-semibold flex items-center gap-2\">\n              <Clock className=\"w-5 h-5\" />\n              Recent Projects\n            </h2>\n            <div className=\"space-y-2\">\n              {recentProjects.map((project) => (\n                <Button\n                  key={project.path}\n                  variant=\"ghost\"\n                  className=\"w-full justify-start\"\n                  onClick={() =>\n                    addNotification({\n                      type: 'info',\n                      title: 'Ù‚Ø±ÙŠØ¨Ø§Ù‹',\n                      message: `ÙØªØ­ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø³ÙŠØªÙˆÙØ± ÙÙŠ Ø¥ØµØ¯Ø§Ø± Ù‚Ø§Ø¯Ù….`,\n                      autoDismiss: true,\n                    })\n                  }\n                >\n                  <FolderOpen className=\"w-4 h-4 mr-2\" />\n                  <div className=\"flex-1 text-left\">\n                    <p className=\"font-medium\">{project.name}</p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      {project.path}\n                    </p>\n                  </div>\n                  <span className=\"text-xs text-muted-foreground\">\n                    {project.lastOpened}\n                  </span>\n                </Button>\n              ))}\n            </div>\n          </Card>\n\n          {/* Getting Started â€” opens docs in editor */}\n          <Card className=\"p-6 space-y-4\">\n            <h2 className=\"text-lg font-semibold flex items-center gap-2\">\n              <Book className=\"w-5 h-5\" />\n              Getting Started\n            </h2>\n            <div className=\"space-y-2\">\n              <Button\n                variant=\"ghost\"\n                className=\"w-full justify-start\"\n                onClick={() => openDocInEditor(DOCS.architecture)}\n              >\n                <Book className=\"w-4 h-4 mr-2\" />\n                Architecture Guide\n              </Button>\n              <Button\n                variant=\"ghost\"\n                className=\"w-full justify-start\"\n                onClick={() => openDocInEditor(DOCS.git)}\n              >\n                <GitBranch className=\"w-4 h-4 mr-2\" />\n                Git Integration Guide\n              </Button>\n              <Button\n                variant=\"ghost\"\n                className=\"w-full justify-start\"\n                onClick={() => openDocInEditor(DOCS.shortcuts)}\n              >\n                <Keyboard className=\"w-4 h-4 mr-2\" />\n                Keyboard Shortcuts\n              </Button>\n            </div>\n          </Card>\n\n          {/* GitHub Connection */}\n          <Card className=\"p-6 space-y-4\">\n            <h2 className=\"text-lg font-semibold flex items-center gap-2\">\n              <Github className=\"w-5 h-5\" />\n              {isAuthenticated ? 'GitHub Connected' : 'Connect to GitHub'}\n            </h2>\n            {isAuthenticated && user ? (\n              <div className=\"flex items-center gap-3\">\n                <img\n                  src={user.avatar_url}\n                  alt={user.login}\n                  className=\"h-8 w-8 rounded-full\"\n                />\n                <div className=\"flex-1 min-w-0\">\n                  <p className=\"text-sm font-medium truncate\">\n                    {user.name || user.login}\n                  </p>\n                  <p className=\"text-xs text-muted-foreground truncate\">\n                    @{user.login}\n                  </p>\n                </div>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  onClick={() => setAuthOpen(true)}\n                >\n                  <User className=\"h-4 w-4\" />\n                </Button>\n              </div>\n            ) : (\n              <>\n                <p className=\"text-sm text-muted-foreground\">\n                  Ù‚Ù… Ø¨ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ ÙˆØ§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹Ø§Øª\n                </p>\n                <Button className=\"w-full\" onClick={() => setAuthOpen(true)}>\n                  <Github className=\"w-4 h-4 mr-2\" />\n                  Sign in with GitHub\n                </Button>\n              </>\n            )}\n          </Card>\n        </div>\n\n        {/* Hints */}\n        <div className=\"text-center space-y-2\">\n          <p className=\"text-sm text-muted-foreground\">\n            Press{' '}\n            <kbd className=\"px-2 py-1 mx-1 text-xs font-mono border rounded bg-muted\">\n              Ctrl+P\n            </kbd>{' '}\n            for Quick Open or{' '}\n            <kbd className=\"px-2 py-1 mx-1 text-xs font-mono border rounded bg-muted\">\n              ?\n            </kbd>{' '}\n            for Keyboard Shortcuts\n          </p>\n        </div>\n      </div>\n\n      {/* Dialogs */}\n      <AuthDialog open={authOpen} onOpenChange={setAuthOpen} />\n      <CloneDialog open={cloneOpen} onOpenChange={setCloneOpen} />\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\alert.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\avatar.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@next/next/no-img-element",
        "severity": 1,
        "message": "Using `<img>` could result in slower LCP and higher bandwidth. Consider using `<Image />` from `next/image` to automatically optimize images. This may incur additional usage or cost from your provider. See: https://nextjs.org/docs/messages/no-img-element",
        "line": 26,
        "column": 3,
        "nodeType": "JSXOpeningElement",
        "endLine": 31,
        "endColumn": 5,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\badge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\button.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\card.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\checkbox.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\dialog.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\dropdown-menu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\input.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\label.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\popover.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\progress.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\scroll-area.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\select.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\separator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\skeleton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\switch.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\tabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\textarea.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\components\\ui\\tooltip.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\__tests__\\integration-phase8-9.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'OODAMode' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 16,
        "column": 8,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'OODABridge' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 19,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 19,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-var-requires",
        "severity": 2,
        "message": "Require statement not part of import statement.",
        "line": 234,
        "column": 19,
        "nodeType": "CallExpression",
        "messageId": "noVarReqs",
        "endLine": 234,
        "endColumn": 73
      },
      {
        "ruleId": "@typescript-eslint/no-var-requires",
        "severity": 2,
        "message": "Require statement not part of import statement.",
        "line": 240,
        "column": 19,
        "nodeType": "CallExpression",
        "messageId": "noVarReqs",
        "endLine": 240,
        "endColumn": 73
      },
      {
        "ruleId": "@typescript-eslint/no-var-requires",
        "severity": 2,
        "message": "Require statement not part of import statement.",
        "line": 245,
        "column": 21,
        "nodeType": "CallExpression",
        "messageId": "noVarReqs",
        "endLine": 245,
        "endColumn": 53
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Phase 8-9 Integration Tests\n * Tests for OODAAgentService, useOODABridge hook, and UI integration.\n *\n * 20 tests across 5 groups:\n * - OODAAgentService lifecycle (5)\n * - Self-improve detection (5)\n * - Mode management (3)\n * - Event system (4)\n * - UI component exports (3)\n */\n\nimport {\n  OODAAgentService,\n  createOODAAgentService,\n  type OODAMode,\n  type OODAAgentEvent,\n} from '../agent-service-ooda';\nimport { OODABridge, type OODABridgeConfig } from '../bridge';\nimport type { AgentConfig, ToolDefinition } from '../types';\n\n// â”€â”€â”€ Mock Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst TEST_AGENT_CONFIG: AgentConfig = {\n  provider: 'groq',\n  apiKey: 'gsk_test_key_1234567890',\n  model: 'llama-3.3-70b-versatile',\n  temperature: 0.3,\n  maxTokens: 4096,\n  language: 'ar',\n};\n\nconst TEST_OODA_CONFIG: OODABridgeConfig = {\n  groqApiKey: 'gsk_test_key_1234567890',\n  modelId: 'llama-3.3-70b-versatile',\n  temperature: 0.3,\n};\n\nconst MOCK_TOOLS: ToolDefinition[] = [\n  {\n    name: 'test_tool',\n    description: 'A test tool',\n    parameters: { type: 'object', properties: {} },\n    category: 'utility',\n    riskLevel: 'low',\n  },\n];\n\n// â”€â”€â”€ Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('OODAAgentService â€” Lifecycle', () => {\n  let service: OODAAgentService;\n\n  beforeEach(() => {\n    service = new OODAAgentService(TEST_AGENT_CONFIG, MOCK_TOOLS);\n  });\n\n  afterEach(() => {\n    service.dispose();\n  });\n\n  test('should create without OODA initialized', () => {\n    expect(service.isOODAReady()).toBe(false);\n    expect(service.getBridge()).toBeNull();\n    expect(service.getMode()).toBe('chat');\n  });\n\n  test('should initialize OODA bridge', () => {\n    service.initOODA(TEST_OODA_CONFIG);\n    expect(service.isOODAReady()).toBe(true);\n    expect(service.getBridge()).not.toBeNull();\n  });\n\n  test('should create via factory function', () => {\n    const factoryService = createOODAAgentService(\n      TEST_AGENT_CONFIG,\n      MOCK_TOOLS,\n      TEST_OODA_CONFIG\n    );\n    expect(factoryService.isOODAReady()).toBe(true);\n    factoryService.dispose();\n  });\n\n  test('should clean up on dispose', () => {\n    service.initOODA(TEST_OODA_CONFIG);\n    service.dispose();\n    // After dispose, bridge reference may still exist but events are cleared\n    expect(service.getMode()).toBe('chat');\n  });\n\n  test('should return null for last result before any cycle', () => {\n    expect(service.getLastSelfImproveResult()).toBeNull();\n  });\n});\n\ndescribe('OODAAgentService â€” Self-Improve Detection', () => {\n  let service: OODAAgentService;\n\n  beforeEach(() => {\n    service = new OODAAgentService(TEST_AGENT_CONFIG, MOCK_TOOLS);\n  });\n\n  afterEach(() => {\n    service.dispose();\n  });\n\n  test('should detect Arabic self-improve keywords', () => {\n    // Internal detection is tested through mode changes\n    service.initOODA(TEST_OODA_CONFIG);\n    const events: OODAAgentEvent[] = [];\n    service.onOODAEvent((e) => events.push(e));\n\n    // The detection logic is internal, but we can verify the keywords exist\n    expect(service.isOODAReady()).toBe(true);\n  });\n\n  test('should detect English self-improve keywords', () => {\n    service.initOODA(TEST_OODA_CONFIG);\n    expect(service.isOODAReady()).toBe(true);\n  });\n\n  test('should respect autoDetect flag', () => {\n    service.setAutoDetect(false);\n    // When autoDetect is false, self-improve mode should not be triggered\n    expect(service.getMode()).toBe('chat');\n  });\n\n  test('should enable autoDetect by default', () => {\n    // Auto-detect should be enabled by default\n    service.initOODA(TEST_OODA_CONFIG);\n    expect(service.isOODAReady()).toBe(true);\n  });\n\n  test('should categorize UI bugs correctly', () => {\n    // Category extraction is internal but we verify the service functions\n    service.initOODA(TEST_OODA_CONFIG);\n    expect(service.getMode()).toBe('chat');\n  });\n});\n\ndescribe('OODAAgentService â€” Mode Management', () => {\n  let service: OODAAgentService;\n\n  beforeEach(() => {\n    service = new OODAAgentService(TEST_AGENT_CONFIG, MOCK_TOOLS);\n  });\n\n  afterEach(() => {\n    service.dispose();\n  });\n\n  test('should start in chat mode', () => {\n    expect(service.getMode()).toBe('chat');\n  });\n\n  test('should switch modes', () => {\n    service.setMode('self-improve');\n    expect(service.getMode()).toBe('self-improve');\n\n    service.setMode('hybrid');\n    expect(service.getMode()).toBe('hybrid');\n\n    service.setMode('chat');\n    expect(service.getMode()).toBe('chat');\n  });\n\n  test('should emit mode change events', () => {\n    const events: OODAAgentEvent[] = [];\n    service.onOODAEvent((e) => events.push(e));\n\n    service.setMode('self-improve');\n    service.setMode('chat');\n\n    const modeEvents = events.filter((e) => e.type === 'mode_change');\n    expect(modeEvents.length).toBe(2);\n    expect(modeEvents[0].mode).toBe('self-improve');\n    expect(modeEvents[1].mode).toBe('chat');\n  });\n});\n\ndescribe('OODAAgentService â€” Event System', () => {\n  let service: OODAAgentService;\n\n  beforeEach(() => {\n    service = new OODAAgentService(TEST_AGENT_CONFIG, MOCK_TOOLS);\n  });\n\n  afterEach(() => {\n    service.dispose();\n  });\n\n  test('should register event handlers', () => {\n    const events: OODAAgentEvent[] = [];\n    const unsubscribe = service.onOODAEvent((e) => events.push(e));\n    expect(typeof unsubscribe).toBe('function');\n    unsubscribe();\n  });\n\n  test('should unregister event handlers', () => {\n    const events: OODAAgentEvent[] = [];\n    const unsubscribe = service.onOODAEvent((e) => events.push(e));\n\n    service.setMode('self-improve');\n    expect(events.length).toBe(1);\n\n    unsubscribe();\n\n    service.setMode('chat');\n    // No new events after unsubscribe\n    expect(events.length).toBe(1);\n  });\n\n  test('should include timestamps in events', () => {\n    const events: OODAAgentEvent[] = [];\n    service.onOODAEvent((e) => events.push(e));\n\n    service.setMode('self-improve');\n\n    expect(events[0].timestamp).toBeDefined();\n    expect(events[0].timestamp).toBeGreaterThan(0);\n  });\n\n  test('should not emit for same mode', () => {\n    const events: OODAAgentEvent[] = [];\n    service.onOODAEvent((e) => events.push(e));\n\n    service.setMode('chat'); // Already in chat mode\n    expect(events.length).toBe(0);\n  });\n});\n\ndescribe('Phase 9 â€” UI Component Exports', () => {\n  test('should export OODAStatusBar', () => {\n    const panel = require('../../components/agent/agent-panel-enhanced');\n    expect(panel.OODAStatusBar).toBeDefined();\n    expect(typeof panel.OODAStatusBar).toBe('function');\n  });\n\n  test('should export OODAPhaseIndicator', () => {\n    const panel = require('../../components/agent/agent-panel-enhanced');\n    expect(panel.OODAPhaseIndicator).toBeDefined();\n  });\n\n  test('should export agent-service-ooda', () => {\n    const service = require('../agent-service-ooda');\n    expect(service.OODAAgentService).toBeDefined();\n    expect(service.createOODAAgentService).toBeDefined();\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\__tests__\\integration-unified-agent.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-var-requires",
        "severity": 2,
        "message": "Require statement not part of import statement.",
        "line": 193,
        "column": 33,
        "nodeType": "CallExpression",
        "messageId": "noVarReqs",
        "endLine": 193,
        "endColumn": 53
      },
      {
        "ruleId": "@typescript-eslint/no-var-requires",
        "severity": 2,
        "message": "Require statement not part of import statement.",
        "line": 199,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noVarReqs",
        "endLine": 199,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-var-requires",
        "severity": 2,
        "message": "Require statement not part of import statement.",
        "line": 205,
        "column": 20,
        "nodeType": "CallExpression",
        "messageId": "noVarReqs",
        "endLine": 205,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Unified Agent Integration Tests (Phase 7)\n * Tests the bridge connecting AgentService â†” OODA â†” Groq LLM.\n *\n * 15 tests across 4 groups:\n * - OODABridge lifecycle (5)\n * - Safety enforcement (4)\n * - Event system (3)\n * - AgentLLMAdapter (3)\n */\n\nimport {\n  OODABridge,\n  type OODABridgeConfig,\n  type SelfImproveRequest,\n  type BridgeEvent,\n} from '../bridge';\n\n// â”€â”€â”€ Mock Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst TEST_CONFIG: OODABridgeConfig = {\n  groqApiKey: 'gsk_test_key_1234567890abcdef',\n  modelId: 'llama-3.3-70b-versatile',\n  temperature: 0.3,\n  debug: false,\n};\n\nconst SAMPLE_REQUEST: SelfImproveRequest = {\n  issue: 'Ø²Ø± Ø§Ù„Ø­ÙØ¸ Ù„Ø§ ÙŠØ¹Ù…Ù„ ÙÙŠ ØµÙØ­Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',\n  category: 'ui_bug',\n  fileContents: {\n    'components/settings.tsx':\n      'export function Settings() { return <div>Settings</div>; }',\n    'lib/stores/settings-store.ts':\n      'export const useSettings = () => ({ save: () => {} });',\n  },\n  affectedFiles: ['components/settings.tsx', 'lib/stores/settings-store.ts'],\n};\n\n// â”€â”€â”€ Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('OODABridge â€” Lifecycle', () => {\n  let bridge: OODABridge;\n\n  beforeEach(() => {\n    bridge = new OODABridge(TEST_CONFIG);\n  });\n\n  afterEach(() => {\n    bridge.dispose();\n  });\n\n  test('should initialize with correct config', () => {\n    expect(bridge.isReady()).toBe(true);\n    expect(bridge.getModel()).toBe('llama-3.3-70b-versatile');\n  });\n\n  test('should report not ready without API key', () => {\n    const emptyBridge = new OODABridge({ groqApiKey: '', modelId: 'test' });\n    expect(emptyBridge.isReady()).toBe(false);\n    emptyBridge.dispose();\n  });\n\n  test('should update config dynamically', () => {\n    bridge.updateConfig({ modelId: 'llama-3.1-8b-instant' });\n    expect(bridge.getModel()).toBe('llama-3.1-8b-instant');\n  });\n\n  test('should track stats correctly', () => {\n    const stats = bridge.getStats();\n    expect(stats.totalCycles).toBe(0);\n    expect(stats.activeCycles).toBe(0);\n    expect(stats.isReady).toBe(true);\n    expect(stats.model).toBe('llama-3.3-70b-versatile');\n  });\n\n  test('should clean up on dispose', () => {\n    bridge.dispose();\n    const stats = bridge.getStats();\n    expect(stats.totalCycles).toBe(0);\n  });\n});\n\ndescribe('OODABridge â€” Safety Enforcement', () => {\n  let bridge: OODABridge;\n\n  beforeEach(() => {\n    bridge = new OODABridge(TEST_CONFIG);\n  });\n\n  afterEach(() => {\n    bridge.dispose();\n  });\n\n  test('should block protected paths', async () => {\n    const protectedRequest: SelfImproveRequest = {\n      ...SAMPLE_REQUEST,\n      affectedFiles: ['lib/agent/safety/index.ts'],\n    };\n\n    const result = await bridge.runAnalysisCycle(protectedRequest);\n    expect(result.success).toBe(false);\n    expect(result.phase).toBe('BLOCKED');\n    expect(result.error).toContain('Ù…Ø­Ù…ÙŠØ©');\n  });\n\n  test('should block .env files', async () => {\n    const envRequest: SelfImproveRequest = {\n      ...SAMPLE_REQUEST,\n      affectedFiles: ['.env.local'],\n    };\n\n    const result = await bridge.runAnalysisCycle(envRequest);\n    expect(result.success).toBe(false);\n    expect(result.phase).toBe('BLOCKED');\n  });\n\n  test('should block >10 files', async () => {\n    const manyFiles: SelfImproveRequest = {\n      ...SAMPLE_REQUEST,\n      affectedFiles: Array.from({ length: 11 }, (_, i) => `file-${i}.ts`),\n    };\n\n    const result = await bridge.runAnalysisCycle(manyFiles);\n    expect(result.success).toBe(false);\n    expect(result.error).toContain('10');\n  });\n\n  test('should block when API key is missing', async () => {\n    const noBridge = new OODABridge({ groqApiKey: '', modelId: 'test' });\n    const result = await noBridge.runAnalysisCycle(SAMPLE_REQUEST);\n    expect(result.success).toBe(false);\n    expect(result.error).toContain('Groq API');\n    noBridge.dispose();\n  });\n});\n\ndescribe('OODABridge â€” Event System', () => {\n  let bridge: OODABridge;\n\n  beforeEach(() => {\n    bridge = new OODABridge(TEST_CONFIG);\n  });\n\n  afterEach(() => {\n    bridge.dispose();\n  });\n\n  test('should register and unregister event handlers', () => {\n    const events: BridgeEvent[] = [];\n    const unsubscribe = bridge.onEvent((e) => events.push(e));\n\n    expect(typeof unsubscribe).toBe('function');\n    unsubscribe();\n    // After unsubscribe, events should not accumulate\n  });\n\n  test('should track multiple event handlers', () => {\n    const events1: BridgeEvent[] = [];\n    const events2: BridgeEvent[] = [];\n\n    const unsub1 = bridge.onEvent((e) => events1.push(e));\n    const unsub2 = bridge.onEvent((e) => events2.push(e));\n\n    expect(typeof unsub1).toBe('function');\n    expect(typeof unsub2).toBe('function');\n\n    unsub1();\n    unsub2();\n  });\n\n  test('should include timestamp in events', () => {\n    // Events are emitted during runAnalysisCycle, but we can test\n    // the structure by checking the type definition\n    const events: BridgeEvent[] = [];\n    bridge.onEvent((e) => events.push(e));\n\n    // Trigger a blocked cycle to generate events\n    bridge\n      .runAnalysisCycle({\n        ...SAMPLE_REQUEST,\n        affectedFiles: ['.env'],\n      })\n      .then(() => {\n        // Blocked cycles don't emit events, but the handler was registered\n        expect(events.length).toBe(0); // Blocked before any phase starts\n      });\n  });\n});\n\ndescribe('AgentLLMAdapter â€” Provider Compatibility', () => {\n  test('should import AgentLLMAdapter from bridge', () => {\n    const { AgentLLMAdapter } = require('../bridge');\n    expect(AgentLLMAdapter).toBeDefined();\n    expect(typeof AgentLLMAdapter).toBe('function');\n  });\n\n  test('should import OODABridge from bridge', () => {\n    const { OODABridge } = require('../bridge');\n    expect(OODABridge).toBeDefined();\n    expect(typeof OODABridge).toBe('function');\n  });\n\n  test('should import all bridge exports', () => {\n    const bridge = require('../bridge');\n    expect(bridge.OODABridge).toBeDefined();\n    expect(bridge.getOODABridge).toBeDefined();\n    expect(bridge.resetOODABridge).toBeDefined();\n    expect(bridge.AgentLLMAdapter).toBeDefined();\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\__tests__\\integration.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'PendingApproval' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 23,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 23,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Integration Test Suite v1.0\n * Phase 6: Full integration testing for the agent system.\n *\n * Tests:\n * 1. Safety classification correctness (AUTO/NOTIFY/CONFIRM)\n * 2. Approval manager creates proper approvals & notifications\n * 3. Audit logger lifecycle (log â†’ filter â†’ stats â†’ export)\n * 4. Type compatibility across all modules\n * 5. Anti-loop protection\n * 6. Agent-service sendMessage flow (mock provider)\n *\n * Run: npx jest lib/agent/__tests__/integration.test.ts\n * or:  npx vitest run lib/agent/__tests__/integration.test.ts\n */\n\nimport type {\n  ToolCall,\n  ToolDefinition,\n  RiskLevel,\n  AuditLogEntry,\n  ApprovalSource,\n  PendingApproval,\n} from '../types';\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// MOCK: localStorage (for Node.js environment)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst mockStorage: Record<string, string> = {};\n\nif (typeof globalThis.localStorage === 'undefined') {\n  (globalThis as Record<string, unknown>).localStorage = {\n    getItem: (key: string) => mockStorage[key] || null,\n    setItem: (key: string, value: string) => {\n      mockStorage[key] = value;\n    },\n    removeItem: (key: string) => {\n      delete mockStorage[key];\n    },\n    clear: () => {\n      Object.keys(mockStorage).forEach((k) => delete mockStorage[k]);\n    },\n    get length() {\n      return Object.keys(mockStorage).length;\n    },\n    key: (i: number) => Object.keys(mockStorage)[i] || null,\n  };\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST HELPERS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nfunction makeToolCall(\n  name: string,\n  args: Record<string, unknown> = {}\n): ToolCall {\n  return {\n    id: `tc-${name}-${Date.now()}`,\n    name,\n    arguments: args,\n  };\n}\n\nfunction makeToolDef(\n  name: string,\n  riskLevel: RiskLevel,\n  category: 'filesystem' | 'git' | 'github' | 'utility' = 'github'\n): ToolDefinition {\n  return {\n    name,\n    description: `Test tool: ${name}`,\n    parameters: { type: 'object', properties: {} },\n    riskLevel,\n    category,\n  };\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST 1: Type Compatibility\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ndescribe('Type Compatibility', () => {\n  test('ApprovalSource includes all three values', () => {\n    const sources: ApprovalSource[] = ['auto', 'notify', 'user'];\n    expect(sources).toHaveLength(3);\n    expect(sources).toContain('auto');\n    expect(sources).toContain('notify');\n    expect(sources).toContain('user');\n  });\n\n  test('AuditLogEntry.approvedBy accepts all ApprovalSource values', () => {\n    const entries: AuditLogEntry[] = [\n      {\n        id: '1',\n        toolName: 'test',\n        args: {},\n        approvedBy: 'auto',\n        timestamp: Date.now(),\n      },\n      {\n        id: '2',\n        toolName: 'test',\n        args: {},\n        approvedBy: 'notify',\n        timestamp: Date.now(),\n      },\n      {\n        id: '3',\n        toolName: 'test',\n        args: {},\n        approvedBy: 'user',\n        timestamp: Date.now(),\n      },\n    ];\n    expect(entries[0].approvedBy).toBe('auto');\n    expect(entries[1].approvedBy).toBe('notify');\n    expect(entries[2].approvedBy).toBe('user');\n  });\n\n  test('RiskLevel covers all three levels', () => {\n    const levels: RiskLevel[] = ['auto', 'notify', 'confirm'];\n    expect(levels).toHaveLength(3);\n  });\n});\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST 2: Safety Classification\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ndescribe('Safety Classification', () => {\n  // Lazy import to avoid issues with localStorage\n  let processToolSafety: (typeof import('../safety'))['processToolSafety'];\n\n  beforeAll(async () => {\n    const safety = await import('../safety');\n    processToolSafety = safety.processToolSafety;\n  });\n\n  test('AUTO tools return type \"auto\"', () => {\n    const tc = makeToolCall('github_read_file', { path: 'README.md' });\n    const td = makeToolDef('github_read_file', 'auto');\n    const action = processToolSafety(tc, td);\n    expect(action.type).toBe('auto');\n    expect(action.riskLevel).toBe('auto');\n  });\n\n  test('NOTIFY tools return type \"notify\" with notification', () => {\n    const tc = makeToolCall('github_push_file', {\n      path: 'src/app.ts',\n      content: '// new',\n    });\n    const td = makeToolDef('github_push_file', 'notify');\n    const action = processToolSafety(tc, td);\n    expect(action.type).toBe('notify');\n    expect(action.riskLevel).toBe('notify');\n    if (action.type === 'notify') {\n      expect(action.notification).toBeDefined();\n      expect(action.notification.toolName).toBe('github_push_file');\n      expect(action.notification.id).toBeTruthy();\n    }\n  });\n\n  test('CONFIRM tools return type \"confirm\" with approval', () => {\n    const tc = makeToolCall('github_delete_file', { path: 'important.ts' });\n    const td = makeToolDef('github_delete_file', 'confirm');\n    const action = processToolSafety(tc, td);\n    expect(action.type).toBe('confirm');\n    expect(action.riskLevel).toBe('confirm');\n    if (action.type === 'confirm') {\n      expect(action.approval).toBeDefined();\n      expect(action.approval.status).toBe('pending');\n      expect(action.approval.toolName).toBe('github_delete_file');\n    }\n  });\n\n  test('Unknown tool without definition defaults to AUTO', () => {\n    const tc = makeToolCall('unknown_tool');\n    const action = processToolSafety(tc, undefined);\n    // Without a definition, it should default to the safest assumption\n    expect(['auto', 'notify', 'confirm']).toContain(action.type);\n  });\n});\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST 3: Audit Logger\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ndescribe('Audit Logger', () => {\n  let AuditLogger: (typeof import('../audit-logger'))['AuditLogger'];\n  let logger: InstanceType<(typeof import('../audit-logger'))['AuditLogger']>;\n\n  beforeAll(async () => {\n    const mod = await import('../audit-logger');\n    AuditLogger = mod.AuditLogger;\n  });\n\n  beforeEach(() => {\n    localStorage.clear();\n    logger = new AuditLogger();\n  });\n\n  test('log() creates entry with all fields', () => {\n    const entry = logger.log({\n      toolName: 'github_push_file',\n      args: { path: 'test.ts' },\n      result: { success: true },\n      riskLevel: 'notify',\n      approvedBy: 'notify',\n    });\n\n    expect(entry.id).toBeTruthy();\n    expect(entry.toolName).toBe('github_push_file');\n    expect(entry.riskLevel).toBe('notify');\n    expect(entry.approvedBy).toBe('notify');\n    expect(entry.result?.success).toBe(true);\n    expect(entry.timestamp).toBeGreaterThan(0);\n  });\n\n  test('logStart() + finish() records duration', async () => {\n    const tracker = logger.logStart(\n      'github_read_file',\n      { path: 'x.ts' },\n      'auto'\n    );\n    // Simulate some work\n    await new Promise((r) => setTimeout(r, 50));\n    const entry = tracker.finish({ success: true }, true, 'auto');\n\n    expect(entry.duration).toBeGreaterThan(0);\n    expect(entry.approvedBy).toBe('auto');\n  });\n\n  test('logStart() + reject() records rejection', () => {\n    const tracker = logger.logStart(\n      'github_delete_file',\n      { path: 'x.ts' },\n      'confirm'\n    );\n    const entry = tracker.reject();\n\n    expect(entry.approved).toBe(false);\n    expect(entry.approvedBy).toBe('user');\n    expect(entry.result?.success).toBe(false);\n  });\n\n  test('logStart() + finish() with notify approvedBy', () => {\n    const tracker = logger.logStart(\n      'fs_create_file',\n      { name: 'new.ts' },\n      'notify',\n      'filesystem'\n    );\n    const entry = tracker.finish({ success: true }, true, 'notify');\n\n    expect(entry.approvedBy).toBe('notify');\n    expect(entry.category).toBe('filesystem');\n  });\n\n  test('filter() works with riskLevel', () => {\n    logger.log({ toolName: 'a', args: {}, riskLevel: 'auto' });\n    logger.log({ toolName: 'b', args: {}, riskLevel: 'notify' });\n    logger.log({ toolName: 'c', args: {}, riskLevel: 'confirm' });\n\n    const notifyOnly = logger.filter({ riskLevel: 'notify' });\n    expect(notifyOnly).toHaveLength(1);\n    expect(notifyOnly[0].toolName).toBe('b');\n  });\n\n  test('getStats() counts correctly', () => {\n    logger.log({\n      toolName: 'a',\n      args: {},\n      result: { success: true },\n      riskLevel: 'auto',\n      approved: true,\n    });\n    logger.log({\n      toolName: 'b',\n      args: {},\n      result: { success: true },\n      riskLevel: 'notify',\n      approved: true,\n    });\n    logger.log({\n      toolName: 'c',\n      args: {},\n      result: { success: false, error: 'rejected' },\n      riskLevel: 'confirm',\n      approved: false,\n    });\n\n    const stats = logger.getStats();\n    expect(stats.totalOperations).toBe(3);\n    expect(stats.successCount).toBe(2);\n    expect(stats.rejectedCount).toBe(1);\n    expect(stats.byRiskLevel['auto']).toBe(1);\n    expect(stats.byRiskLevel['notify']).toBe(1);\n    expect(stats.byRiskLevel['confirm']).toBe(1);\n  });\n\n  test('exportCSV() includes Approved By column', () => {\n    logger.log({ toolName: 'test', args: {}, approvedBy: 'notify' });\n    const csv = logger.exportCSV();\n    expect(csv).toContain('Approved By');\n    expect(csv).toContain('notify');\n  });\n\n  test('inferCategory recognizes fs_ prefix', () => {\n    const entry = logger.log({ toolName: 'fs_create_file', args: {} });\n    expect(entry.category).toBe('filesystem');\n  });\n});\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// TEST 4: Safety â†’ Audit Integration\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ndescribe('Safety â†’ Audit Integration', () => {\n  test('CONFIRM tool â†’ reject â†’ audit shows rejected', async () => {\n    const { processToolSafety } = await import('../safety');\n    const { AuditLogger } = await import('../audit-logger');\n\n    localStorage.clear();\n    const logger = new AuditLogger();\n\n    const tc = makeToolCall('github_delete_file', { path: 'secret.ts' });\n    const td = makeToolDef('github_delete_file', 'confirm');\n    const action = processToolSafety(tc, td);\n\n    expect(action.type).toBe('confirm');\n\n    // Simulate rejection\n    const tracker = logger.logStart(tc.name, tc.arguments, 'confirm', 'github');\n    tracker.reject();\n\n    const all = logger.getAll();\n    expect(all).toHaveLength(1);\n    expect(all[0].approved).toBe(false);\n    expect(all[0].approvedBy).toBe('user');\n    expect(all[0].riskLevel).toBe('confirm');\n  });\n\n  test('NOTIFY tool â†’ execute â†’ audit shows notify', async () => {\n    const { processToolSafety } = await import('../safety');\n    const { AuditLogger } = await import('../audit-logger');\n\n    localStorage.clear();\n    const logger = new AuditLogger();\n\n    const tc = makeToolCall('github_push_file', { path: 'new.ts' });\n    const td = makeToolDef('github_push_file', 'notify');\n    const action = processToolSafety(tc, td);\n\n    expect(action.type).toBe('notify');\n\n    const tracker = logger.logStart(tc.name, tc.arguments, 'notify', 'github');\n    tracker.finish({ success: true }, true, 'notify');\n\n    const all = logger.getAll();\n    expect(all).toHaveLength(1);\n    expect(all[0].approvedBy).toBe('notify');\n    expect(all[0].riskLevel).toBe('notify');\n    expect(all[0].result?.success).toBe(true);\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\agent-service-ooda.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'buildSystemPrompt' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 17,
        "column": 24,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 17,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'getOODABridge' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 20,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 20,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'SELF_IMPROVE_FILE_PATTERNS' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 63,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 63,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Agent Service OODA Integration (Phase 8)\n * Extends AgentService with OODABridge for self-improvement capabilities.\n *\n * This module wraps the original AgentService and adds:\n * 1. Automatic SELF-IMPROVE mode detection\n * 2. OODABridge routing for self-improvement tasks\n * 3. Groq LLM fallback when primary provider fails\n * 4. Unified event stream for UI components\n *\n * Usage:\n *   const service = new OODAAgentService(config, tools);\n *   service.initOODA({ groqApiKey: '...', modelId: '...' });\n *   const response = await service.sendMessage(messages);\n */\n\nimport { AgentService, buildSystemPrompt } from './agent-service';\nimport {\n  OODABridge,\n  getOODABridge,\n  type OODABridgeConfig,\n  type SelfImproveRequest,\n  type SelfImproveResult,\n  type BridgeEvent,\n} from './bridge';\nimport type {\n  AgentConfig,\n  AgentMessage,\n  ToolDefinition,\n  ToolCall,\n  PendingApproval,\n  ProjectContext,\n} from './types';\nimport type { ToolNotification } from './safety';\nimport { v4 as uuidv4 } from 'uuid';\n\n// â”€â”€â”€ Self-Improve Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst SELF_IMPROVE_KEYWORDS_AR = [\n  'Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©',\n  'Ù…Ø´ÙƒÙ„Ø© ÙÙŠ',\n  'Ù„Ø§ ÙŠØ¹Ù…Ù„',\n  'Ù„Ø§ ØªØ¹Ù…Ù„',\n  'Ø£ØµÙ„Ø­',\n  'Ø­Ø³Ù‘Ù†',\n  'Ø¹Ø¯Ù‘Ù„',\n  'Ø§Ù„Ø²Ø± Ù„Ø§',\n  'Ø§Ù„Ø´Ø§Ø´Ø©',\n  'Ø®Ù„Ù„',\n  'Ø¨Ø§Øº',\n  'ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡',\n  'Ø¨Ø·ÙŠØ¡',\n  'self-improve',\n  'fix the',\n  'bug in',\n  'broken',\n  \"doesn't work\",\n  'improve',\n  'Ø­Ù„Ù‘ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©',\n  'Ø£ØµÙ„Ø­ Ø§Ù„ÙƒÙˆØ¯',\n];\n\nconst SELF_IMPROVE_FILE_PATTERNS = [\n  'components/',\n  'lib/agent/',\n  'lib/stores/',\n  'app/',\n  'hooks/',\n];\n\nfunction detectSelfImproveIntent(message: string): boolean {\n  const lower = message.toLowerCase();\n  return SELF_IMPROVE_KEYWORDS_AR.some((kw) =>\n    lower.includes(kw.toLowerCase())\n  );\n}\n\nfunction extractCategory(message: string): SelfImproveRequest['category'] {\n  const lower = message.toLowerCase();\n  if (\n    lower.includes('Ø£Ø¯Ø§Ø¡') ||\n    lower.includes('Ø¨Ø·ÙŠØ¡') ||\n    lower.includes('performance')\n  )\n    return 'performance';\n  if (\n    lower.includes('ØªØµÙ…ÙŠÙ…') ||\n    lower.includes('style') ||\n    lower.includes('css')\n  )\n    return 'style';\n  if (\n    lower.includes('ÙˆØµÙˆÙ„') ||\n    lower.includes('accessibility') ||\n    lower.includes('a11y')\n  )\n    return 'accessibility';\n  if (\n    lower.includes('ÙˆØ§Ø¬Ù‡') ||\n    lower.includes('ui') ||\n    lower.includes('Ø²Ø±') ||\n    lower.includes('Ø´Ø§Ø´Ø©')\n  )\n    return 'ui_bug';\n  return 'logic_error';\n}\n\n// â”€â”€â”€ OODA-Aware Agent Service â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport type OODAMode = 'chat' | 'self-improve' | 'hybrid';\n\nexport interface OODAAgentEvent {\n  type:\n    | 'mode_change'\n    | 'ooda_start'\n    | 'ooda_complete'\n    | 'ooda_error'\n    | 'ooda_phase';\n  mode?: OODAMode;\n  data?: unknown;\n  timestamp: number;\n}\n\nexport type OODAAgentEventHandler = (event: OODAAgentEvent) => void;\n\nexport class OODAAgentService extends AgentService {\n  private bridge: OODABridge | null = null;\n  private currentMode: OODAMode = 'chat';\n  private oodaEventHandlers: Set<OODAAgentEventHandler> = new Set();\n  private autoDetect: boolean = true;\n  private lastSelfImproveResult: SelfImproveResult | null = null;\n\n  constructor(config: AgentConfig, tools: ToolDefinition[]) {\n    super(config, tools);\n  }\n\n  // â”€â”€â”€ OODA Initialization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Initialize the OODA Bridge with Groq API credentials.\n   * Call this after constructing the service, when the user\n   * provides their Groq API key in settings.\n   */\n  initOODA(config: OODABridgeConfig): void {\n    this.bridge = new OODABridge(config);\n    // Forward bridge events to our event system\n    this.bridge.onEvent((bridgeEvent: BridgeEvent) => {\n      this.emitOODA({\n        type: 'ooda_phase',\n        data: bridgeEvent,\n      });\n    });\n  }\n\n  /** Get or initialize the bridge via singleton */\n  getBridge(): OODABridge | null {\n    return this.bridge;\n  }\n\n  /** Check if OODA capabilities are available */\n  isOODAReady(): boolean {\n    return this.bridge?.isReady() ?? false;\n  }\n\n  /** Set auto-detection of self-improve intent */\n  setAutoDetect(enabled: boolean): void {\n    this.autoDetect = enabled;\n  }\n\n  /** Get the last self-improve analysis result */\n  getLastSelfImproveResult(): SelfImproveResult | null {\n    return this.lastSelfImproveResult;\n  }\n\n  // â”€â”€â”€ Mode Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  getMode(): OODAMode {\n    return this.currentMode;\n  }\n\n  setMode(mode: OODAMode): void {\n    const old = this.currentMode;\n    this.currentMode = mode;\n    if (old !== mode) {\n      this.emitOODA({ type: 'mode_change', mode });\n    }\n  }\n\n  // â”€â”€â”€ Enhanced sendMessage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Enhanced sendMessage that detects self-improve intent\n   * and routes to OODABridge when appropriate.\n   *\n   * Flow:\n   * 1. Check if message triggers SELF-IMPROVE mode\n   * 2. If yes AND bridge is ready â†’ run OODA analysis cycle\n   * 3. Format OODA results as AgentMessage\n   * 4. If no â†’ delegate to original AgentService.sendMessage()\n   */\n  async sendMessageWithOODA(\n    messages: AgentMessage[],\n    systemPrompt?: string,\n    onToolCall?: (toolCall: ToolCall) => void,\n    onApprovalRequired?: (approval: PendingApproval) => Promise<boolean>,\n    projectContext?: ProjectContext,\n    onNotify?: (notification: ToolNotification) => void\n  ): Promise<AgentMessage> {\n    const lastMessage = messages[messages.length - 1];\n    const userText = lastMessage?.content || '';\n\n    // Check for self-improve intent\n    const isSelfImprove = this.autoDetect && detectSelfImproveIntent(userText);\n\n    if (isSelfImprove && this.bridge?.isReady()) {\n      this.setMode('self-improve');\n      this.emitOODA({ type: 'ooda_start', data: { message: userText } });\n\n      try {\n        // Build a minimal self-improve request\n        // In real usage, the agent would first call self_* tools to gather files\n        const request: SelfImproveRequest = {\n          issue: userText,\n          category: extractCategory(userText),\n          fileContents: {}, // Will be populated by self_* tools in the OODA cycle\n          affectedFiles: [],\n          context: `Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙŠØ¨Ù„Øº Ø¹Ù† Ù…Ø´ÙƒÙ„Ø©: ${userText}`,\n        };\n\n        const result = await this.bridge.runAnalysisCycle(request);\n        this.lastSelfImproveResult = result;\n\n        this.emitOODA({ type: 'ooda_complete', data: result });\n\n        // Format OODA result as agent message\n        return this.formatOODAResult(result);\n      } catch (error) {\n        this.emitOODA({\n          type: 'ooda_error',\n          data: { error: (error as Error).message },\n        });\n        // Fallback to normal chat if OODA fails\n        this.setMode('chat');\n      }\n    }\n\n    // Default: use original AgentService\n    this.setMode('chat');\n    return super.sendMessage(\n      messages,\n      systemPrompt,\n      onToolCall,\n      onApprovalRequired,\n      projectContext,\n      onNotify\n    );\n  }\n\n  // â”€â”€â”€ Event System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  onOODAEvent(handler: OODAAgentEventHandler): () => void {\n    this.oodaEventHandlers.add(handler);\n    return () => this.oodaEventHandlers.delete(handler);\n  }\n\n  private emitOODA(event: Omit<OODAAgentEvent, 'timestamp'>): void {\n    const fullEvent: OODAAgentEvent = { ...event, timestamp: Date.now() };\n    this.oodaEventHandlers.forEach((h) => h(fullEvent));\n  }\n\n  // â”€â”€â”€ Format OODA Results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private formatOODAResult(result: SelfImproveResult): AgentMessage {\n    if (!result.success) {\n      return {\n        id: uuidv4(),\n        role: 'assistant',\n        content: `## âš ï¸ ØªØ¹Ø°Ù‘Ø± Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ­Ù„ÙŠÙ„\\n\\n${result.error || 'Ø®Ø·Ø£ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}\\n\\n**Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¯ÙˆØ±Ø©:** \\`${result.cycleId}\\``,\n        createdAt: Date.now(),\n      };\n    }\n\n    const sections: string[] = [];\n\n    // Header\n    sections.push(`## ğŸ”„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø°Ø§ØªÙŠ`);\n    sections.push(`**Ù…Ø¹Ø±Ù‘Ù Ø§Ù„Ø¯ÙˆØ±Ø©:** \\`${result.cycleId}\\`\\n`);\n\n    // Observe phase\n    if (result.analyses.observe) {\n      sections.push(`### ğŸ‘ï¸ Ø§Ù„Ø±ØµØ¯ (Observe)`);\n      sections.push(result.analyses.observe.analysis);\n    }\n\n    // Orient phase\n    if (result.analyses.orient) {\n      sections.push(`\\n### ğŸ§­ Ø§Ù„ØªØ­Ù„ÙŠÙ„ (Orient)`);\n      sections.push(result.analyses.orient.analysis);\n      if (result.analyses.orient.suggestions.length > 0) {\n        sections.push(`\\n**Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª:**`);\n        result.analyses.orient.suggestions.forEach((s, i) => {\n          sections.push(`${i + 1}. ${s}`);\n        });\n      }\n    }\n\n    // Decide phase\n    if (result.analyses.decide) {\n      sections.push(`\\n### ğŸ“‹ Ø§Ù„Ù‚Ø±Ø§Ø± (Decide)`);\n      sections.push(result.analyses.decide.analysis);\n    }\n\n    // Proposed fixes\n    if (result.proposedFixes.length > 0) {\n      sections.push(`\\n### âš¡ Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§Øª Ø§Ù„Ù…Ù‚ØªØ±Ø­Ø©`);\n      result.proposedFixes.forEach((fix, i) => {\n        sections.push(`\\n**${i + 1}. \\`${fix.filePath}\\`** (${fix.type})`);\n        sections.push(fix.explanation);\n        if (fix.type === 'edit' && fix.oldStr && fix.newStr) {\n          sections.push(`\\`\\`\\`diff\\n- ${fix.oldStr}\\n+ ${fix.newStr}\\n\\`\\`\\``);\n        }\n      });\n      sections.push(\n        `\\n> Ù‡Ù„ ØªØ±ÙŠØ¯Ù†ÙŠ Ø£Ù† Ø£Ù†ÙØ° Ù‡Ø°Ù‡ Ø§Ù„Ø¥ØµÙ„Ø§Ø­Ø§ØªØŸ Ø§ÙƒØªØ¨ **\"Ù†ÙÙ‘Ø°\"** Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©.`\n      );\n    }\n\n    // Token usage\n    sections.push(\n      `\\n---\\n*ğŸª™ Ø§Ù„Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ: ${result.tokenUsage.totalTokens.toLocaleString()} tokens*`\n    );\n\n    return {\n      id: uuidv4(),\n      role: 'assistant',\n      content: sections.join('\\n'),\n      createdAt: Date.now(),\n    };\n  }\n\n  // â”€â”€â”€ Cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  dispose(): void {\n    this.bridge?.dispose();\n    this.oodaEventHandlers.clear();\n  }\n}\n\n// â”€â”€â”€ Factory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport function createOODAAgentService(\n  config: AgentConfig,\n  tools: ToolDefinition[],\n  oodaConfig?: OODABridgeConfig\n): OODAAgentService {\n  const service = new OODAAgentService(config, tools);\n  if (oodaConfig) {\n    service.initOODA(oodaConfig);\n  }\n  return service;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\agent-service.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'RiskLevel' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 34,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 34,
        "endColumn": 12
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Agent Service (Core Engine) v2.4\n * Orchestrates the AI agent: sends messages, handles tool calls,\n * manages the conversation loop, and enforces safety rules.\n *\n * v2.4 â€” Full OODA Loop Integration:\n *   - Added SECTION 2F: OODA Loop Tools (5 tools)\n *   - Enhanced SECTION 10: Self-Improvement with active OODA protocol\n *   - Updated tool count: 48 â†’ 53 (5 OODA tools)\n *   - All previous safety and tool handling unchanged\n *\n * v2.3 â€” Self-Improvement Protocol:\n *   - Added SECTION 10: Self-Improvement OODA Loop\n *   - Added SECTION 2E: Self-Improvement Tools\n *   - Updated tool count: 45 â†’ 48 (3 self-improve tools)\n *\n * v2.2 â€” Triple-layer safety integration:\n *   - Uses processToolSafety() from safety/index.ts\n *   - Added onNotify callback for NOTIFY-level tools\n *   - CONFIRM tools await onApprovalRequired() (unchanged API)\n *   - AUTO tools execute silently (unchanged)\n *   - Backward compatible: onNotify is optional\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport type {\n  AgentConfig,\n  AgentMessage,\n  ToolDefinition,\n  ToolCall,\n  ToolCallResult,\n  PendingApproval,\n  AuditLogEntry,\n  RiskLevel,\n  ProjectContext,\n} from './types';\nimport { MAX_TOOL_ITERATIONS } from './constants';\nimport { getAuditLogger, type AuditLogger } from './audit-logger';\nimport { processToolSafety, type ToolNotification } from './safety';\n\n// â”€â”€â”€ System Prompt (extracted to system-prompt.ts) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Ù…Ø³ØªØ®Ø±Ø¬ ÙÙŠ Ù…Ù„Ù Ù…Ø³ØªÙ‚Ù„ Ù„ØªØ­Ø³ÙŠÙ† Ù‚Ø§Ø¨Ù„ÙŠØ© Ø§Ù„ØµÙŠØ§Ù†Ø© (1152 Ø³Ø·Ø± â†’ Ù…Ù„Ù Ø®Ø§Ø±Ø¬ÙŠ)\nexport {\n  SYSTEM_PROMPT_TEMPLATE,\n  buildSystemPrompt,\n  DEFAULT_SYSTEM_PROMPT,\n} from './system-prompt';\n\n// â”€â”€â”€ Provider Callers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ninterface ProviderResponse {\n  content?: string;\n  toolCalls?: ToolCall[];\n}\n\nfunction parseToolCalls(\n  rawToolCalls: Array<{\n    id?: string;\n    function?: { name: string; arguments: string };\n    name?: string;\n    arguments?: Record<string, unknown>;\n  }>\n): ToolCall[] {\n  return rawToolCalls.map((tc) => {\n    if (tc.function) {\n      let parsedArgs: Record<string, unknown> = {};\n      try {\n        parsedArgs = JSON.parse(tc.function.arguments || '{}');\n      } catch {\n        parsedArgs = {};\n      }\n      return {\n        id: tc.id || uuidv4(),\n        name: tc.function.name,\n        arguments: parsedArgs,\n      };\n    }\n    return {\n      id: tc.id || uuidv4(),\n      name: tc.name || '',\n      arguments: tc.arguments || {},\n    };\n  });\n}\n\nasync function callProvider(\n  config: AgentConfig,\n  messages: Array<{ role: string; content: string }>,\n  tools: ToolDefinition[]\n): Promise<ProviderResponse> {\n  const { provider, apiKey, model, temperature, maxTokens } = config;\n\n  const formattedTools = tools.map((t) => ({\n    type: 'function' as const,\n    function: {\n      name: t.name,\n      description: t.description,\n      parameters: t.parameters,\n    },\n  }));\n\n  // â”€â”€ OpenAI â”€â”€\n  if (provider === 'openai') {\n    const res = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${apiKey}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model,\n        messages,\n        tools: formattedTools,\n        tool_choice: 'auto',\n        temperature,\n        max_tokens: maxTokens,\n      }),\n    });\n    if (!res.ok) {\n      const err = await res\n        .json()\n        .catch(() => ({ error: { message: `HTTP ${res.status}` } }));\n      throw new Error(err.error?.message || `OpenAI error: ${res.status}`);\n    }\n    const data = await res.json();\n    const choice = data.choices?.[0]?.message;\n    return {\n      content: choice?.content || undefined,\n      toolCalls: choice?.tool_calls\n        ? parseToolCalls(choice.tool_calls)\n        : undefined,\n    };\n  }\n\n  // â”€â”€ Groq â”€â”€\n  if (provider === 'groq') {\n    const res = await fetch('https://api.groq.com/openai/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        Authorization: `Bearer ${apiKey}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model,\n        messages,\n        tools: formattedTools,\n        tool_choice: 'auto',\n        temperature,\n        max_tokens: maxTokens,\n      }),\n    });\n    if (!res.ok) {\n      const err = await res\n        .json()\n        .catch(() => ({ error: { message: `HTTP ${res.status}` } }));\n      throw new Error(err.error?.message || `Groq error: ${res.status}`);\n    }\n    const data = await res.json();\n    const choice = data.choices?.[0]?.message;\n    return {\n      content: choice?.content || undefined,\n      toolCalls: choice?.tool_calls\n        ? parseToolCalls(choice.tool_calls)\n        : undefined,\n    };\n  }\n\n  // â”€â”€ Google Gemini â”€â”€\n  if (provider === 'google') {\n    const res = await fetch(\n      `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          contents: messages\n            .filter((m) => m.role !== 'system')\n            .map((m) => ({\n              role: m.role === 'assistant' ? 'model' : 'user',\n              parts: [{ text: m.content }],\n            })),\n          systemInstruction: {\n            parts: [\n              {\n                text:\n                  messages.find((m) => m.role === 'system')?.content ||\n                  SYSTEM_PROMPT_TEMPLATE,\n              },\n            ],\n          },\n          tools: [\n            {\n              functionDeclarations: tools.map((t) => ({\n                name: t.name,\n                description: t.description,\n                parameters: t.parameters,\n              })),\n            },\n          ],\n          generationConfig: { temperature, maxOutputTokens: maxTokens },\n        }),\n      }\n    );\n    if (!res.ok) {\n      const err = await res\n        .json()\n        .catch(() => ({ error: { message: `HTTP ${res.status}` } }));\n      throw new Error(err.error?.message || `Gemini error: ${res.status}`);\n    }\n    const data = await res.json();\n    const parts = data.candidates?.[0]?.content?.parts || [];\n    const textPart = parts.find((p: Record<string, unknown>) => p.text);\n    const fnParts = parts.filter(\n      (p: Record<string, unknown>) => p.functionCall\n    );\n    return {\n      content: (textPart?.text as string) || undefined,\n      toolCalls:\n        fnParts.length > 0\n          ? fnParts.map((p: Record<string, unknown>) => {\n              const fc = p.functionCall as {\n                name: string;\n                args?: Record<string, unknown>;\n              };\n              return {\n                id: uuidv4(),\n                name: fc.name,\n                arguments: fc.args || {},\n              };\n            })\n          : undefined,\n    };\n  }\n\n  // â”€â”€ Anthropic â”€â”€\n  if (provider === 'anthropic') {\n    const systemMsg = messages.find((m) => m.role === 'system')?.content;\n    const nonSystemMsgs = messages.filter((m) => m.role !== 'system');\n    const res = await fetch('https://api.anthropic.com/v1/messages', {\n      method: 'POST',\n      headers: {\n        'x-api-key': apiKey,\n        'anthropic-version': '2023-06-01',\n        'anthropic-dangerous-direct-browser-access': 'true',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model,\n        max_tokens: maxTokens || 4096,\n        system: systemMsg,\n        messages: nonSystemMsgs,\n        tools: tools.map((t) => ({\n          name: t.name,\n          description: t.description,\n          input_schema: t.parameters,\n        })),\n      }),\n    });\n    if (!res.ok) {\n      const err = await res\n        .json()\n        .catch(() => ({ error: { message: `HTTP ${res.status}` } }));\n      throw new Error(err.error?.message || `Anthropic error: ${res.status}`);\n    }\n    const data = await res.json();\n    const textBlock = data.content?.find(\n      (b: Record<string, unknown>) => b.type === 'text'\n    );\n    const toolBlocks =\n      data.content?.filter(\n        (b: Record<string, unknown>) => b.type === 'tool_use'\n      ) || [];\n    return {\n      content: (textBlock?.text as string) || undefined,\n      toolCalls:\n        toolBlocks.length > 0\n          ? toolBlocks.map((b: Record<string, unknown>) => ({\n              id: b.id as string,\n              name: b.name as string,\n              arguments: (b.input as Record<string, unknown>) || {},\n            }))\n          : undefined,\n    };\n  }\n\n  throw new Error(`Unknown provider: ${provider}`);\n}\n\n// â”€â”€â”€ Agent Service â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport class AgentService {\n  private config: AgentConfig;\n  private tools: ToolDefinition[];\n  private auditLogger: AuditLogger;\n  private toolExecutors: Map<\n    string,\n    (args: Record<string, unknown>) => Promise<ToolCallResult>\n  > = new Map();\n\n  /** Anti-loop tracking: counts consecutive calls to the same tool */\n  private toolCallTracker: Map<string, number> = new Map();\n  private static readonly MAX_SAME_TOOL_CALLS = 3;\n\n  constructor(config: AgentConfig, tools: ToolDefinition[]) {\n    this.config = config;\n    this.tools = tools;\n    this.auditLogger = getAuditLogger();\n  }\n\n  /** Update configuration */\n  updateConfig(config: AgentConfig): void {\n    this.config = config;\n  }\n\n  /** Get audit log entries (from persistent storage) */\n  getAuditLog(): AuditLogEntry[] {\n    return this.auditLogger.getAll();\n  }\n\n  /** Get the audit logger instance for advanced operations */\n  getAuditLoggerInstance(): AuditLogger {\n    return this.auditLogger;\n  }\n\n  /** Register a tool executor function */\n  registerToolExecutor(\n    toolName: string,\n    executor: (args: Record<string, unknown>) => Promise<ToolCallResult>\n  ): void {\n    this.toolExecutors.set(toolName, executor);\n  }\n\n  /** Reset anti-loop tracker (call at start of new user message) */\n  private resetToolTracker(): void {\n    this.toolCallTracker.clear();\n  }\n\n  /**\n   * Check if a tool call should be blocked by anti-loop protection.\n   * Returns true if the tool has been called too many times consecutively.\n   */\n  private isToolLooping(\n    toolName: string,\n    args: Record<string, unknown>\n  ): boolean {\n    const key = `${toolName}:${JSON.stringify(args)}`;\n    const count = (this.toolCallTracker.get(key) || 0) + 1;\n    this.toolCallTracker.set(key, count);\n    return count > AgentService.MAX_SAME_TOOL_CALLS;\n  }\n\n  /**\n   * Send a message and get a response (with tool calling loop).\n   *\n   * v2.2 â€” Triple-layer safety:\n   *   - onToolCall: callback when any tool is invoked (for UI status)\n   *   - onNotify: callback for NOTIFY-level tools (shows notification, doesn't block)\n   *   - onApprovalRequired: callback for CONFIRM-level tools (blocks until user decides)\n   *\n   * onNotify is optional for backward compatibility.\n   */\n  async sendMessage(\n    messages: AgentMessage[],\n    systemPrompt?: string,\n    onToolCall?: (toolCall: ToolCall) => void,\n    onApprovalRequired?: (approval: PendingApproval) => Promise<boolean>,\n    projectContext?: ProjectContext,\n    onNotify?: (notification: ToolNotification) => void\n  ): Promise<AgentMessage> {\n    // Reset anti-loop tracker for each new user message\n    this.resetToolTracker();\n\n    // Build the full system prompt with injected runtime variables\n    const resolvedPrompt =\n      systemPrompt || buildSystemPrompt(this.config, projectContext);\n\n    const apiMessages: Array<{ role: string; content: string }> = [\n      { role: 'system', content: resolvedPrompt },\n      ...messages.map((m) => ({ role: m.role, content: m.content || '' })),\n    ];\n\n    let iterations = 0;\n    const maxIterations = MAX_TOOL_ITERATIONS || 10;\n\n    while (iterations < maxIterations) {\n      iterations++;\n\n      const response = await callProvider(this.config, apiMessages, this.tools);\n\n      // If no tool calls, return the text response\n      if (!response.toolCalls || response.toolCalls.length === 0) {\n        return {\n          id: uuidv4(),\n          role: 'assistant',\n          content: response.content || 'Ù„Ù… Ø£ØªÙ…ÙƒÙ† Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ Ø±Ø¯.',\n          createdAt: Date.now(),\n        };\n      }\n\n      // Process each tool call\n      for (const toolCall of response.toolCalls) {\n        onToolCall?.(toolCall);\n\n        const toolDef = this.tools.find((t) => t.name === toolCall.name);\n        const category = toolDef?.category || 'utility';\n\n        // â”€â”€ Anti-loop check â”€â”€\n        if (this.isToolLooping(toolCall.name, toolCall.arguments)) {\n          const loopMsg = `âš ï¸ ØªÙ… Ø§ÙƒØªØ´Ø§Ù ØªÙƒØ±Ø§Ø±: Ø§Ù„Ø£Ø¯Ø§Ø© \"${toolCall.name}\" Ø§Ø³ØªÙØ¯Ø¹ÙŠØª Ø£ÙƒØ«Ø± Ù…Ù† ${AgentService.MAX_SAME_TOOL_CALLS} Ù…Ø±Ø§Øª Ø¨Ù†ÙØ³ Ø§Ù„Ù…Ø¹Ø§Ù…Ù„Ø§Øª. Ø£ØªÙˆÙ‚Ù ÙˆØ£Ø·Ù„Ø¨ ØªÙˆØ¬ÙŠÙ‡Ø§ØªÙƒ.`;\n          apiMessages.push({ role: 'assistant', content: loopMsg });\n          apiMessages.push({\n            role: 'user',\n            content:\n              'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØªÙƒØ±Ø§Ø± Ø¨ÙˆØ§Ø³Ø·Ø© Ù†Ø¸Ø§Ù… Ø§Ù„Ø­Ù…Ø§ÙŠØ©. Ø£Ø¹Ø¯ ØµÙŠØ§ØºØ© Ø§Ù„Ù…Ù‡Ù…Ø© Ø£Ùˆ Ø¬Ø±Ø¨ Ù†Ù‡Ø¬Ø§Ù‹ Ù…Ø®ØªÙ„ÙØ§Ù‹.',\n          });\n          continue;\n        }\n\n        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n        // TRIPLE-LAYER SAFETY â€” processToolSafety() decides\n        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n        const safetyAction = processToolSafety(toolCall, toolDef);\n\n        // â”€â”€ Start audit tracking (captures duration) â”€â”€\n        const auditTracker = this.auditLogger.logStart(\n          toolCall.name,\n          toolCall.arguments,\n          safetyAction.riskLevel,\n          category\n        );\n\n        // â”€â”€ CONFIRM: Block and wait for user approval â”€â”€\n        if (safetyAction.type === 'confirm' && onApprovalRequired) {\n          const approved = await onApprovalRequired(safetyAction.approval);\n\n          if (!approved) {\n            // Log the rejection with duration\n            auditTracker.reject();\n\n            apiMessages.push({\n              role: 'assistant',\n              content: `Ø£Ø±Ø¯Øª ØªÙ†ÙÙŠØ° Ø¹Ù…Ù„ÙŠØ© Ø­Ø³Ø§Ø³Ø© (${toolCall.name}) Ù„ÙƒÙ† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø±ÙØ¶.`,\n            });\n            apiMessages.push({\n              role: 'user',\n              content: `ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©: ${toolCall.name}. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ø¯ÙˆÙ†Ù‡Ø§.`,\n            });\n            continue;\n          }\n        }\n\n        // â”€â”€ NOTIFY: Show notification (non-blocking) then execute â”€â”€\n        if (safetyAction.type === 'notify' && onNotify) {\n          onNotify(safetyAction.notification);\n        }\n\n        // â”€â”€ Execute the tool (AUTO, NOTIFY after notification, CONFIRM after approval) â”€â”€\n        const executor = this.toolExecutors.get(toolCall.name);\n        let result: ToolCallResult;\n\n        if (executor) {\n          try {\n            result = await executor(toolCall.arguments);\n          } catch (error) {\n            result = { success: false, error: (error as Error).message };\n          }\n        } else {\n          result = {\n            success: false,\n            error: `Tool '${toolCall.name}' not registered`,\n          };\n        }\n\n        // â”€â”€ Log the result with duration â”€â”€\n        const approvedBy: 'auto' | 'user' | 'notify' =\n          safetyAction.type === 'confirm'\n            ? 'user'\n            : safetyAction.type === 'notify'\n              ? 'notify'\n              : 'auto';\n        auditTracker.finish(result, true, approvedBy);\n\n        // Add tool result to conversation\n        apiMessages.push({\n          role: 'assistant',\n          content: response.content || `[Calling tool: ${toolCall.name}]`,\n        });\n        apiMessages.push({\n          role: 'user',\n          content: `Tool ${toolCall.name} result: ${JSON.stringify(result)}`,\n        });\n      }\n    }\n\n    return {\n      id: uuidv4(),\n      role: 'assistant',\n      content: 'âš ï¸ ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ø¯ÙˆØ±Ø§Øª. Ù‡Ù„ ØªØ±ÙŠØ¯Ù†ÙŠ Ø£Ù† Ø£ÙƒÙ…Ù„ Ø¨Ù†Ù‡Ø¬ Ù…Ø®ØªÙ„ÙØŸ',\n      createdAt: Date.now(),\n    };\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\audit-logger.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 440,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 440,
        "endColumn": 11
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Audit Logger v2.1\n * Persistent audit logging system for all agent operations.\n * Stores entries in localStorage with auto-cleanup, filtering,\n * statistics, and export capabilities.\n *\n * v2.1 â€” approvedBy now supports 'notify' in addition to 'auto' | 'user'\n *         inferCategory now recognizes fs_* prefix\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport type {\n  AuditLogEntry,\n  ToolCallResult,\n  RiskLevel,\n  ApprovalSource,\n} from './types';\n\nconst STORAGE_KEY = 'codeforge-audit-log';\nconst MAX_ENTRIES = 500;\nconst AUTO_CLEANUP_DAYS = 30;\n\n// â”€â”€â”€ Enhanced Audit Entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface AuditLogEntryEnhanced extends AuditLogEntry {\n  /** Duration of tool execution in ms */\n  duration?: number;\n  /** Session ID for grouping operations */\n  sessionId?: string;\n  /** Human-readable summary */\n  summary?: string;\n  /** Category of the tool */\n  category?: string;\n}\n\nexport interface AuditLogStats {\n  totalOperations: number;\n  successCount: number;\n  failureCount: number;\n  rejectedCount: number;\n  byTool: Record<string, number>;\n  byCategory: Record<string, number>;\n  byRiskLevel: Record<string, number>;\n  averageDuration: number;\n  oldestEntry: number | null;\n  newestEntry: number | null;\n}\n\nexport interface AuditLogFilter {\n  toolName?: string;\n  category?: string;\n  riskLevel?: RiskLevel;\n  success?: boolean;\n  approved?: boolean;\n  dateFrom?: number;\n  dateTo?: number;\n  searchQuery?: string;\n  sessionId?: string;\n}\n\n// â”€â”€â”€ Audit Logger Class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport class AuditLogger {\n  private entries: AuditLogEntryEnhanced[] = [];\n  private currentSessionId: string;\n  private listeners: Set<() => void> = new Set();\n\n  constructor() {\n    this.currentSessionId = uuidv4().slice(0, 8);\n    this.loadFromStorage();\n    this.autoCleanup();\n  }\n\n  // â”€â”€ Core Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Log a tool execution with full details\n   */\n  log(entry: {\n    toolName: string;\n    args: Record<string, unknown>;\n    result?: ToolCallResult;\n    riskLevel?: RiskLevel;\n    approved?: boolean;\n    approvedBy?: ApprovalSource;\n    duration?: number;\n    category?: string;\n  }): AuditLogEntryEnhanced {\n    const fullEntry: AuditLogEntryEnhanced = {\n      id: uuidv4(),\n      toolName: entry.toolName,\n      args: this.sanitizeArgs(entry.args),\n      result: entry.result,\n      riskLevel: entry.riskLevel || 'auto',\n      approved: entry.approved ?? true,\n      approvedBy: entry.approvedBy || 'auto',\n      duration: entry.duration,\n      sessionId: this.currentSessionId,\n      category: entry.category || this.inferCategory(entry.toolName),\n      summary: this.generateSummary(entry.toolName, entry.args, entry.result),\n      timestamp: Date.now(),\n    };\n\n    this.entries.push(fullEntry);\n\n    // Trim if over limit\n    if (this.entries.length > MAX_ENTRIES) {\n      this.entries = this.entries.slice(-MAX_ENTRIES);\n    }\n\n    this.saveToStorage();\n    this.notifyListeners();\n\n    return fullEntry;\n  }\n\n  /**\n   * Log the start of a tool execution (returns a finish function)\n   */\n  logStart(\n    toolName: string,\n    args: Record<string, unknown>,\n    riskLevel?: RiskLevel,\n    category?: string\n  ): {\n    finish: (\n      result: ToolCallResult,\n      approved?: boolean,\n      approvedBy?: ApprovalSource\n    ) => AuditLogEntryEnhanced;\n    reject: () => AuditLogEntryEnhanced;\n  } {\n    const startTime = Date.now();\n\n    return {\n      finish: (result, approved = true, approvedBy = 'auto') => {\n        return this.log({\n          toolName,\n          args,\n          result,\n          riskLevel,\n          approved,\n          approvedBy,\n          duration: Date.now() - startTime,\n          category,\n        });\n      },\n      reject: () => {\n        return this.log({\n          toolName,\n          args,\n          result: { success: false, error: 'Rejected by user' },\n          riskLevel,\n          approved: false,\n          approvedBy: 'user',\n          duration: Date.now() - startTime,\n          category,\n        });\n      },\n    };\n  }\n\n  // â”€â”€ Query & Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Get all entries (newest first)\n   */\n  getAll(): AuditLogEntryEnhanced[] {\n    return [...this.entries].reverse();\n  }\n\n  /**\n   * Get entries with filters\n   */\n  filter(filters: AuditLogFilter): AuditLogEntryEnhanced[] {\n    let result = [...this.entries];\n\n    if (filters.toolName) {\n      result = result.filter((e) => e.toolName === filters.toolName);\n    }\n    if (filters.category) {\n      result = result.filter((e) => e.category === filters.category);\n    }\n    if (filters.riskLevel) {\n      result = result.filter((e) => e.riskLevel === filters.riskLevel);\n    }\n    if (filters.success !== undefined) {\n      result = result.filter((e) => e.result?.success === filters.success);\n    }\n    if (filters.approved !== undefined) {\n      result = result.filter((e) => e.approved === filters.approved);\n    }\n    if (filters.dateFrom) {\n      result = result.filter((e) => e.timestamp >= filters.dateFrom!);\n    }\n    if (filters.dateTo) {\n      result = result.filter((e) => e.timestamp <= filters.dateTo!);\n    }\n    if (filters.searchQuery) {\n      const q = filters.searchQuery.toLowerCase();\n      result = result.filter(\n        (e) =>\n          e.toolName.toLowerCase().includes(q) ||\n          e.summary?.toLowerCase().includes(q) ||\n          JSON.stringify(e.args).toLowerCase().includes(q)\n      );\n    }\n    if (filters.sessionId) {\n      result = result.filter((e) => e.sessionId === filters.sessionId);\n    }\n\n    return result.reverse();\n  }\n\n  /**\n   * Get recent entries\n   */\n  getRecent(count: number = 20): AuditLogEntryEnhanced[] {\n    return this.entries.slice(-count).reverse();\n  }\n\n  // â”€â”€ Statistics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Get comprehensive statistics\n   */\n  getStats(): AuditLogStats {\n    const stats: AuditLogStats = {\n      totalOperations: this.entries.length,\n      successCount: 0,\n      failureCount: 0,\n      rejectedCount: 0,\n      byTool: {},\n      byCategory: {},\n      byRiskLevel: {},\n      averageDuration: 0,\n      oldestEntry: this.entries.length > 0 ? this.entries[0].timestamp : null,\n      newestEntry:\n        this.entries.length > 0\n          ? this.entries[this.entries.length - 1].timestamp\n          : null,\n    };\n\n    let totalDuration = 0;\n    let durationCount = 0;\n\n    for (const entry of this.entries) {\n      // Success / Failure / Rejected\n      if (!entry.approved) {\n        stats.rejectedCount++;\n      } else if (entry.result?.success) {\n        stats.successCount++;\n      } else {\n        stats.failureCount++;\n      }\n\n      // By tool\n      stats.byTool[entry.toolName] = (stats.byTool[entry.toolName] || 0) + 1;\n\n      // By category\n      const cat = entry.category || 'unknown';\n      stats.byCategory[cat] = (stats.byCategory[cat] || 0) + 1;\n\n      // By risk level\n      const risk = entry.riskLevel || 'auto';\n      stats.byRiskLevel[risk] = (stats.byRiskLevel[risk] || 0) + 1;\n\n      // Duration\n      if (entry.duration) {\n        totalDuration += entry.duration;\n        durationCount++;\n      }\n    }\n\n    stats.averageDuration =\n      durationCount > 0 ? Math.round(totalDuration / durationCount) : 0;\n\n    return stats;\n  }\n\n  // â”€â”€ Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Export audit log as JSON\n   */\n  exportJSON(): string {\n    return JSON.stringify(\n      {\n        exportedAt: new Date().toISOString(),\n        totalEntries: this.entries.length,\n        stats: this.getStats(),\n        entries: this.entries,\n      },\n      null,\n      2\n    );\n  }\n\n  /**\n   * Export audit log as CSV\n   */\n  exportCSV(): string {\n    const headers = [\n      'ID',\n      'Timestamp',\n      'Tool',\n      'Category',\n      'Risk Level',\n      'Approved',\n      'Approved By',\n      'Success',\n      'Duration (ms)',\n      'Summary',\n      'Error',\n    ];\n    const rows = this.entries.map((e) => [\n      e.id,\n      new Date(e.timestamp).toISOString(),\n      e.toolName,\n      e.category || '',\n      e.riskLevel || '',\n      e.approved ? 'Yes' : 'No',\n      e.approvedBy || 'auto',\n      e.result?.success ? 'Yes' : e.result ? 'No' : 'N/A',\n      e.duration?.toString() || '',\n      (e.summary || '').replace(/,/g, ';'),\n      (e.result?.error || '').replace(/,/g, ';'),\n    ]);\n\n    return [headers.join(','), ...rows.map((r) => r.join(','))].join('\\n');\n  }\n\n  /**\n   * Download export as file\n   */\n  downloadExport(format: 'json' | 'csv'): void {\n    const content = format === 'json' ? this.exportJSON() : this.exportCSV();\n    const mimeType = format === 'json' ? 'application/json' : 'text/csv';\n    const filename = `codeforge-audit-log-${new Date().toISOString().slice(0, 10)}.${format}`;\n\n    const blob = new Blob([content], { type: mimeType });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    a.click();\n    URL.revokeObjectURL(url);\n  }\n\n  // â”€â”€ Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Clear all entries\n   */\n  clear(): void {\n    this.entries = [];\n    this.saveToStorage();\n    this.notifyListeners();\n  }\n\n  /**\n   * Delete entries older than specified days\n   */\n  cleanupOlderThan(days: number): number {\n    const cutoff = Date.now() - days * 24 * 60 * 60 * 1000;\n    const before = this.entries.length;\n    this.entries = this.entries.filter((e) => e.timestamp >= cutoff);\n    const removed = before - this.entries.length;\n    if (removed > 0) {\n      this.saveToStorage();\n      this.notifyListeners();\n    }\n    return removed;\n  }\n\n  /**\n   * Subscribe to changes\n   */\n  subscribe(listener: () => void): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  /**\n   * Get current session ID\n   */\n  getSessionId(): string {\n    return this.currentSessionId;\n  }\n\n  /**\n   * Start a new session\n   */\n  newSession(): string {\n    this.currentSessionId = uuidv4().slice(0, 8);\n    return this.currentSessionId;\n  }\n\n  // â”€â”€ Private Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private sanitizeArgs(args: Record<string, unknown>): Record<string, unknown> {\n    const sanitized = { ...args };\n    // Truncate very long content fields\n    for (const key of Object.keys(sanitized)) {\n      if (\n        typeof sanitized[key] === 'string' &&\n        (sanitized[key] as string).length > 500\n      ) {\n        sanitized[key] =\n          (sanitized[key] as string).slice(0, 500) + '... [truncated]';\n      }\n    }\n    return sanitized;\n  }\n\n  private inferCategory(toolName: string): string {\n    if (toolName.startsWith('github_')) return 'github';\n    if (toolName.startsWith('git_')) return 'git';\n    if (toolName.startsWith('fs_')) return 'filesystem';\n    if (\n      [\n        'read_file',\n        'write_file',\n        'create_file',\n        'delete_file',\n        'list_dir',\n        'search_files',\n        'move_file',\n        'copy_file',\n        'file_info',\n      ].includes(toolName)\n    )\n      return 'filesystem';\n    return 'utility';\n  }\n\n  private generateSummary(\n    toolName: string,\n    args: Record<string, unknown>,\n    result?: ToolCallResult\n  ): string {\n    const summaryMap: Record<string, () => string> = {\n      // GitHub tools\n      github_create_repo: () =>\n        `\\u0625\\u0646\\u0634\\u0627\\u0621 \\u0645\\u0633\\u062a\\u0648\\u062f\\u0639: ${args.name}`,\n      github_delete_repo: () =>\n        `\\u062d\\u0630\\u0641 \\u0645\\u0633\\u062a\\u0648\\u062f\\u0639: ${args.owner}/${args.repo}`,\n      github_push_file: () =>\n        `\\u062f\\u0641\\u0639 \\u0645\\u0644\\u0641: ${args.path} \\u2192 ${args.owner}/${args.repo}`,\n      github_push_files: () =>\n        `\\u062f\\u0641\\u0639 ${(args.files as unknown[])?.length || '?'} \\u0645\\u0644\\u0641\\u0627\\u062a \\u2192 ${args.owner}/${args.repo}`,\n      github_read_file: () =>\n        `\\u0642\\u0631\\u0627\\u0621\\u0629 \\u0645\\u0644\\u0641: ${args.path} \\u0645\\u0646 ${args.owner}/${args.repo}`,\n      github_edit_file: () =>\n        `\\u062a\\u0639\\u062f\\u064a\\u0644 \\u0645\\u0644\\u0641: ${args.path} \\u0641\\u064a ${args.owner}/${args.repo}`,\n      github_delete_file: () =>\n        `\\u062d\\u0630\\u0641 \\u0645\\u0644\\u0641: ${args.path} \\u0645\\u0646 ${args.owner}/${args.repo}`,\n      github_list_files: () =>\n        `\\u0639\\u0631\\u0636 \\u0645\\u0644\\u0641\\u0627\\u062a: ${args.path || '/'} \\u0641\\u064a ${args.owner}/${args.repo}`,\n      github_create_branch: () =>\n        `\\u0625\\u0646\\u0634\\u0627\\u0621 \\u0641\\u0631\\u0639: ${args.branch} \\u0645\\u0646 ${args.fromBranch || 'main'}`,\n      github_delete_branch: () =>\n        `\\u062d\\u0630\\u0641 \\u0641\\u0631\\u0639: ${args.branch}`,\n      github_create_pull_request: () =>\n        `\\u0625\\u0646\\u0634\\u0627\\u0621 PR: ${args.title}`,\n      github_merge_pull_request: () =>\n        `\\u062f\\u0645\\u062c PR #${args.pullNumber} (${args.mergeMethod || 'merge'})`,\n      github_create_issue: () =>\n        `\\u0625\\u0646\\u0634\\u0627\\u0621 Issue: ${args.title}`,\n      github_update_issue: () =>\n        `\\u062a\\u062d\\u062f\\u064a\\u062b Issue #${args.issueNumber}`,\n      github_list_issues: () =>\n        `\\u0639\\u0631\\u0636 Issues: ${args.owner}/${args.repo}`,\n      github_add_comment: () =>\n        `\\u062a\\u0639\\u0644\\u064a\\u0642 \\u0639\\u0644\\u0649 #${args.issueNumber}`,\n      github_search_code: () =>\n        `\\u0628\\u062d\\u062b \\u0641\\u064a \\u0627\\u0644\\u0643\\u0648\\u062f: ${args.query}`,\n      github_search_repos: () => `\\u0628\\u062d\\u062b: ${args.query}`,\n      github_get_user_info: () =>\n        `\\u0627\\u0633\\u062a\\u0639\\u0644\\u0627\\u0645 \\u0639\\u0646 \\u0645\\u0639\\u0644\\u0648\\u0645\\u0627\\u062a \\u0627\\u0644\\u0645\\u0633\\u062a\\u062e\\u062f\\u0645`,\n      github_get_repo_info: () =>\n        `\\u0645\\u0639\\u0644\\u0648\\u0645\\u0627\\u062a: ${args.owner}/${args.repo}`,\n      github_get_commit_history: () =>\n        `\\u0633\\u062c\\u0644 \\u0627\\u0644\\u062d\\u0641\\u0638: ${args.owner}/${args.repo}`,\n      github_get_pull_request: () =>\n        `\\u062a\\u0641\\u0627\\u0635\\u064a\\u0644 PR #${args.pullNumber}`,\n      github_list_repos: () =>\n        `\\u0639\\u0631\\u0636 \\u0627\\u0644\\u0645\\u0633\\u062a\\u0648\\u062f\\u0639\\u0627\\u062a`,\n      github_list_branches: () =>\n        `\\u0639\\u0631\\u0636 \\u0627\\u0644\\u0641\\u0631\\u0648\\u0639: ${args.owner}/${args.repo}`,\n      github_list_pull_requests: () =>\n        `\\u0639\\u0631\\u0636 PRs: ${args.owner}/${args.repo}`,\n\n      // FS tools\n      fs_list_files: () =>\n        `\\u0639\\u0631\\u0636 \\u0645\\u0644\\u0641\\u0627\\u062a \\u0645\\u062d\\u0644\\u064a\\u0629`,\n      fs_read_file: () =>\n        `\\u0642\\u0631\\u0627\\u0621\\u0629 \\u0645\\u062d\\u0644\\u064a: ${args.filePath || args.fileId}`,\n      fs_search_files: () =>\n        `\\u0628\\u062d\\u062b \\u0645\\u062d\\u0644\\u064a: ${args.query}`,\n      fs_create_file: () =>\n        `\\u0625\\u0646\\u0634\\u0627\\u0621 \\u0645\\u062d\\u0644\\u064a: ${args.name}`,\n      fs_update_file: () =>\n        `\\u062a\\u062d\\u062f\\u064a\\u062b \\u0645\\u062d\\u0644\\u064a: ${args.filePath || args.fileId}`,\n      fs_create_folder: () =>\n        `\\u0625\\u0646\\u0634\\u0627\\u0621 \\u0645\\u062c\\u0644\\u062f: ${args.name}`,\n      fs_delete_file: () =>\n        `\\u062d\\u0630\\u0641 \\u0645\\u062d\\u0644\\u064a: ${args.nodeId}`,\n      fs_rename_file: () =>\n        `\\u0625\\u0639\\u0627\\u062f\\u0629 \\u062a\\u0633\\u0645\\u064a\\u0629: ${args.newName}`,\n      fs_move_file: () => `\\u0646\\u0642\\u0644: ${args.nodeId}`,\n\n      // Git tools\n      git_status: () => `\\u0641\\u062d\\u0635 \\u062d\\u0627\\u0644\\u0629 Git`,\n      git_diff: () =>\n        `\\u0639\\u0631\\u0636 \\u0627\\u0644\\u062a\\u063a\\u064a\\u064a\\u0631\\u0627\\u062a`,\n      git_log: () => `\\u0633\\u062c\\u0644 Git`,\n      git_stage: () =>\n        `\\u062a\\u062c\\u0647\\u064a\\u0632: ${JSON.stringify(args.paths)}`,\n      git_commit: () => `\\u062d\\u0641\\u0638: ${args.message}`,\n      git_push: () => `\\u062f\\u0641\\u0639 \\u0644\\u0640 remote`,\n      git_create_branch: () =>\n        `\\u0625\\u0646\\u0634\\u0627\\u0621 \\u0641\\u0631\\u0639 \\u0645\\u062d\\u0644\\u064a: ${args.name}`,\n      git_create_pr: () =>\n        `\\u0625\\u0646\\u0634\\u0627\\u0621 PR \\u0645\\u0646 \\u0645\\u062d\\u0644\\u064a: ${args.title}`,\n\n      // Utility\n      get_project_context: () =>\n        `\\u062a\\u062d\\u0644\\u064a\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0631\\u0648\\u0639`,\n      explain_code: () => `\\u0634\\u0631\\u062d \\u0643\\u0648\\u062f`,\n      suggest_fix: () =>\n        `\\u0627\\u0642\\u062a\\u0631\\u0627\\u062d \\u0625\\u0635\\u0644\\u0627\\u062d: ${args.error}`,\n\n      // Legacy fallbacks\n      read_file: () => `\\u0642\\u0631\\u0627\\u0621\\u0629: ${args.path}`,\n      write_file: () => `\\u0643\\u062a\\u0627\\u0628\\u0629: ${args.path}`,\n      create_file: () => `\\u0625\\u0646\\u0634\\u0627\\u0621: ${args.path}`,\n    };\n\n    const generator = summaryMap[toolName];\n    if (generator) {\n      try {\n        return generator();\n      } catch {\n        /* fall through */\n      }\n    }\n\n    return `${toolName}(${Object.keys(args).join(', ')})`;\n  }\n\n  private loadFromStorage(): void {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      if (raw) {\n        this.entries = JSON.parse(raw);\n      }\n    } catch {\n      this.entries = [];\n    }\n  }\n\n  private saveToStorage(): void {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(this.entries));\n    } catch {\n      // Storage full â€” remove old entries and retry\n      this.entries = this.entries.slice(-Math.floor(MAX_ENTRIES / 2));\n      try {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(this.entries));\n      } catch {\n        /* give up */\n      }\n    }\n  }\n\n  private autoCleanup(): void {\n    this.cleanupOlderThan(AUTO_CLEANUP_DAYS);\n  }\n\n  private notifyListeners(): void {\n    this.listeners.forEach((fn) => fn());\n  }\n}\n\n// â”€â”€â”€ Singleton Instance â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nlet _instance: AuditLogger | null = null;\n\nexport function getAuditLogger(): AuditLogger {\n  if (!_instance) {\n    _instance = new AuditLogger();\n  }\n  return _instance;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\bridge\\agent-llm-adapter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\bridge\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\bridge\\ooda-bridge.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'OODAAnalysisRequest' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 25,
        "column": 8,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 25,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” OODA Bridge (Phase 7)\n * Connects AgentService â†” OODAController â†” GroqProvider into one unified system.\n *\n * This is the central integration point that:\n * 1. Intercepts SELF-IMPROVE mode triggers from AgentService\n * 2. Routes analysis requests to GroqProvider (LLM brain)\n * 3. Feeds LLM responses into OODAController (execution engine)\n * 4. Returns results back to AgentService for user display\n *\n * Architecture:\n * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n * â”‚ AgentService  â”‚â”€â”€â”€â”€â–¶â”‚  OODABridge  â”‚â”€â”€â”€â”€â–¶â”‚ OODAControllerâ”‚\n * â”‚ (User Chat)   â”‚â—€â”€â”€â”€â”€â”‚  (Router)    â”‚â—€â”€â”€â”€â”€â”‚ (Engine)      â”‚\n * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚              â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n *                      â”‚              â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n *                      â”‚              â”‚â”€â”€â”€â”€â–¶â”‚ GroqProvider  â”‚\n *                      â”‚              â”‚â—€â”€â”€â”€â”€â”‚ (LLM Brain)   â”‚\n *                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n */\n\nimport {\n  GroqProvider,\n  getGroqProvider,\n  type OODAAnalysisRequest,\n  type OODAAnalysisResponse,\n} from '../llm';\nimport type { AgentConfig } from '../types';\n\n// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface OODABridgeConfig {\n  /** Groq API key (required for LLM calls) */\n  groqApiKey: string;\n  /** Selected model ID from the model selector */\n  modelId: string;\n  /** Temperature for LLM responses */\n  temperature?: number;\n  /** Maximum tokens for LLM responses */\n  maxTokens?: number;\n  /** Enable verbose logging */\n  debug?: boolean;\n}\n\nexport interface SelfImproveRequest {\n  /** User's description of the issue */\n  issue: string;\n  /** Category of the issue */\n  category:\n    | 'ui_bug'\n    | 'logic_error'\n    | 'performance'\n    | 'style'\n    | 'accessibility';\n  /** File contents gathered by self_* tools */\n  fileContents: Record<string, string>;\n  /** Affected file paths */\n  affectedFiles: string[];\n  /** Additional context from previous analysis */\n  context?: string;\n}\n\nexport interface SelfImproveResult {\n  /** Whether the improvement cycle completed successfully */\n  success: boolean;\n  /** The OODA cycle ID */\n  cycleId: string;\n  /** Current phase when result was generated */\n  phase: string;\n  /** LLM analysis from each phase */\n  analyses: {\n    observe?: OODAAnalysisResponse;\n    orient?: OODAAnalysisResponse;\n    decide?: OODAAnalysisResponse;\n  };\n  /** Proposed fixes from the DECIDE phase */\n  proposedFixes: Array<{\n    filePath: string;\n    type: 'edit' | 'rewrite';\n    oldStr?: string;\n    newStr?: string;\n    content?: string;\n    explanation: string;\n  }>;\n  /** Error message if the cycle failed */\n  error?: string;\n  /** Token usage for this cycle */\n  tokenUsage: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n}\n\nexport type BridgeEventType =\n  | 'phase_start'\n  | 'phase_complete'\n  | 'llm_request'\n  | 'llm_response'\n  | 'fix_proposed'\n  | 'fix_applied'\n  | 'verification_result'\n  | 'pattern_learned'\n  | 'error';\n\nexport interface BridgeEvent {\n  type: BridgeEventType;\n  phase?: string;\n  data?: unknown;\n  timestamp: number;\n}\n\nexport type BridgeEventHandler = (event: BridgeEvent) => void;\n\n// â”€â”€â”€ Protected Paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst PROTECTED_PATHS = [\n  'lib/agent/safety/',\n  'lib/agent/constants.ts',\n  '.env',\n  '.env.local',\n  '.env.production',\n];\n\nfunction isProtectedPath(filePath: string): boolean {\n  return PROTECTED_PATHS.some((p) => filePath.startsWith(p) || filePath === p);\n}\n\n// â”€â”€â”€ OODA Bridge Class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport class OODABridge {\n  private groq: GroqProvider;\n  private config: OODABridgeConfig;\n  private eventHandlers: Set<BridgeEventHandler> = new Set();\n  private activeCycles: Map<string, SelfImproveResult> = new Map();\n  private cycleCounter = 0;\n\n  constructor(config: OODABridgeConfig) {\n    this.config = config;\n    this.groq = getGroqProvider({\n      apiKey: config.groqApiKey,\n      defaultModel: config.modelId,\n      temperature: config.temperature ?? 0.3,\n      maxTokens: config.maxTokens ?? 8192,\n    });\n  }\n\n  // â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  updateConfig(config: Partial<OODABridgeConfig>): void {\n    if (config.groqApiKey) this.groq.setApiKey(config.groqApiKey);\n    if (config.modelId) this.groq.setModel(config.modelId);\n    if (config.temperature !== undefined)\n      this.groq.setTemperature(config.temperature);\n    Object.assign(this.config, config);\n  }\n\n  /** Sync settings from AgentService config (provider-agnostic) */\n  syncFromAgentConfig(agentConfig: AgentConfig): void {\n    if (agentConfig.provider === 'groq' && agentConfig.apiKey) {\n      this.updateConfig({\n        groqApiKey: agentConfig.apiKey,\n        modelId: agentConfig.model,\n        temperature: agentConfig.temperature,\n      });\n    }\n  }\n\n  isReady(): boolean {\n    return this.groq.isConfigured();\n  }\n\n  getModel(): string {\n    return this.groq.getModel();\n  }\n\n  // â”€â”€â”€ Event System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  onEvent(handler: BridgeEventHandler): () => void {\n    this.eventHandlers.add(handler);\n    return () => this.eventHandlers.delete(handler);\n  }\n\n  private emit(event: Omit<BridgeEvent, 'timestamp'>): void {\n    const fullEvent: BridgeEvent = { ...event, timestamp: Date.now() };\n    this.eventHandlers.forEach((h) => h(fullEvent));\n    if (this.config.debug) {\n      console.log(\n        `[OODABridge] ${event.type}`,\n        event.phase || '',\n        event.data || ''\n      );\n    }\n  }\n\n  // â”€â”€â”€ Main: Run Self-Improve Cycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Execute a full OODA self-improvement cycle:\n   * OBSERVE â†’ ORIENT â†’ DECIDE\n   *\n   * Returns the analysis and proposed fixes WITHOUT executing them.\n   * The AgentService decides whether to proceed with execution\n   * based on risk level and user approval.\n   */\n  async runAnalysisCycle(\n    request: SelfImproveRequest\n  ): Promise<SelfImproveResult> {\n    const cycleId = `ooda-${++this.cycleCounter}-${Date.now()}`;\n\n    // Validate inputs\n    const protectedFiles = request.affectedFiles.filter(isProtectedPath);\n    if (protectedFiles.length > 0) {\n      return {\n        success: false,\n        cycleId,\n        phase: 'BLOCKED',\n        analyses: {},\n        proposedFixes: [],\n        error: `Ù…Ù„ÙØ§Øª Ù…Ø­Ù…ÙŠØ© Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ¹Ø¯ÙŠÙ„Ù‡Ø§: ${protectedFiles.join(', ')}`,\n        tokenUsage: { promptTokens: 0, completionTokens: 0, totalTokens: 0 },\n      };\n    }\n\n    if (request.affectedFiles.length > 10) {\n      return {\n        success: false,\n        cycleId,\n        phase: 'BLOCKED',\n        analyses: {},\n        proposedFixes: [],\n        error: `Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª (${request.affectedFiles.length}) ÙŠØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ (10)`,\n        tokenUsage: { promptTokens: 0, completionTokens: 0, totalTokens: 0 },\n      };\n    }\n\n    if (!this.isReady()) {\n      return {\n        success: false,\n        cycleId,\n        phase: 'BLOCKED',\n        analyses: {},\n        proposedFixes: [],\n        error: 'Ù…ÙØªØ§Ø­ Groq API ØºÙŠØ± Ù…ÙƒÙˆÙ‘Ù†. ÙŠØ±Ø¬Ù‰ Ø¥Ø¶Ø§ÙØªÙ‡ ÙÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.',\n        tokenUsage: { promptTokens: 0, completionTokens: 0, totalTokens: 0 },\n      };\n    }\n\n    const result: SelfImproveResult = {\n      success: false,\n      cycleId,\n      phase: 'OBSERVE',\n      analyses: {},\n      proposedFixes: [],\n      tokenUsage: { promptTokens: 0, completionTokens: 0, totalTokens: 0 },\n    };\n\n    this.activeCycles.set(cycleId, result);\n    const usageBefore = this.groq.getUsageStats();\n\n    try {\n      // â•â•â• Phase 1: OBSERVE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n      this.emit({ type: 'phase_start', phase: 'OBSERVE' });\n      this.emit({\n        type: 'llm_request',\n        phase: 'OBSERVE',\n        data: { issue: request.issue },\n      });\n\n      const observeResult = await this.groq.analyzeForOODA({\n        phase: 'observe',\n        issue: request.issue,\n        fileContents: request.fileContents,\n        context: request.context,\n      });\n\n      result.analyses.observe = observeResult;\n      result.phase = 'ORIENT';\n      this.emit({\n        type: 'llm_response',\n        phase: 'OBSERVE',\n        data: observeResult,\n      });\n      this.emit({ type: 'phase_complete', phase: 'OBSERVE' });\n\n      // â•â•â• Phase 2: ORIENT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n      this.emit({ type: 'phase_start', phase: 'ORIENT' });\n      this.emit({ type: 'llm_request', phase: 'ORIENT' });\n\n      const orientResult = await this.groq.analyzeForOODA({\n        phase: 'orient',\n        issue: request.issue,\n        fileContents: request.fileContents,\n        context: `Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø±ØµØ¯: ${observeResult.analysis}\\n\\nÙ…Ù„Ø§Ø­Ø¸Ø§Øª: ${observeResult.suggestions.join(', ')}`,\n      });\n\n      result.analyses.orient = orientResult;\n      result.phase = 'DECIDE';\n      this.emit({ type: 'llm_response', phase: 'ORIENT', data: orientResult });\n      this.emit({ type: 'phase_complete', phase: 'ORIENT' });\n\n      // â•â•â• Phase 3: DECIDE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n      this.emit({ type: 'phase_start', phase: 'DECIDE' });\n      this.emit({ type: 'llm_request', phase: 'DECIDE' });\n\n      const decideResult = await this.groq.analyzeForOODA({\n        phase: 'decide',\n        issue: request.issue,\n        fileContents: request.fileContents,\n        context: [\n          `Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø±ØµØ¯: ${observeResult.analysis}`,\n          `Ø§Ù„ØªØ­Ù„ÙŠÙ„: ${orientResult.analysis}`,\n          `Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª: ${orientResult.suggestions.join(', ')}`,\n        ].join('\\n\\n'),\n      });\n\n      result.analyses.decide = decideResult;\n      result.phase = 'READY';\n      this.emit({ type: 'llm_response', phase: 'DECIDE', data: decideResult });\n      this.emit({ type: 'phase_complete', phase: 'DECIDE' });\n\n      // Extract fixes from DECIDE response\n      if (decideResult.fixes && decideResult.fixes.length > 0) {\n        // Filter out any fixes targeting protected paths\n        result.proposedFixes = decideResult.fixes.filter(\n          (fix) => !isProtectedPath(fix.filePath)\n        );\n        this.emit({ type: 'fix_proposed', data: result.proposedFixes });\n      }\n\n      result.success = true;\n    } catch (error) {\n      result.error = (error as Error).message;\n      result.phase = 'ERROR';\n      this.emit({ type: 'error', data: { error: (error as Error).message } });\n    }\n\n    // Calculate token usage for this cycle\n    const usageAfter = this.groq.getUsageStats();\n    result.tokenUsage = {\n      promptTokens:\n        usageAfter.totalPromptTokens - usageBefore.totalPromptTokens,\n      completionTokens:\n        usageAfter.totalCompletionTokens - usageBefore.totalCompletionTokens,\n      totalTokens: usageAfter.totalTokens - usageBefore.totalTokens,\n    };\n\n    this.activeCycles.set(cycleId, result);\n    return result;\n  }\n\n  // â”€â”€â”€ Cycle Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  getCycle(cycleId: string): SelfImproveResult | undefined {\n    return this.activeCycles.get(cycleId);\n  }\n\n  getAllCycles(): Map<string, SelfImproveResult> {\n    return new Map(this.activeCycles);\n  }\n\n  getActiveCycleCount(): number {\n    return [...this.activeCycles.values()].filter(\n      (c) => !['READY', 'COMPLETE', 'ERROR', 'BLOCKED'].includes(c.phase)\n    ).length;\n  }\n\n  // â”€â”€â”€ Quick Ask (for simple agent queries) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Quick LLM call for non-OODA tasks.\n   * Used when AgentService needs Groq for general responses.\n   */\n  async ask(prompt: string, systemPrompt?: string): Promise<string> {\n    if (!this.isReady()) {\n      throw new Error('Ù…ÙØªØ§Ø­ Groq API ØºÙŠØ± Ù…ÙƒÙˆÙ‘Ù†');\n    }\n    return this.groq.ask(prompt, systemPrompt);\n  }\n\n  /**\n   * Streaming chat for real-time UI responses.\n   */\n  async *chatStream(\n    prompt: string,\n    systemPrompt?: string\n  ): AsyncGenerator<string, void, unknown> {\n    if (!this.isReady()) {\n      throw new Error('Ù…ÙØªØ§Ø­ Groq API ØºÙŠØ± Ù…ÙƒÙˆÙ‘Ù†');\n    }\n\n    const messages = [];\n    if (systemPrompt)\n      messages.push({ role: 'system' as const, content: systemPrompt });\n    messages.push({ role: 'user' as const, content: prompt });\n\n    yield* this.groq.chatStream(messages);\n  }\n\n  // â”€â”€â”€ Stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  getStats(): {\n    totalCycles: number;\n    activeCycles: number;\n    successfulCycles: number;\n    failedCycles: number;\n    totalTokens: number;\n    model: string;\n    isReady: boolean;\n  } {\n    const cycles = [...this.activeCycles.values()];\n    return {\n      totalCycles: cycles.length,\n      activeCycles: this.getActiveCycleCount(),\n      successfulCycles: cycles.filter((c) => c.success).length,\n      failedCycles: cycles.filter((c) => c.phase === 'ERROR').length,\n      totalTokens: this.groq.getUsageStats().totalTokens,\n      model: this.groq.getModel(),\n      isReady: this.isReady(),\n    };\n  }\n\n  // â”€â”€â”€ Cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  dispose(): void {\n    this.eventHandlers.clear();\n    this.activeCycles.clear();\n  }\n}\n\n// â”€â”€â”€ Singleton â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nlet bridgeInstance: OODABridge | null = null;\n\nexport function getOODABridge(config?: OODABridgeConfig): OODABridge {\n  if (!bridgeInstance && config) {\n    bridgeInstance = new OODABridge(config);\n  }\n  if (!bridgeInstance) {\n    bridgeInstance = new OODABridge({\n      groqApiKey: '',\n      modelId: 'llama-3.3-70b-versatile',\n    });\n  }\n  return bridgeInstance;\n}\n\nexport function resetOODABridge(): void {\n  bridgeInstance?.dispose();\n  bridgeInstance = null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\bridge\\store-bridge.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'FileNode' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 8,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 8,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 37,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 37,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1102, 1105], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1102, 1105], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 47,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 47,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1341, 1344], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1341, 1344], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 49,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 49,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1412, 1415], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1412, 1415], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 56,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 56,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1590, 1593], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1590, 1593], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 58,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 58,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1660, 1663], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1660, 1663], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 59,
        "column": 25,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 59,
        "endColumn": 28,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1718, 1721], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1718, 1721], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 75,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 75,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2148, 2151], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2148, 2151], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 76,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 76,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2202, 2205], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2202, 2205], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 112,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 112,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3232, 3235], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3232, 3235], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 113,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 113,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3275, 3278], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3275, 3278], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 130,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 130,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3754, 3757], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3754, 3757], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 131,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 131,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3810, 3813], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3810, 3813], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 13,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Store Bridge\n * Bridges agent tool operations with UI stores.\n * Ensures File Explorer, Editor tabs, and Git panel\n * stay in sync when the agent modifies files.\n */\n\nimport type { FileNode } from '@/lib/db/schema';\n\n/**\n * Refresh the file tree in the File Explorer.\n * Call after any file create/delete/rename/move.\n */\nexport async function refreshFileTree(): Promise<void> {\n  try {\n    const { useFilesStore } = await import('@/lib/stores/files-store');\n    await useFilesStore.getState().loadFileTree();\n  } catch (error) {\n    console.error('[StoreBridge] Failed to refresh file tree:', error);\n  }\n}\n\n/**\n * Refresh a specific file in the editor if it's currently open.\n * Call after update_file to sync the editor content.\n */\nexport async function refreshOpenFile(\n  fileId: string,\n  newContent: string\n): Promise<void> {\n  try {\n    const { useEditorStore } = await import('@/lib/stores/editor-store');\n    const editorStore = useEditorStore.getState();\n\n    // Check if this file is in an open tab\n    if ('tabs' in editorStore) {\n      const tabs = (editorStore as any).tabs as Array<{\n        id: string;\n        fileId?: string;\n      }>;\n      const isOpen = tabs?.some(\n        (tab) => tab.fileId === fileId || tab.id === fileId\n      );\n\n      if (\n        isOpen &&\n        typeof (editorStore as any).updateTabContent === 'function'\n      ) {\n        (editorStore as any).updateTabContent(fileId, newContent);\n      }\n    }\n\n    // If the active file is this file, update it\n    if (\n      'activeFileId' in editorStore &&\n      (editorStore as any).activeFileId === fileId\n    ) {\n      if (typeof (editorStore as any).setContent === 'function') {\n        (editorStore as any).setContent(newContent);\n      }\n    }\n  } catch (error) {\n    console.error('[StoreBridge] Failed to refresh open file:', error);\n  }\n}\n\n/**\n * Close editor tab for a deleted file.\n */\nexport async function closeDeletedFileTab(fileId: string): Promise<void> {\n  try {\n    const { useEditorStore } = await import('@/lib/stores/editor-store');\n    const editorStore = useEditorStore.getState();\n\n    if (typeof (editorStore as any).closeTab === 'function') {\n      (editorStore as any).closeTab(fileId);\n    }\n  } catch (error) {\n    console.error('[StoreBridge] Failed to close deleted file tab:', error);\n  }\n}\n\n/**\n * Expand the parent folder in File Explorer after creating a file/folder.\n */\nexport async function expandParentFolder(\n  parentId: string | null\n): Promise<void> {\n  if (!parentId) return;\n  try {\n    const { useFilesStore } = await import('@/lib/stores/files-store');\n    useFilesStore.getState().expandFolder(parentId);\n  } catch (error) {\n    console.error('[StoreBridge] Failed to expand parent folder:', error);\n  }\n}\n\n/**\n * Send a notification to the user.\n */\nexport async function sendNotification(\n  message: string,\n  type: 'info' | 'success' | 'warning' | 'error' = 'info'\n): Promise<void> {\n  try {\n    const { useNotificationStore } =\n      await import('@/lib/stores/notification-store');\n    const store = useNotificationStore.getState();\n\n    if (typeof store.addNotification === 'function') {\n      store.addNotification({ message, type });\n    } else if (typeof (store as any).add === 'function') {\n      (store as any).add({ message, type });\n    }\n  } catch (error) {\n    console.warn('[StoreBridge] Notification store not available:', error);\n  }\n}\n\n/**\n * Refresh git store state after git operations.\n */\nexport async function refreshGitState(): Promise<void> {\n  try {\n    const { useGitStore } = await import('@/lib/stores/git-store');\n    const store = useGitStore.getState();\n\n    if (typeof store.refresh === 'function') {\n      await store.refresh();\n    } else if (typeof (store as any).loadStatus === 'function') {\n      await (store as any).loadStatus();\n    }\n  } catch (error) {\n    console.error('[StoreBridge] Failed to refresh git state:', error);\n  }\n}\n\n/**\n * Set the active file in the editor (navigate to a file).\n */\nexport async function openFileInEditor(fileId: string): Promise<void> {\n  try {\n    const { useFilesStore } = await import('@/lib/stores/files-store');\n    useFilesStore.getState().setActiveFile(fileId);\n  } catch (error) {\n    console.error('[StoreBridge] Failed to open file in editor:', error);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\hooks\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\hooks\\use-agent-context-menu.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\hooks\\use-agent-keyboard.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\hooks\\use-ooda-bridge.ts",
    "messages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useEffect has a missing dependency: 'initialConfig'. Either include it or remove the dependency array.",
        "line": 113,
        "column": 6,
        "nodeType": "ArrayExpression",
        "endLine": 113,
        "endColumn": 8,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [initialConfig]",
            "fix": { "range": [2986, 2988], "text": "[initialConfig]" }
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” useOODABridge React Hook (Phase 8)\n * Provides React components with access to the OODABridge state.\n *\n * Features:\n * - Reactive state updates from OODABridge events\n * - Automatic cleanup on unmount\n * - Bridge stats, active cycles, and readiness\n * - Integration with agent settings for Groq API key\n *\n * Usage:\n *   const { isReady, stats, events, mode, runCycle } = useOODABridge();\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport {\n  OODABridge,\n  getOODABridge,\n  type OODABridgeConfig,\n  type SelfImproveRequest,\n  type SelfImproveResult,\n  type BridgeEvent,\n} from '../bridge';\n\n// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface OODABridgeState {\n  /** Whether the bridge is configured and ready */\n  isReady: boolean;\n  /** Current model being used */\n  model: string;\n  /** Bridge statistics */\n  stats: {\n    totalCycles: number;\n    activeCycles: number;\n    successfulCycles: number;\n    failedCycles: number;\n    totalTokens: number;\n  };\n  /** Recent events from the bridge (last 50) */\n  events: BridgeEvent[];\n  /** Last cycle result */\n  lastResult: SelfImproveResult | null;\n  /** Whether a cycle is currently running */\n  isRunning: boolean;\n  /** Error message if something went wrong */\n  error: string | null;\n}\n\nexport interface UseOODABridgeReturn extends OODABridgeState {\n  /** Initialize or update the bridge configuration */\n  configure: (config: OODABridgeConfig) => void;\n  /** Run an analysis cycle */\n  runCycle: (request: SelfImproveRequest) => Promise<SelfImproveResult | null>;\n  /** Clear events list */\n  clearEvents: () => void;\n  /** Get the raw bridge instance */\n  bridge: OODABridge | null;\n}\n\n// â”€â”€â”€ Hook â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport function useOODABridge(\n  initialConfig?: OODABridgeConfig\n): UseOODABridgeReturn {\n  const bridgeRef = useRef<OODABridge | null>(null);\n  const [state, setState] = useState<OODABridgeState>({\n    isReady: false,\n    model: 'llama-3.3-70b-versatile',\n    stats: {\n      totalCycles: 0,\n      activeCycles: 0,\n      successfulCycles: 0,\n      failedCycles: 0,\n      totalTokens: 0,\n    },\n    events: [],\n    lastResult: null,\n    isRunning: false,\n    error: null,\n  });\n\n  // Initialize bridge\n  useEffect(() => {\n    if (initialConfig) {\n      bridgeRef.current = new OODABridge(initialConfig);\n    } else {\n      bridgeRef.current = getOODABridge();\n    }\n\n    const bridge = bridgeRef.current;\n\n    // Subscribe to events\n    const unsubscribe = bridge.onEvent((event: BridgeEvent) => {\n      setState((prev) => ({\n        ...prev,\n        events: [...prev.events.slice(-49), event], // Keep last 50\n        stats: bridge.getStats(),\n      }));\n    });\n\n    // Initial state\n    setState((prev) => ({\n      ...prev,\n      isReady: bridge.isReady(),\n      model: bridge.getModel(),\n      stats: bridge.getStats(),\n    }));\n\n    return () => {\n      unsubscribe();\n    };\n  }, []);\n\n  // Configure bridge\n  const configure = useCallback((config: OODABridgeConfig) => {\n    if (bridgeRef.current) {\n      bridgeRef.current.updateConfig(config);\n    } else {\n      bridgeRef.current = new OODABridge(config);\n    }\n\n    const bridge = bridgeRef.current;\n    setState((prev) => ({\n      ...prev,\n      isReady: bridge.isReady(),\n      model: bridge.getModel(),\n      stats: bridge.getStats(),\n    }));\n  }, []);\n\n  // Run analysis cycle\n  const runCycle = useCallback(\n    async (request: SelfImproveRequest): Promise<SelfImproveResult | null> => {\n      const bridge = bridgeRef.current;\n      if (!bridge || !bridge.isReady()) {\n        setState((prev) => ({\n          ...prev,\n          error: 'Ø§Ù„Ø¬Ø³Ø± ØºÙŠØ± Ø¬Ø§Ù‡Ø² â€” ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯ Ù…ÙØªØ§Ø­ Groq API',\n        }));\n        return null;\n      }\n\n      setState((prev) => ({ ...prev, isRunning: true, error: null }));\n\n      try {\n        const result = await bridge.runAnalysisCycle(request);\n        setState((prev) => ({\n          ...prev,\n          isRunning: false,\n          lastResult: result,\n          stats: bridge.getStats(),\n          error: result.success ? null : result.error || null,\n        }));\n        return result;\n      } catch (error) {\n        const msg = (error as Error).message;\n        setState((prev) => ({\n          ...prev,\n          isRunning: false,\n          error: msg,\n        }));\n        return null;\n      }\n    },\n    []\n  );\n\n  // Clear events\n  const clearEvents = useCallback(() => {\n    setState((prev) => ({ ...prev, events: [] }));\n  }, []);\n\n  return {\n    ...state,\n    configure,\n    runCycle,\n    clearEvents,\n    bridge: bridgeRef.current,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\llm\\groq-provider.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 351,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 351,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9274, 9277], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9274, 9277], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Groq LLM Provider\n * Full Groq API client with chat, streaming, and OODA integration.\n *\n * Endpoints:\n * - Chat Completions: POST /openai/v1/chat/completions\n * - Audio Transcription: POST /openai/v1/audio/transcriptions\n *\n * Features:\n * - Standard chat completion\n * - Streaming responses (SSE)\n * - OODA phase analysis (observe, orient, decide)\n * - Automatic retry with exponential backoff\n * - Token usage tracking\n */\n\nimport type {\n  GroqConfig,\n  ChatMessage,\n  ChatCompletionRequest,\n  ChatCompletionResponse,\n  StreamChunk,\n  OODAAnalysisRequest,\n  OODAAnalysisResponse,\n} from './types';\nimport { getModelById, getDefaultModel } from './types';\n\n// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst GROQ_BASE_URL = 'https://api.groq.com/openai/v1';\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\n\n// â”€â”€â”€ OODA System Prompts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst OODA_SYSTEM_PROMPTS: Record<string, string> = {\n  observe: `Ø£Ù†Øª Ù…Ø­Ù„Ù„ ÙƒÙˆØ¯ Ø®Ø¨ÙŠØ± ÙÙŠ Ù…Ø´Ø±ÙˆØ¹ CodeForge IDE (Next.js + TypeScript + Monaco Editor).\nÙ…Ù‡Ù…ØªÙƒ: **Ø±ØµØ¯** Ø§Ù„Ù…Ø´ÙƒÙ„Ø© ÙˆØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ£Ø«Ø±Ø©.\n\nÙ‚ÙˆØ§Ø¹Ø¯:\n- Ø­Ù„Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ø¹Ø·Ù‰ Ø¨Ø¯Ù‚Ø©\n- Ø­Ø¯Ø¯ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ£Ø«Ø±Ø© Ù…Ø¨Ø§Ø´Ø±Ø© ÙˆØºÙŠØ± Ù…Ø¨Ø§Ø´Ø±Ø©\n- Ø§Ø°ÙƒØ± Ø§Ù„Ø£Ø¯Ù„Ø© Ø§Ù„ÙˆØ§Ø¶Ø­Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©\n- Ù„Ø§ ØªÙ‚ØªØ±Ø­ Ø­Ù„ÙˆÙ„Ø§Ù‹ Ø¨Ø¹Ø¯ â€” ÙÙ‚Ø· Ø±ØµØ¯\n\nØ£Ø¬Ø¨ Ø¨ØµÙŠØºØ© JSON:\n{\n  \"analysis\": \"ÙˆØµÙ Ø§Ù„Ù…Ø´ÙƒÙ„Ø©\",\n  \"suggestions\": [\"Ù…Ù„Ø§Ø­Ø¸Ø© 1\", \"Ù…Ù„Ø§Ø­Ø¸Ø© 2\"],\n  \"confidence\": 0.0-1.0\n}`,\n\n  orient: `Ø£Ù†Øª Ù…Ø­Ù„Ù„ ÙƒÙˆØ¯ Ø®Ø¨ÙŠØ± ÙÙŠ Ù…Ø´Ø±ÙˆØ¹ CodeForge IDE.\nÙ…Ù‡Ù…ØªÙƒ: **ØªØ­Ù„ÙŠÙ„** Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ø¬Ø°Ø±ÙŠ Ù„Ù„Ù…Ø´ÙƒÙ„Ø©.\n\nÙ‚ÙˆØ§Ø¹Ø¯:\n- Ø­Ø¯Ø¯ Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ø¬Ø°Ø±ÙŠ (root cause)\n- Ø±ØªØ¨ Ø§Ù„Ø£Ø³Ø¨Ø§Ø¨ Ø§Ù„Ù…Ø­ØªÙ…Ù„Ø© Ø­Ø³Ø¨ Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©\n- Ø­Ø¯Ø¯ Ù†Ø·Ø§Ù‚ Ø§Ù„ØªØ£Ø«ÙŠØ± (scope)\n- Ø§Ø°ÙƒØ± Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ù„Ù„Ø¥ØµÙ„Ø§Ø­\n\nØ£Ø¬Ø¨ Ø¨ØµÙŠØºØ© JSON:\n{\n  \"analysis\": \"Ø§Ù„Ø³Ø¨Ø¨ Ø§Ù„Ø¬Ø°Ø±ÙŠ\",\n  \"suggestions\": [\"Ø³Ø¨Ø¨ 1\", \"Ø³Ø¨Ø¨ 2\"],\n  \"confidence\": 0.0-1.0\n}`,\n\n  decide: `Ø£Ù†Øª Ù…Ù‡Ù†Ø¯Ø³ Ø¨Ø±Ù…Ø¬ÙŠØ§Øª Ø®Ø¨ÙŠØ± ÙÙŠ Ù…Ø´Ø±ÙˆØ¹ CodeForge IDE.\nÙ…Ù‡Ù…ØªÙƒ: **Ø§Ù‚ØªØ±Ø§Ø­** Ø®Ø·Ø© Ø¥ØµÙ„Ø§Ø­ Ø¯Ù‚ÙŠÙ‚Ø© ÙˆÙ‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ†ÙÙŠØ°.\n\nÙ‚ÙˆØ§Ø¹Ø¯:\n- Ø§ÙƒØªØ¨ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø¨Ø¯Ù‚Ø© (oldStr â†’ newStr Ø£Ùˆ content ÙƒØ§Ù…Ù„)\n- Ù„Ø§ ØªØ¹Ø¯Ù„ Ù…Ù„ÙØ§Øª Ù…Ø­Ù…ÙŠØ© (lib/agent/safety/*, .env*)\n- Ø­Ø¯ Ø£Ù‚ØµÙ‰ 10 Ù…Ù„ÙØ§Øª\n- Ø§Ø´Ø±Ø­ ÙƒÙ„ ØªØ¹Ø¯ÙŠÙ„\n\nØ£Ø¬Ø¨ Ø¨ØµÙŠØºØ© JSON:\n{\n  \"analysis\": \"Ø®Ø·Ø© Ø§Ù„Ø¥ØµÙ„Ø§Ø­\",\n  \"suggestions\": [\"Ø®Ø·ÙˆØ© 1\", \"Ø®Ø·ÙˆØ© 2\"],\n  \"fixes\": [\n    {\n      \"filePath\": \"path/to/file.ts\",\n      \"type\": \"edit\",\n      \"oldStr\": \"Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù‚Ø¯ÙŠÙ…\",\n      \"newStr\": \"Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯\",\n      \"explanation\": \"Ø³Ø¨Ø¨ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„\"\n    }\n  ],\n  \"confidence\": 0.0-1.0\n}`,\n};\n\n// â”€â”€â”€ GroqProvider Class â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport class GroqProvider {\n  private apiKey: string;\n  private baseUrl: string;\n  private defaultModel: string;\n  private temperature: number;\n  private maxTokens: number;\n\n  // Usage tracking\n  private totalPromptTokens = 0;\n  private totalCompletionTokens = 0;\n  private totalRequests = 0;\n\n  constructor(config: GroqConfig) {\n    this.apiKey = config.apiKey;\n    this.baseUrl = config.baseUrl || GROQ_BASE_URL;\n    this.defaultModel = config.defaultModel || getDefaultModel().id;\n    this.temperature = config.temperature ?? 0.3;\n    this.maxTokens = config.maxTokens ?? 8192;\n  }\n\n  // â”€â”€â”€ Configuration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  setApiKey(key: string): void {\n    this.apiKey = key;\n  }\n\n  setModel(modelId: string): void {\n    const model = getModelById(modelId);\n    if (model && (model.type === 'text' || model.type === 'compound')) {\n      this.defaultModel = modelId;\n    }\n  }\n\n  setTemperature(temp: number): void {\n    this.temperature = Math.max(0, Math.min(2, temp));\n  }\n\n  getModel(): string {\n    return this.defaultModel;\n  }\n\n  isConfigured(): boolean {\n    return this.apiKey.length > 0;\n  }\n\n  // â”€â”€â”€ Chat Completion â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  async chat(\n    messages: ChatMessage[],\n    options?: {\n      model?: string;\n      temperature?: number;\n      maxTokens?: number;\n      stop?: string[];\n    }\n  ): Promise<ChatCompletionResponse> {\n    const request: ChatCompletionRequest = {\n      model: options?.model || this.defaultModel,\n      messages,\n      temperature: options?.temperature ?? this.temperature,\n      max_tokens: options?.maxTokens ?? this.maxTokens,\n      stream: false,\n      stop: options?.stop,\n    };\n\n    const response = await this.fetchWithRetry('/chat/completions', request);\n\n    // Track usage\n    if (response.usage) {\n      this.totalPromptTokens += response.usage.prompt_tokens;\n      this.totalCompletionTokens += response.usage.completion_tokens;\n    }\n    this.totalRequests++;\n\n    return response;\n  }\n\n  // â”€â”€â”€ Streaming Chat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  async *chatStream(\n    messages: ChatMessage[],\n    options?: {\n      model?: string;\n      temperature?: number;\n      maxTokens?: number;\n    }\n  ): AsyncGenerator<string, void, unknown> {\n    const request: ChatCompletionRequest = {\n      model: options?.model || this.defaultModel,\n      messages,\n      temperature: options?.temperature ?? this.temperature,\n      max_tokens: options?.maxTokens ?? this.maxTokens,\n      stream: true,\n    };\n\n    const response = await fetch(`${this.baseUrl}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.apiKey}`,\n      },\n      body: JSON.stringify(request),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Groq API error (${response.status}): ${error}`);\n    }\n\n    const reader = response.body?.getReader();\n    if (!reader) throw new Error('No response body');\n\n    const decoder = new TextDecoder();\n    let buffer = '';\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          const trimmed = line.trim();\n          if (!trimmed || !trimmed.startsWith('data: ')) continue;\n          const data = trimmed.slice(6);\n          if (data === '[DONE]') return;\n\n          try {\n            const chunk: StreamChunk = JSON.parse(data);\n            const content = chunk.choices[0]?.delta?.content;\n            if (content) yield content;\n          } catch {\n            // Skip malformed chunks\n          }\n        }\n      }\n    } finally {\n      reader.releaseLock();\n    }\n\n    this.totalRequests++;\n  }\n\n  // â”€â”€â”€ OODA Integration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  async analyzeForOODA(\n    request: OODAAnalysisRequest\n  ): Promise<OODAAnalysisResponse> {\n    const systemPrompt = OODA_SYSTEM_PROMPTS[request.phase];\n    if (!systemPrompt) {\n      throw new Error(`Unknown OODA phase: ${request.phase}`);\n    }\n\n    // Build file context\n    const fileContext = Object.entries(request.fileContents)\n      .map(([path, content]) => `=== ${path} ===\\n${content}`)\n      .join('\\n\\n');\n\n    const messages: ChatMessage[] = [\n      { role: 'system', content: systemPrompt },\n      {\n        role: 'user',\n        content: [\n          `## Ø§Ù„Ù…Ø´ÙƒÙ„Ø©`,\n          request.issue,\n          '',\n          request.context ? `## Ø³ÙŠØ§Ù‚ Ø¥Ø¶Ø§ÙÙŠ\\n${request.context}\\n` : '',\n          `## Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…ØªØ£Ø«Ø±Ø©`,\n          fileContext,\n        ].join('\\n'),\n      },\n    ];\n\n    const response = await this.chat(messages, {\n      temperature: 0.2,\n      maxTokens: 4096,\n    });\n\n    const content = response.choices[0]?.message?.content || '{}';\n\n    try {\n      // Extract JSON from response (handle markdown code blocks)\n      const jsonMatch =\n        content.match(/```json\\s*([\\s\\S]*?)```/) ||\n        content.match(/\\{[\\s\\S]*\\}/);\n      const jsonStr = jsonMatch ? jsonMatch[1] || jsonMatch[0] : content;\n      return JSON.parse(jsonStr);\n    } catch {\n      return {\n        analysis: content,\n        suggestions: [],\n        confidence: 0.5,\n      };\n    }\n  }\n\n  // â”€â”€â”€ Simple Helper: Ask â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  async ask(prompt: string, systemPrompt?: string): Promise<string> {\n    const messages: ChatMessage[] = [];\n    if (systemPrompt) {\n      messages.push({ role: 'system', content: systemPrompt });\n    }\n    messages.push({ role: 'user', content: prompt });\n\n    const response = await this.chat(messages);\n    return response.choices[0]?.message?.content || '';\n  }\n\n  // â”€â”€â”€ Usage Stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  getUsageStats(): {\n    totalRequests: number;\n    totalPromptTokens: number;\n    totalCompletionTokens: number;\n    totalTokens: number;\n  } {\n    return {\n      totalRequests: this.totalRequests,\n      totalPromptTokens: this.totalPromptTokens,\n      totalCompletionTokens: this.totalCompletionTokens,\n      totalTokens: this.totalPromptTokens + this.totalCompletionTokens,\n    };\n  }\n\n  resetUsageStats(): void {\n    this.totalRequests = 0;\n    this.totalPromptTokens = 0;\n    this.totalCompletionTokens = 0;\n  }\n\n  // â”€â”€â”€ API Key Validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  async validateApiKey(): Promise<{ valid: boolean; error?: string }> {\n    try {\n      await this.chat([{ role: 'user', content: 'Hi' }], { maxTokens: 1 });\n      return { valid: true };\n    } catch (error) {\n      return {\n        valid: false,\n        error: (error as Error).message,\n      };\n    }\n  }\n\n  // â”€â”€â”€ Internal: Fetch with Retry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private async fetchWithRetry(\n    endpoint: string,\n    body: Record<string, unknown>,\n    retries = MAX_RETRIES\n  ): Promise<any> {\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt <= retries; attempt++) {\n      try {\n        const response = await fetch(`${this.baseUrl}${endpoint}`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${this.apiKey}`,\n          },\n          body: JSON.stringify(body),\n        });\n\n        if (response.status === 429) {\n          // Rate limited â€” wait and retry\n          const retryAfter = parseInt(\n            response.headers.get('retry-after') || '2'\n          );\n          await this.sleep(retryAfter * 1000);\n          continue;\n        }\n\n        if (!response.ok) {\n          const errorBody = await response.text();\n          throw new Error(`Groq API error (${response.status}): ${errorBody}`);\n        }\n\n        return await response.json();\n      } catch (error) {\n        lastError = error as Error;\n        if (attempt < retries) {\n          await this.sleep(RETRY_DELAY_MS * Math.pow(2, attempt));\n        }\n      }\n    }\n\n    throw lastError || new Error('Groq API request failed after retries');\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n\n// â”€â”€â”€ Singleton â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nlet groqInstance: GroqProvider | null = null;\n\nexport function getGroqProvider(config?: GroqConfig): GroqProvider {\n  if (!groqInstance && config) {\n    groqInstance = new GroqProvider(config);\n  }\n  if (!groqInstance) {\n    groqInstance = new GroqProvider({ apiKey: '' });\n  }\n  return groqInstance;\n}\n\nexport function resetGroqProvider(): void {\n  groqInstance = null;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\llm\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\llm\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\providers\\anthropic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\providers\\google.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\providers\\groq.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\providers\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\providers\\openai.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\safety\\__tests__\\approval-manager.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\safety\\approval-manager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\safety\\index.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'RiskLevel' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 9,
        "column": 41,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 9,
        "endColumn": 50
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'classifyRisk' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 11,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 11,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'classifyGitHubRisk' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 12,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 12,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'isSensitiveFile' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 13,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 13,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'containsRiskyContent' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 14,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 14,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'getRiskDescription' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 15,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 15,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'getRiskEmoji' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 16,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 16,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Safety Module v2.0\n * Central export for all safety components.\n *\n * Provides processToolSafety() as the single entry point\n * for the agent-service tool execution loop.\n */\n\nimport type { ToolCall, ToolDefinition, RiskLevel } from '../types';\nimport {\n  classifyRisk,\n  classifyGitHubRisk,\n  isSensitiveFile,\n  containsRiskyContent,\n  getRiskDescription,\n  getRiskEmoji,\n} from './risk-classifier';\nimport { ApprovalManager, type ToolNotification } from './approval-manager';\nimport type { PendingApproval } from '../types';\n\n// Re-export everything\nexport {\n  classifyRisk,\n  classifyGitHubRisk,\n  isSensitiveFile,\n  containsRiskyContent,\n  getRiskDescription,\n  getRiskEmoji,\n} from './risk-classifier';\nexport { ApprovalManager, type ToolNotification } from './approval-manager';\n\n// â”€â”€â”€ Singleton Approval Manager â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nlet _approvalManager: ApprovalManager | null = null;\n\nexport function getApprovalManager(): ApprovalManager {\n  if (!_approvalManager) {\n    _approvalManager = new ApprovalManager();\n  }\n  return _approvalManager;\n}\n\n// â”€â”€â”€ Safety Action Descriptors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport type SafetyAction =\n  | { type: 'auto'; riskLevel: 'auto' }\n  | { type: 'notify'; riskLevel: 'notify'; notification: ToolNotification }\n  | { type: 'confirm'; riskLevel: 'confirm'; approval: PendingApproval };\n\n/**\n * processToolSafety â€” Single entry point for the agent-service.\n *\n * Given a tool call and its definition, returns a SafetyAction\n * that tells the agent-service exactly what to do:\n *\n * - auto:    Execute immediately, no UI interaction\n * - notify:  Execute but show a notification to the user\n * - confirm: Pause and wait for user approval before executing\n *\n * @example\n * ```ts\n * const action = processToolSafety(toolCall, toolDef);\n * if (action.type === 'confirm') {\n *   const approved = await onApprovalRequired(action.approval);\n *   if (!approved) { return; } // skip execution\n * } else if (action.type === 'notify') {\n *   onNotify?.(action.notification);\n * }\n * // then execute the tool\n * ```\n */\nexport function processToolSafety(\n  toolCall: ToolCall,\n  toolDef?: ToolDefinition\n): SafetyAction {\n  const manager = getApprovalManager();\n\n  // Determine effective risk level\n  const effectiveRisk = manager.getEffectiveRisk(toolCall, toolDef);\n\n  switch (effectiveRisk) {\n    case 'confirm':\n      return {\n        type: 'confirm',\n        riskLevel: 'confirm',\n        approval: manager.createApproval(toolCall, toolDef),\n      };\n\n    case 'notify':\n      return {\n        type: 'notify',\n        riskLevel: 'notify',\n        notification: manager.createNotification(toolCall),\n      };\n\n    case 'auto':\n    default:\n      return {\n        type: 'auto',\n        riskLevel: 'auto',\n      };\n  }\n}\n\n/**\n * Quick check: does this tool call need any user interaction?\n * Returns false for AUTO tools, true for NOTIFY and CONFIRM.\n */\nexport function requiresUserInteraction(\n  toolCall: ToolCall,\n  toolDef?: ToolDefinition\n): boolean {\n  const manager = getApprovalManager();\n  return !manager.isAutoExecute(toolCall, toolDef);\n}\n\n/**\n * Quick check: is this a dangerous (CONFIRM-level) operation?\n */\nexport function isDangerous(\n  toolCall: ToolCall,\n  toolDef?: ToolDefinition\n): boolean {\n  const manager = getApprovalManager();\n  return manager.needsApproval(toolCall, toolDef);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\safety\\risk-classifier.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\safety\\validation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\__tests__\\fix-executor.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 104,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 104,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2850, 2853], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2850, 2853], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 109,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 109,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3003, 3006], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3003, 3006], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'result' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 192,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 192,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 268,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 268,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7324, 7327], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7324, 7327], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 289,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 289,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7856, 7859], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7856, 7859], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Fix Executor Tests\n * Unit tests for the plan execution engine.\n *\n * Tests cover:\n * - Plan execution with file operations\n * - Rollback on failure\n * - Protected path enforcement\n * - Dry run mode\n * - File limit enforcement\n * - Step-by-step execution order\n */\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { FixExecutor } from '../fix-executor';\nimport type { ToolBridge } from '../fix-executor';\n\n// â”€â”€â”€ Test Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction createMockBridge(): ToolBridge {\n  const files: Record<string, string> = {\n    'src/app.ts': 'export const app = true;\\nconst old = \"value\";',\n    'src/utils.ts': 'export function helper() { return 1; }',\n    'lib/agent/safety/index.ts': 'export const SAFE = true;',\n  };\n\n  return {\n    readFile: vi.fn(async (path: string) => files[path] || ''),\n    editFile: vi.fn(async (path, oldStr, newStr) => {\n      if (files[path] && files[path].includes(oldStr)) {\n        files[path] = files[path].replace(oldStr, newStr);\n        return true;\n      }\n      return false;\n    }),\n    writeFile: vi.fn(async (path, content) => {\n      files[path] = content;\n      return true;\n    }),\n    deleteFile: vi.fn(async (path) => {\n      if (files[path]) {\n        delete files[path];\n        return true;\n      }\n      return false;\n    }),\n  };\n}\n\n// â”€â”€â”€ Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('FixExecutor', () => {\n  let executor: FixExecutor;\n  let bridge: ToolBridge;\n\n  beforeEach(() => {\n    bridge = createMockBridge();\n    executor = new FixExecutor(bridge);\n  });\n\n  // â”€â”€â”€ Basic Execution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('executePlan', () => {\n    it('should execute a read step', async () => {\n      const result = await executor.executePlan({\n        steps: [\n          {\n            type: 'read',\n            filePath: 'src/app.ts',\n            description: 'Read app file',\n          },\n        ],\n        protectedPaths: [],\n        maxFiles: 10,\n      });\n\n      expect(result.success).toBe(true);\n      expect(bridge.readFile).toHaveBeenCalledWith('src/app.ts');\n    });\n\n    it('should execute an edit step', async () => {\n      const result = await executor.executePlan({\n        steps: [\n          {\n            type: 'edit',\n            filePath: 'src/app.ts',\n            description: 'Change old value',\n            oldStr: 'const old = \"value\"',\n            newStr: 'const updated = \"new_value\"',\n          },\n        ],\n        protectedPaths: [],\n        maxFiles: 10,\n      });\n\n      expect(result.success).toBe(true);\n      expect(bridge.editFile).toHaveBeenCalled();\n      expect(result.filesModified).toContain('src/app.ts');\n    });\n\n    it('should execute steps in order', async () => {\n      const callOrder: string[] = [];\n\n      (bridge.readFile as any).mockImplementation(async (path: string) => {\n        callOrder.push(`read:${path}`);\n        return 'content';\n      });\n\n      (bridge.editFile as any).mockImplementation(async () => {\n        callOrder.push('edit');\n        return true;\n      });\n\n      await executor.executePlan({\n        steps: [\n          { type: 'read', filePath: 'src/app.ts', description: 'Read first' },\n          {\n            type: 'edit',\n            filePath: 'src/app.ts',\n            description: 'Edit',\n            oldStr: 'x',\n            newStr: 'y',\n          },\n          {\n            type: 'read',\n            filePath: 'src/utils.ts',\n            description: 'Read second',\n          },\n        ],\n        protectedPaths: [],\n        maxFiles: 10,\n      });\n\n      expect(callOrder).toEqual([\n        'read:src/app.ts',\n        'edit',\n        'read:src/utils.ts',\n      ]);\n    });\n  });\n\n  // â”€â”€â”€ Rollback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Rollback', () => {\n    it('should backup files before editing', async () => {\n      const result = await executor.executePlan({\n        steps: [\n          {\n            type: 'edit',\n            filePath: 'src/app.ts',\n            description: 'Edit app',\n            oldStr: 'const old = \"value\"',\n            newStr: 'const new_ = \"value\"',\n          },\n        ],\n        protectedPaths: [],\n        maxFiles: 10,\n      });\n\n      expect(result.backupData).toBeDefined();\n      expect(result.backupData.has('src/app.ts')).toBe(true);\n    });\n\n    it('should restore files on rollback', async () => {\n      const result = await executor.executePlan({\n        steps: [\n          {\n            type: 'edit',\n            filePath: 'src/app.ts',\n            description: 'Edit',\n            oldStr: 'const old = \"value\"',\n            newStr: 'BROKEN CODE',\n          },\n        ],\n        protectedPaths: [],\n        maxFiles: 10,\n      });\n\n      await executor.rollback(result.backupData);\n      expect(bridge.writeFile).toHaveBeenCalledWith(\n        'src/app.ts',\n        expect.stringContaining('const old = \"value\"'),\n        expect.any(String)\n      );\n    });\n  });\n\n  // â”€â”€â”€ Protected Paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Protected Paths', () => {\n    it('should skip editing protected files', async () => {\n      const result = await executor.executePlan({\n        steps: [\n          {\n            type: 'edit',\n            filePath: 'lib/agent/safety/index.ts',\n            description: 'Try to edit safety',\n            oldStr: 'SAFE',\n            newStr: 'UNSAFE',\n          },\n        ],\n        protectedPaths: ['lib/agent/safety'],\n        maxFiles: 10,\n      });\n\n      // Should not have called editFile for protected path\n      expect(bridge.editFile).not.toHaveBeenCalledWith(\n        'lib/agent/safety/index.ts',\n        expect.anything(),\n        expect.anything(),\n        expect.anything()\n      );\n    });\n  });\n\n  // â”€â”€â”€ Dry Run â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Dry Run', () => {\n    it('should not modify files in dry run mode', async () => {\n      const result = await executor.executePlan({\n        steps: [\n          {\n            type: 'edit',\n            filePath: 'src/app.ts',\n            description: 'Dry run edit',\n            oldStr: 'const old = \"value\"',\n            newStr: 'const dry = \"run\"',\n          },\n        ],\n        protectedPaths: [],\n        maxFiles: 10,\n        dryRun: true,\n      });\n\n      expect(result.success).toBe(true);\n      // In dry run, editFile should not be called (or called with dry flag)\n      // Implementation may vary â€” at minimum, no actual writes\n    });\n  });\n\n  // â”€â”€â”€ File Limits â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('File Limits', () => {\n    it('should respect maximum file limit', async () => {\n      const steps = Array.from({ length: 15 }, (_, i) => ({\n        type: 'edit' as const,\n        filePath: `src/file${i}.ts`,\n        description: `Edit file ${i}`,\n        oldStr: 'old',\n        newStr: 'new',\n      }));\n\n      const result = await executor.executePlan({\n        steps,\n        protectedPaths: [],\n        maxFiles: 3,\n      });\n\n      // Should stop after hitting file limit\n      expect(result.filesModified.length).toBeLessThanOrEqual(3);\n    });\n  });\n\n  // â”€â”€â”€ Error Handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Error Handling', () => {\n    it('should handle read failure gracefully', async () => {\n      (bridge.readFile as any).mockRejectedValueOnce(\n        new Error('File not found')\n      );\n\n      const result = await executor.executePlan({\n        steps: [\n          {\n            type: 'read',\n            filePath: 'nonexistent.ts',\n            description: 'Read missing',\n          },\n        ],\n        protectedPaths: [],\n        maxFiles: 10,\n      });\n\n      // Should handle error gracefully (not throw)\n      expect(result).toBeDefined();\n    });\n\n    it('should handle edit failure and continue', async () => {\n      (bridge.editFile as any).mockResolvedValueOnce(false);\n\n      const result = await executor.executePlan({\n        steps: [\n          {\n            type: 'edit',\n            filePath: 'src/app.ts',\n            description: 'Failed edit',\n            oldStr: 'NONEXISTENT STRING',\n            newStr: 'replacement',\n          },\n        ],\n        protectedPaths: [],\n        maxFiles: 10,\n      });\n\n      expect(result).toBeDefined();\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\__tests__\\integration-full-cycle.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 51,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 51,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1792, 1795], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1792, 1795], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 67,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 67,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2293, 2296], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2293, 2296], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 70,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 70,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2379, 2382], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2379, 2382], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 82,
        "column": 61,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 82,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2627, 2630], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2627, 2630], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 82,
        "column": 69,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 82,
        "endColumn": 72,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2635, 2638], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2635, 2638], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 108,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 108,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3328, 3331], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3328, 3331], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 112,
        "column": 54,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 112,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3463, 3466], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3463, 3466], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 185,
        "column": 71,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 185,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5726, 5729], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5726, 5729], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'originalContent' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 284,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 284,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 9,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Full Cycle Integration Tests\n * End-to-end tests that simulate a complete OODA improvement workflow.\n *\n * Tests: 12 total\n * - Full lifecycle:         3 tests (analyze â†’ start â†’ fix â†’ verify â†’ learn)\n * - Failure & recovery:     3 tests (verify fail â†’ retry, rollback, escalate)\n * - Concurrent cycles:      2 tests (parallel cycles, status tracking)\n * - Event integrity:        2 tests (event flow, phase ordering)\n * - Memory accumulation:    1 test  (patterns persist across cycles)\n * - Safety enforcement:     1 test  (protected paths through full chain)\n */\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\n\n// â”€â”€â”€ Mock Dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst mockFiles: Record<string, string> = {};\n\nfunction resetFiles() {\n  Object.keys(mockFiles).forEach((k) => delete mockFiles[k]);\n  Object.assign(mockFiles, {\n    'src/components/header.tsx': [\n      'import React from \"react\";',\n      'import { useTheme } from \"../hooks/useTheme\";',\n      '',\n      'export function Header() {',\n      '  const { theme } = useTheme();',\n      '  return <header className={`header ${theme}`}>CodeForge</header>;',\n      '}',\n    ].join('\\n'),\n    'src/hooks/useTheme.ts': [\n      'import { useState } from \"react\";',\n      '',\n      'export function useTheme() {',\n      '  const [theme, setTheme] = useState(\"dark\");',\n      '  return { theme, setTheme };',\n      '}',\n    ].join('\\n'),\n    'src/styles/main.css': [\n      '.header { padding: 1rem; }',\n      '.header.dark { background: #1a1a2e; color: #eee; }',\n      '.header.light { background: #fff; color: #333; }',\n    ].join('\\n'),\n    'lib/agent/safety/core.ts': 'export const IMMUTABLE = true;',\n  });\n}\n\n// Mock Task Store\nlet taskCounter = 0;\nconst tasks = new Map<string, any>();\n\nfunction makeTask(desc: string, cat: string) {\n  const id = `cycle-${++taskCounter}`;\n  const t = {\n    id,\n    status: 'running',\n    description: desc,\n    category: cat,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n    observation: { affectedArea: '', detectedFiles: [], evidence: [] },\n    orientation: { rootCause: '', scope: [], skills: [] },\n    decision: { plan: [], riskLevel: 'low', requiresApproval: false },\n    execution: {\n      status: 'pending',\n      changes: [] as any[],\n      iterations: 0,\n      maxIterations: 5,\n      verificationResult: null as any,\n      errors: [] as string[],\n    },\n  };\n  tasks.set(id, t);\n  return t;\n}\n\nvi.mock('../ooda-controller', () => ({\n  getOODAController: () => ({\n    startImprovement: vi\n      .fn()\n      .mockImplementation(async (_t: string, d: string, _f: any, o: any) =>\n        makeTask(d, o?.category || 'ui_bug')\n      ),\n    getTask: vi.fn().mockImplementation((id: string) => tasks.get(id) || null),\n    getActiveTasks: vi\n      .fn()\n      .mockImplementation(() =>\n        Array.from(tasks.values()).filter((t) => t.status === 'running')\n      ),\n    getHistory: vi\n      .fn()\n      .mockImplementation(() =>\n        Array.from(tasks.values()).filter((t) => t.status !== 'running')\n      ),\n    cancelTask: vi.fn().mockImplementation((id: string) => {\n      const t = tasks.get(id);\n      if (t) {\n        t.status = 'cancelled';\n        return true;\n      }\n      return false;\n    }),\n  }),\n  OODAController: vi.fn(),\n}));\n\nconst memoryPatterns: any[] = [];\n\nvi.mock('../learning-memory', () => ({\n  getLearningMemory: () => ({\n    recordSuccess: vi.fn().mockImplementation((task: any) => {\n      memoryPatterns.push({\n        id: `p-${memoryPatterns.length + 1}`,\n        problemSignature: task.description,\n        solution: 'fixed',\n        category: task.category || 'unknown',\n        successRate: 1.0,\n        timesUsed: 1,\n        filesInvolved: [],\n      });\n    }),\n    recordFailure: vi.fn(),\n    findSimilar: vi\n      .fn()\n      .mockImplementation((_d: string, limit: number) =>\n        memoryPatterns\n          .slice(0, limit)\n          .map((p) => ({ pattern: p, similarity: 0.5 }))\n      ),\n    getAllPatterns: vi.fn().mockImplementation(() => memoryPatterns),\n    findByCategory: vi.fn().mockReturnValue([]),\n    getStats: vi.fn().mockImplementation(() => ({\n      totalPatterns: memoryPatterns.length,\n      successfulPatterns: memoryPatterns.length,\n      topCategories: [],\n      topFiles: [],\n    })),\n  }),\n  LearningMemory: vi.fn(),\n}));\n\n// â”€â”€â”€ Import After Mocks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nimport { createOODAPhase3Executors } from '../ooda-tool-definitions';\nimport type { ToolBridge } from '../fix-executor';\n\n// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction makeBridge(): ToolBridge {\n  return {\n    readFile: vi.fn().mockImplementation(async (p: string) => {\n      if (mockFiles[p] === undefined) throw new Error(`Not found: ${p}`);\n      return mockFiles[p];\n    }),\n    editFile: vi\n      .fn()\n      .mockImplementation(async (p: string, old: string, neu: string) => {\n        if (!mockFiles[p] || !mockFiles[p].includes(old)) return false;\n        mockFiles[p] = mockFiles[p].replace(old, neu);\n        return true;\n      }),\n    writeFile: vi.fn().mockImplementation(async (p: string, c: string) => {\n      mockFiles[p] = c;\n      return true;\n    }),\n    deleteFile: vi.fn().mockImplementation(async (p: string) => {\n      delete mockFiles[p];\n      return true;\n    }),\n  };\n}\n\nfunction makeLoader() {\n  return vi.fn().mockImplementation(async () => {\n    const m = new Map<string, string>();\n    Object.entries(mockFiles).forEach(([k, v]) => m.set(k, v));\n    return m;\n  });\n}\n\n// â”€â”€â”€ Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('Full OODA Cycle â€” Integration', () => {\n  let exec: Record<string, (args: Record<string, unknown>) => Promise<any>>;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    resetFiles();\n    taskCounter = 0;\n    tasks.clear();\n    memoryPatterns.length = 0;\n    exec = createOODAPhase3Executors(makeBridge(), makeLoader());\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // Full Lifecycle\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('Full Lifecycle', () => {\n    it('should complete analyze â†’ start â†’ fix â†’ verify â†’ learn', async () => {\n      // 1. Start cycle\n      const startRes = await exec.ooda_start_cycle({\n        issue: 'Header not switching themes',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/header.tsx', 'src/hooks/useTheme.ts'],\n      });\n      expect(startRes.success).toBe(true);\n      const cycleId = startRes.data.cycleId;\n\n      // Mark task as having changes for verification\n      const task = tasks.get(cycleId);\n      task.execution.changes = [\n        { filePath: 'src/components/header.tsx', changeType: 'edit' },\n      ];\n\n      // 2. Execute fix\n      const fixRes = await exec.ooda_execute_fix({\n        cycleId,\n        fixes: [\n          {\n            filePath: 'src/components/header.tsx',\n            type: 'edit',\n            oldStr: 'className={`header ${theme}`}',\n            newStr: 'className={`header header--${theme}`}',\n            commitMessage: 'fix: theme class naming',\n          },\n        ],\n      });\n      expect(fixRes.success).toBe(true);\n      expect(fixRes.data.applied).toBe(1);\n\n      // 3. Verify fix\n      const verifyRes = await exec.ooda_verify_fix({ cycleId });\n      expect(verifyRes.success).toBe(true);\n      expect(verifyRes.data.overallPassed).toBe(true);\n      expect(verifyRes.data.recommendedAction).toBe('COMPLETE');\n\n      // 4. Learn pattern\n      const learnRes = await exec.ooda_learn_pattern({\n        cycleId,\n        pattern: {\n          description: 'Theme class naming inconsistency',\n          rootCause: 'Missing BEM convention for theme modifier',\n          fixApproach: 'Use header--{theme} instead of just {theme}',\n          tags: ['css', 'theme', 'bem', 'naming'],\n          confidence: 0.95,\n        },\n      });\n      expect(learnRes.success).toBe(true);\n      expect(learnRes.data.patternSaved).toBe(true);\n\n      // 5. Check status\n      const statusRes = await exec.ooda_get_status({ cycleId });\n      expect(statusRes.success).toBe(true);\n      expect(statusRes.data.cycleId).toBe(cycleId);\n    });\n\n    it('should reflect file changes after fix execution', async () => {\n      const startRes = await exec.ooda_start_cycle({\n        issue: 'CSS padding too large',\n        category: 'style',\n        affectedFiles: ['src/styles/main.css'],\n      });\n\n      await exec.ooda_execute_fix({\n        cycleId: startRes.data.cycleId,\n        fixes: [\n          {\n            filePath: 'src/styles/main.css',\n            type: 'edit',\n            oldStr: 'padding: 1rem',\n            newStr: 'padding: 0.5rem',\n            commitMessage: 'style: reduce header padding',\n          },\n        ],\n      });\n\n      expect(mockFiles['src/styles/main.css']).toContain('padding: 0.5rem');\n      expect(mockFiles['src/styles/main.css']).not.toContain('padding: 1rem');\n    });\n\n    it('should create backup before modifying files', async () => {\n      const originalContent = mockFiles['src/components/header.tsx'];\n\n      const startRes = await exec.ooda_start_cycle({\n        issue: 'Header rewrite needed',\n        category: 'feature_enhancement',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n\n      const fixRes = await exec.ooda_execute_fix({\n        cycleId: startRes.data.cycleId,\n        fixes: [\n          {\n            filePath: 'src/components/header.tsx',\n            type: 'rewrite',\n            content: 'export function Header() { return <h1>New</h1>; }',\n            commitMessage: 'refactor: simplify header',\n          },\n        ],\n      });\n\n      expect(fixRes.data.backupsCreated).toBeGreaterThan(0);\n      expect(fixRes.data.rollbackAvailable).toBe(true);\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // Failure & Recovery\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('Failure & Recovery', () => {\n    it('should recommend RETRY_FIX when 1-2 checks fail', async () => {\n      const startRes = await exec.ooda_start_cycle({\n        issue: 'Partial fix scenario',\n        category: 'logic_error',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n\n      const task = tasks.get(startRes.data.cycleId);\n      // Add a change to a file that doesn't exist â†’ exists check will fail\n      task.execution.changes = [\n        { filePath: 'src/components/header.tsx', changeType: 'edit' },\n        { filePath: 'src/nonexistent.tsx', changeType: 'edit' },\n      ];\n\n      const verifyRes = await exec.ooda_verify_fix({\n        cycleId: startRes.data.cycleId,\n      });\n      expect(verifyRes.success).toBe(true);\n      // With a mix of existing and non-existing files, some checks fail\n      expect(['RETRY_FIX', 'ESCALATE', 'COMPLETE']).toContain(\n        verifyRes.data.recommendedAction\n      );\n    });\n\n    it('should handle edit that finds no match gracefully', async () => {\n      const startRes = await exec.ooda_start_cycle({\n        issue: 'Bad edit target',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n\n      const fixRes = await exec.ooda_execute_fix({\n        cycleId: startRes.data.cycleId,\n        fixes: [\n          {\n            filePath: 'src/components/header.tsx',\n            type: 'edit',\n            oldStr: 'THIS STRING DOES NOT EXIST IN THE FILE',\n            newStr: 'replacement',\n            commitMessage: 'fix: bad match',\n          },\n        ],\n      });\n\n      // Fix should report failure for this specific file but not crash\n      expect(fixRes.data.results).toBeDefined();\n      expect(fixRes.data.results[0].success).toBe(false);\n    });\n\n    it('should return error for non-existent cycle', async () => {\n      const fixRes = await exec.ooda_execute_fix({\n        cycleId: 'nonexistent-cycle-id',\n        fixes: [\n          {\n            filePath: 'src/app.ts',\n            type: 'rewrite',\n            content: 'test',\n            commitMessage: 'test',\n          },\n        ],\n      });\n      expect(fixRes.success).toBe(false);\n      expect(fixRes.error).toContain('not found');\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // Concurrent Cycles\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('Concurrent Cycles', () => {\n    it('should track multiple cycles independently', async () => {\n      const cycle1 = await exec.ooda_start_cycle({\n        issue: 'Header bug',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n      const cycle2 = await exec.ooda_start_cycle({\n        issue: 'Theme performance',\n        category: 'performance',\n        affectedFiles: ['src/hooks/useTheme.ts'],\n      });\n\n      expect(cycle1.data.cycleId).not.toBe(cycle2.data.cycleId);\n\n      const status1 = await exec.ooda_get_status({\n        cycleId: cycle1.data.cycleId,\n      });\n      const status2 = await exec.ooda_get_status({\n        cycleId: cycle2.data.cycleId,\n      });\n\n      expect(status1.data.category).toBe('ui_bug');\n      expect(status2.data.category).toBe('performance');\n    });\n\n    it('should list all active cycles in status overview', async () => {\n      await exec.ooda_start_cycle({\n        issue: 'A',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n      await exec.ooda_start_cycle({\n        issue: 'B',\n        category: 'style',\n        affectedFiles: ['src/styles/main.css'],\n      });\n      await exec.ooda_start_cycle({\n        issue: 'C',\n        category: 'performance',\n        affectedFiles: ['src/hooks/useTheme.ts'],\n      });\n\n      const all = await exec.ooda_get_status({});\n      expect(all.data.activeCycles.length).toBe(3);\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // Event Integrity & Phase Order\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('Event Integrity', () => {\n    it('should produce consistent data between start and status', async () => {\n      const startRes = await exec.ooda_start_cycle({\n        issue: 'Consistency check',\n        category: 'accessibility',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n\n      const statusRes = await exec.ooda_get_status({\n        cycleId: startRes.data.cycleId,\n      });\n      expect(statusRes.data.cycleId).toBe(startRes.data.cycleId);\n      expect(statusRes.data.description).toContain('Consistency check');\n    });\n\n    it('should track elapsed time in status', async () => {\n      const startRes = await exec.ooda_start_cycle({\n        issue: 'Timing test',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n\n      // Small delay\n      await new Promise((r) => setTimeout(r, 50));\n\n      const statusRes = await exec.ooda_get_status({\n        cycleId: startRes.data.cycleId,\n      });\n      expect(statusRes.data.elapsedMs).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // Memory Accumulation\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('Memory Accumulation', () => {\n    it('should accumulate patterns across multiple cycles', async () => {\n      // Cycle 1\n      const c1 = await exec.ooda_start_cycle({\n        issue: 'Pattern 1',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n      await exec.ooda_learn_pattern({\n        cycleId: c1.data.cycleId,\n        pattern: {\n          description: 'First pattern',\n          rootCause: 'A',\n          fixApproach: 'B',\n          tags: ['first'],\n          confidence: 0.8,\n        },\n      });\n\n      // Cycle 2\n      const c2 = await exec.ooda_start_cycle({\n        issue: 'Pattern 2',\n        category: 'style',\n        affectedFiles: ['src/styles/main.css'],\n      });\n      const learnRes = await exec.ooda_learn_pattern({\n        cycleId: c2.data.cycleId,\n        pattern: {\n          description: 'Second pattern',\n          rootCause: 'C',\n          fixApproach: 'D',\n          tags: ['second'],\n          confidence: 0.9,\n        },\n      });\n\n      // Memory should have accumulated\n      expect(learnRes.data.totalPatternsInMemory).toBeGreaterThanOrEqual(2);\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // Safety Enforcement\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('Safety Enforcement', () => {\n    it('should block protected paths at every stage', async () => {\n      // Blocked at start\n      const startRes = await exec.ooda_start_cycle({\n        issue: 'Try to hack safety',\n        category: 'logic_error',\n        affectedFiles: ['lib/agent/safety/core.ts'],\n      });\n      expect(startRes.success).toBe(false);\n\n      // Start a valid cycle, then try to fix protected path\n      const validStart = await exec.ooda_start_cycle({\n        issue: 'Valid issue',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/header.tsx'],\n      });\n\n      const fixRes = await exec.ooda_execute_fix({\n        cycleId: validStart.data.cycleId,\n        fixes: [\n          {\n            filePath: '.env.local',\n            type: 'rewrite',\n            content: 'HACKED=true',\n            commitMessage: 'hack env',\n          },\n        ],\n      });\n      expect(fixRes.success).toBe(false);\n      expect(fixRes.error).toContain('protected');\n\n      // Verify safety file wasn't touched\n      expect(mockFiles['lib/agent/safety/core.ts']).toBe(\n        'export const IMMUTABLE = true;'\n      );\n      expect(mockFiles['.env.local']).toBe('API_KEY=secret');\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\__tests__\\integration-ooda-tools.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 225,
        "column": 48,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 225,
        "endColumn": 51,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6622, 6625], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6622, 6625], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” OODA Tools Integration Tests\n * Tests the 5 ooda_* tools end-to-end with mock dependencies.\n *\n * Tests: 18 total\n * - ooda_start_cycle:   3 tests (validation, protected paths, success)\n * - ooda_execute_fix:   5 tests (edit, rewrite, rollback, limits, protected)\n * - ooda_verify_fix:    4 tests (all checks, partial, syntax, protected)\n * - ooda_learn_pattern: 3 tests (save, confidence, similar)\n * - ooda_get_status:    3 tests (single, all, empty)\n */\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\n\n// â”€â”€â”€ Mock Dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst mockFiles: Record<string, string> = {};\n\nfunction resetMockFiles() {\n  Object.keys(mockFiles).forEach((k) => delete mockFiles[k]);\n  Object.assign(mockFiles, {\n    'src/components/sidebar.tsx': [\n      'import React from \"react\";',\n      'import { useStore } from \"../store\";',\n      '',\n      'export function Sidebar() {',\n      '  const { isOpen } = useStore();',\n      '  return <div className=\"sidebar\">{isOpen && <nav>Menu</nav>}</div>;',\n      '}',\n    ].join('\\n'),\n    'src/store/index.ts': [\n      'import { create } from \"zustand\";',\n      '',\n      'export const useStore = create((set) => ({',\n      '  isOpen: true,',\n      '  toggle: () => set((s) => ({ isOpen: !s.isOpen })),',\n      '}));',\n    ].join('\\n'),\n    'src/utils/helpers.ts': [\n      'export function clamp(val: number, min: number, max: number): number {',\n      '  return Math.min(Math.max(val, min), max);',\n      '}',\n    ].join('\\n'),\n    'lib/agent/safety/index.ts': 'export const SAFETY_ENABLED = true;',\n    '.env.local': 'API_KEY=secret',\n  });\n}\n\n// Mock OODAController\nlet taskIdCounter = 0;\nconst mockTasks = new Map();\n\nfunction createMockTask(description: string, category: string) {\n  const id = `ooda-${++taskIdCounter}`;\n  const task = {\n    id,\n    status: 'running',\n    description,\n    category,\n    createdAt: Date.now(),\n    updatedAt: Date.now(),\n    observation: {\n      affectedArea: 'src/components',\n      detectedFiles: ['src/components/sidebar.tsx'],\n      evidence: ['Bug in sidebar rendering'],\n    },\n    orientation: {\n      rootCause: 'Missing null check',\n      scope: ['src/components/sidebar.tsx'],\n      skills: ['react', 'typescript'],\n    },\n    decision: {\n      plan: [{ type: 'edit', file: 'src/components/sidebar.tsx' }],\n      riskLevel: 'low',\n      requiresApproval: false,\n    },\n    execution: {\n      status: 'pending',\n      changes: [] as Array<{ filePath: string; changeType: string }>,\n      iterations: 0,\n      maxIterations: 5,\n      verificationResult: null as { passed: boolean } | null,\n      errors: [] as string[],\n    },\n  };\n  mockTasks.set(id, task);\n  return task;\n}\n\nvi.mock('../ooda-controller', () => ({\n  getOODAController: () => ({\n    startImprovement: vi\n      .fn()\n      .mockImplementation(\n        async (\n          _trigger: string,\n          desc: string,\n          _files: Map<string, string>,\n          opts: { category?: string }\n        ) => {\n          return createMockTask(desc, opts?.category || 'ui_bug');\n        }\n      ),\n    getTask: vi\n      .fn()\n      .mockImplementation((id: string) => mockTasks.get(id) || null),\n    getActiveTasks: vi\n      .fn()\n      .mockImplementation(() =>\n        Array.from(mockTasks.values()).filter((t) => t.status === 'running')\n      ),\n    getHistory: vi\n      .fn()\n      .mockImplementation(() =>\n        Array.from(mockTasks.values()).filter((t) => t.status !== 'running')\n      ),\n    cancelTask: vi.fn().mockImplementation((id: string) => {\n      const task = mockTasks.get(id);\n      if (task) {\n        task.status = 'cancelled';\n        return true;\n      }\n      return false;\n    }),\n  }),\n  OODAController: vi.fn(),\n}));\n\n// Mock LearningMemory\nconst storedPatterns: Array<{\n  id: string;\n  problemSignature: string;\n  solution: string;\n  category: string;\n  successRate: number;\n  timesUsed: number;\n  filesInvolved: string[];\n}> = [];\n\nvi.mock('../learning-memory', () => ({\n  getLearningMemory: () => ({\n    recordSuccess: vi\n      .fn()\n      .mockImplementation((task: { description: string }) => {\n        storedPatterns.push({\n          id: `pattern-${storedPatterns.length + 1}`,\n          problemSignature: task.description,\n          solution: 'auto-resolved',\n          category: 'ui_bug',\n          successRate: 1.0,\n          timesUsed: 1,\n          filesInvolved: [],\n        });\n      }),\n    recordFailure: vi.fn(),\n    findSimilar: vi.fn().mockImplementation((desc: string, limit: number) => {\n      return storedPatterns\n        .filter((p) => p.problemSignature.includes(desc.split(' ')[0]))\n        .slice(0, limit)\n        .map((p) => ({ pattern: p, similarity: 0.7 }));\n    }),\n    getAllPatterns: vi.fn().mockImplementation(() => storedPatterns),\n    findByCategory: vi.fn().mockReturnValue([]),\n    getStats: vi.fn().mockReturnValue({\n      totalPatterns: storedPatterns.length,\n      successfulPatterns: storedPatterns.length,\n      topCategories: [],\n      topFiles: [],\n    }),\n  }),\n  LearningMemory: vi.fn(),\n}));\n\n// â”€â”€â”€ Import Executors After Mocks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nimport { createOODAPhase3Executors } from '../ooda-tool-definitions';\nimport type { ToolBridge } from '../fix-executor';\n\n// â”€â”€â”€ Test Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction createToolBridge(): ToolBridge {\n  return {\n    readFile: vi.fn().mockImplementation(async (path: string) => {\n      if (mockFiles[path] === undefined)\n        throw new Error(`File not found: ${path}`);\n      return mockFiles[path];\n    }),\n    editFile: vi\n      .fn()\n      .mockImplementation(\n        async (path: string, oldStr: string, newStr: string) => {\n          if (!mockFiles[path] || !mockFiles[path].includes(oldStr))\n            return false;\n          mockFiles[path] = mockFiles[path].replace(oldStr, newStr);\n          return true;\n        }\n      ),\n    writeFile: vi\n      .fn()\n      .mockImplementation(async (path: string, content: string) => {\n        mockFiles[path] = content;\n        return true;\n      }),\n    deleteFile: vi.fn().mockImplementation(async (path: string) => {\n      if (!mockFiles[path]) return false;\n      delete mockFiles[path];\n      return true;\n    }),\n  };\n}\n\nfunction createFileLoader() {\n  return vi.fn().mockImplementation(async () => {\n    const map = new Map<string, string>();\n    for (const [k, v] of Object.entries(mockFiles)) {\n      map.set(k, v);\n    }\n    return map;\n  });\n}\n\ndescribe('OODA Phase 3 Tools â€” Integration', () => {\n  let executors: Record<\n    string,\n    (args: Record<string, unknown>) => Promise<any>\n  >;\n  let bridge: ToolBridge;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    resetMockFiles();\n    taskIdCounter = 0;\n    mockTasks.clear();\n    storedPatterns.length = 0;\n    bridge = createToolBridge();\n    executors = createOODAPhase3Executors(bridge, createFileLoader());\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // ooda_start_cycle\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('ooda_start_cycle', () => {\n    it('should reject when required params are missing', async () => {\n      const result = await executors.ooda_start_cycle({});\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('Required');\n    });\n\n    it('should reject when affected files include protected paths', async () => {\n      const result = await executors.ooda_start_cycle({\n        issue: 'Fix safety module',\n        category: 'logic_error',\n        affectedFiles: ['lib/agent/safety/index.ts', 'src/app.ts'],\n      });\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('protected');\n    });\n\n    it('should start a cycle successfully with valid params', async () => {\n      const result = await executors.ooda_start_cycle({\n        issue: 'Sidebar not rendering correctly',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/sidebar.tsx'],\n      });\n      expect(result.success).toBe(true);\n      expect(result.data.cycleId).toBeDefined();\n      expect(result.data.phase).toBe('observe');\n      expect(result.data.message).toContain('OODA cycle started');\n      expect(result.data.timeout).toBe('30 minutes');\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // ooda_execute_fix\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('ooda_execute_fix', () => {\n    let cycleId: string;\n\n    beforeEach(async () => {\n      const startResult = await executors.ooda_start_cycle({\n        issue: 'Bug in sidebar',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/sidebar.tsx'],\n      });\n      cycleId = startResult.data.cycleId;\n    });\n\n    it('should reject when params are missing', async () => {\n      const result = await executors.ooda_execute_fix({});\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('Required');\n    });\n\n    it('should execute an edit fix successfully', async () => {\n      const result = await executors.ooda_execute_fix({\n        cycleId,\n        fixes: [\n          {\n            filePath: 'src/components/sidebar.tsx',\n            type: 'edit',\n            oldStr: 'className=\"sidebar\"',\n            newStr: 'className=\"sidebar sidebar--fixed\"',\n            commitMessage: 'fix: add fixed class to sidebar',\n          },\n        ],\n      });\n      expect(result.success).toBe(true);\n      expect(result.data.applied).toBe(1);\n      expect(result.data.failed).toBe(0);\n      expect(mockFiles['src/components/sidebar.tsx']).toContain(\n        'sidebar--fixed'\n      );\n    });\n\n    it('should execute a rewrite fix successfully', async () => {\n      const newContent =\n        'export function Sidebar() { return <div>New Sidebar</div>; }';\n      const result = await executors.ooda_execute_fix({\n        cycleId,\n        fixes: [\n          {\n            filePath: 'src/components/sidebar.tsx',\n            type: 'rewrite',\n            content: newContent,\n            commitMessage: 'refactor: rewrite sidebar component',\n          },\n        ],\n      });\n      expect(result.success).toBe(true);\n      expect(mockFiles['src/components/sidebar.tsx']).toBe(newContent);\n    });\n\n    it('should reject fixes to protected paths', async () => {\n      const result = await executors.ooda_execute_fix({\n        cycleId,\n        fixes: [\n          {\n            filePath: 'lib/agent/safety/index.ts',\n            type: 'rewrite',\n            content: 'HACKED',\n            commitMessage: 'hack safety',\n          },\n        ],\n      });\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('protected');\n    });\n\n    it('should reject when fixes exceed 10 file limit', async () => {\n      const fixes = Array.from({ length: 11 }, (_, i) => ({\n        filePath: `src/file${i}.ts`,\n        type: 'rewrite' as const,\n        content: `file ${i}`,\n        commitMessage: `fix file ${i}`,\n      }));\n      const result = await executors.ooda_execute_fix({ cycleId, fixes });\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('10');\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // ooda_verify_fix\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('ooda_verify_fix', () => {\n    let cycleId: string;\n\n    beforeEach(async () => {\n      const startResult = await executors.ooda_start_cycle({\n        issue: 'Verify test',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/sidebar.tsx'],\n      });\n      cycleId = startResult.data.cycleId;\n\n      // Add a change to the task so verification has something to check\n      const task = mockTasks.get(cycleId);\n      if (task) {\n        task.execution.changes = [\n          { filePath: 'src/components/sidebar.tsx', changeType: 'edit' },\n        ];\n      }\n    });\n\n    it('should reject when cycleId is missing', async () => {\n      const result = await executors.ooda_verify_fix({});\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('Required');\n    });\n\n    it('should run all 6 checks by default', async () => {\n      const result = await executors.ooda_verify_fix({ cycleId });\n      expect(result.success).toBe(true);\n      expect(result.data.results.length).toBeGreaterThanOrEqual(5);\n\n      const checkTypes = result.data.results.map(\n        (r: { check: string }) => r.check.split(':')[0]\n      );\n      expect(checkTypes).toContain('exists');\n      expect(checkTypes).toContain('content');\n      expect(checkTypes).toContain('imports');\n      expect(checkTypes).toContain('protected');\n      expect(checkTypes).toContain('syntax');\n    });\n\n    it('should run only specified checks', async () => {\n      const result = await executors.ooda_verify_fix({\n        cycleId,\n        checks: ['exists', 'protected'],\n      });\n      expect(result.success).toBe(true);\n      const checkTypes = result.data.results.map(\n        (r: { check: string }) => r.check.split(':')[0]\n      );\n      expect(checkTypes).toContain('exists');\n      expect(checkTypes).toContain('protected');\n      expect(checkTypes).not.toContain('syntax');\n    });\n\n    it('should detect balanced braces in syntax check', async () => {\n      // Sidebar has balanced braces\n      const result = await executors.ooda_verify_fix({\n        cycleId,\n        checks: ['syntax'],\n      });\n      expect(result.success).toBe(true);\n      const syntaxCheck = result.data.results.find((r: { check: string }) =>\n        r.check.startsWith('syntax')\n      );\n      expect(syntaxCheck?.passed).toBe(true);\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // ooda_learn_pattern\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('ooda_learn_pattern', () => {\n    let cycleId: string;\n\n    beforeEach(async () => {\n      const startResult = await executors.ooda_start_cycle({\n        issue: 'Learning test',\n        category: 'style',\n        affectedFiles: ['src/components/sidebar.tsx'],\n      });\n      cycleId = startResult.data.cycleId;\n    });\n\n    it('should reject when params are missing', async () => {\n      const result = await executors.ooda_learn_pattern({});\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('Required');\n    });\n\n    it('should reject invalid confidence range', async () => {\n      const result = await executors.ooda_learn_pattern({\n        cycleId,\n        pattern: {\n          description: 'Test',\n          rootCause: 'Test',\n          fixApproach: 'Test',\n          tags: ['test'],\n          confidence: 1.5,\n        },\n      });\n      expect(result.success).toBe(false);\n      expect(result.error).toContain('confidence');\n    });\n\n    it('should save pattern successfully and report total', async () => {\n      const result = await executors.ooda_learn_pattern({\n        cycleId,\n        pattern: {\n          description: 'CSS class order matters for RTL layouts',\n          rootCause: 'Missing RTL class on sidebar',\n          fixApproach: 'Add dir-aware CSS classes',\n          tags: ['css', 'rtl', 'sidebar'],\n          confidence: 0.9,\n        },\n      });\n      expect(result.success).toBe(true);\n      expect(result.data.patternSaved).toBe(true);\n      expect(result.data.confidence).toBe('90%');\n      expect(result.data.message).toContain('Pattern saved');\n    });\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // ooda_get_status\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  describe('ooda_get_status', () => {\n    it('should return empty state when no cycles exist', async () => {\n      const result = await executors.ooda_get_status({});\n      expect(result.success).toBe(true);\n      expect(result.data.activeCycles).toEqual([]);\n    });\n\n    it('should return specific cycle status', async () => {\n      const startResult = await executors.ooda_start_cycle({\n        issue: 'Status test',\n        category: 'performance',\n        affectedFiles: ['src/utils/helpers.ts'],\n      });\n      const cycleId = startResult.data.cycleId;\n\n      const result = await executors.ooda_get_status({ cycleId });\n      expect(result.success).toBe(true);\n      expect(result.data.cycleId).toBe(cycleId);\n      expect(result.data.status).toBeDefined();\n      expect(result.data.category).toBe('performance');\n    });\n\n    it('should return all active cycles when no cycleId given', async () => {\n      await executors.ooda_start_cycle({\n        issue: 'Cycle 1',\n        category: 'ui_bug',\n        affectedFiles: ['src/components/sidebar.tsx'],\n      });\n      await executors.ooda_start_cycle({\n        issue: 'Cycle 2',\n        category: 'style',\n        affectedFiles: ['src/utils/helpers.ts'],\n      });\n\n      const result = await executors.ooda_get_status({});\n      expect(result.success).toBe(true);\n      expect(result.data.activeCycles.length).toBe(2);\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\__tests__\\integration-tool-registry.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\__tests__\\learning-memory.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'afterEach' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 14,
        "column": 48,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 14,
        "endColumn": 57
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Learning Memory Tests\n * Unit tests for the persistent pattern storage system.\n *\n * Tests cover:\n * - Recording successful patterns\n * - Recording failures and confidence reduction\n * - Similarity search (Jaccard)\n * - Pruning when exceeding max patterns\n * - Statistics aggregation\n * - localStorage persistence\n */\n\nimport { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\n\n// â”€â”€â”€ Mock localStorage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst mockStorage: Record<string, string> = {};\n\nconst localStorageMock = {\n  getItem: vi.fn((key: string) => mockStorage[key] || null),\n  setItem: vi.fn((key: string, value: string) => {\n    mockStorage[key] = value;\n  }),\n  removeItem: vi.fn((key: string) => {\n    delete mockStorage[key];\n  }),\n  clear: vi.fn(() => {\n    Object.keys(mockStorage).forEach((k) => delete mockStorage[k]);\n  }),\n  length: 0,\n  key: vi.fn(() => null),\n};\n\nObject.defineProperty(globalThis, 'localStorage', {\n  value: localStorageMock,\n  writable: true,\n});\n\n// â”€â”€â”€ Import after mock â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nimport { LearningMemory } from '../learning-memory';\n\n// â”€â”€â”€ Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('LearningMemory', () => {\n  let memory: LearningMemory;\n\n  beforeEach(() => {\n    localStorageMock.clear();\n    memory = new LearningMemory();\n  });\n\n  // â”€â”€â”€ Recording Success â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('recordSuccess', () => {\n    it('should store a successful pattern', () => {\n      memory.recordSuccess({\n        category: 'ui_bug',\n        description: 'Fixed button alignment',\n        filesModified: ['components/button.tsx'],\n        fixSteps: ['edit CSS flex property'],\n        issueKeywords: ['button', 'alignment', 'css'],\n      });\n\n      const stats = memory.getStats();\n      expect(stats.totalPatterns).toBe(1);\n      expect(stats.successfulPatterns).toBe(1);\n    });\n\n    it('should increment use count for existing pattern', () => {\n      const patternData = {\n        category: 'ui_bug',\n        description: 'Fixed button alignment',\n        filesModified: ['components/button.tsx'],\n        fixSteps: ['edit CSS'],\n        issueKeywords: ['button', 'alignment'],\n      };\n\n      memory.recordSuccess(patternData);\n      memory.recordSuccess(patternData);\n\n      const patterns = memory.findSimilar(['button', 'alignment']);\n      expect(patterns.length).toBeGreaterThan(0);\n    });\n  });\n\n  // â”€â”€â”€ Recording Failure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('recordFailure', () => {\n    it('should decrease confidence of matching pattern', () => {\n      memory.recordSuccess({\n        category: 'logic_error',\n        description: 'Fixed null check',\n        filesModified: ['lib/utils.ts'],\n        fixSteps: ['add null guard'],\n        issueKeywords: ['null', 'undefined', 'error'],\n      });\n\n      memory.recordFailure({\n        category: 'logic_error',\n        issueKeywords: ['null', 'undefined', 'error'],\n      });\n\n      const patterns = memory.findSimilar(['null', 'error']);\n      if (patterns.length > 0) {\n        expect(patterns[0].successRate).toBeLessThan(1.0);\n      }\n    });\n  });\n\n  // â”€â”€â”€ Similarity Search â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('findSimilar', () => {\n    beforeEach(() => {\n      memory.recordSuccess({\n        category: 'ui_bug',\n        description: 'Fixed sidebar collapse',\n        filesModified: ['components/sidebar.tsx'],\n        fixSteps: ['update state'],\n        issueKeywords: ['sidebar', 'collapse', 'toggle', 'ui'],\n      });\n\n      memory.recordSuccess({\n        category: 'logic_error',\n        description: 'Fixed API timeout',\n        filesModified: ['lib/api.ts'],\n        fixSteps: ['increase timeout'],\n        issueKeywords: ['api', 'timeout', 'network', 'error'],\n      });\n\n      memory.recordSuccess({\n        category: 'ui_bug',\n        description: 'Fixed sidebar width',\n        filesModified: ['components/sidebar.tsx', 'styles/sidebar.css'],\n        fixSteps: ['adjust CSS width'],\n        issueKeywords: ['sidebar', 'width', 'css', 'ui'],\n      });\n    });\n\n    it('should return patterns sorted by similarity', () => {\n      const results = memory.findSimilar(['sidebar', 'ui', 'collapse']);\n      expect(results.length).toBeGreaterThan(0);\n      // The sidebar collapse pattern should be most similar\n      expect(results[0].description).toContain('sidebar');\n    });\n\n    it('should return empty array for unrelated keywords', () => {\n      const results = memory.findSimilar(['database', 'migration', 'sql']);\n      // Either empty or very low similarity\n      expect(results.every((r) => r.successRate !== undefined)).toBe(true);\n    });\n\n    it('should limit results count', () => {\n      const results = memory.findSimilar(['sidebar'], 1);\n      expect(results.length).toBeLessThanOrEqual(1);\n    });\n  });\n\n  // â”€â”€â”€ Pruning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Pruning', () => {\n    it('should prune when exceeding max patterns', () => {\n      // Record more than 100 patterns\n      for (let i = 0; i < 110; i++) {\n        memory.recordSuccess({\n          category: `cat_${i}`,\n          description: `Pattern ${i}`,\n          filesModified: [`file_${i}.ts`],\n          fixSteps: [`step ${i}`],\n          issueKeywords: [`keyword_${i}`],\n        });\n      }\n\n      const stats = memory.getStats();\n      expect(stats.totalPatterns).toBeLessThanOrEqual(100);\n    });\n  });\n\n  // â”€â”€â”€ Statistics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('getStats', () => {\n    it('should return correct statistics', () => {\n      memory.recordSuccess({\n        category: 'ui_bug',\n        description: 'Fix 1',\n        filesModified: ['a.ts', 'b.ts'],\n        fixSteps: ['step'],\n        issueKeywords: ['bug'],\n      });\n\n      memory.recordSuccess({\n        category: 'ui_bug',\n        description: 'Fix 2',\n        filesModified: ['a.ts'],\n        fixSteps: ['step'],\n        issueKeywords: ['bug'],\n      });\n\n      memory.recordSuccess({\n        category: 'logic_error',\n        description: 'Fix 3',\n        filesModified: ['c.ts'],\n        fixSteps: ['step'],\n        issueKeywords: ['error'],\n      });\n\n      const stats = memory.getStats();\n      expect(stats.totalPatterns).toBe(3);\n      expect(stats.topCategories.length).toBeGreaterThan(0);\n      expect(stats.topFiles.length).toBeGreaterThan(0);\n\n      // ui_bug should be the top category (2 patterns)\n      const topCat = stats.topCategories[0];\n      expect(topCat.category).toBe('ui_bug');\n      expect(topCat.count).toBe(2);\n    });\n\n    it('should return empty stats for fresh memory', () => {\n      const stats = memory.getStats();\n      expect(stats.totalPatterns).toBe(0);\n      expect(stats.topCategories).toEqual([]);\n      expect(stats.topFiles).toEqual([]);\n    });\n  });\n\n  // â”€â”€â”€ Persistence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Persistence', () => {\n    it('should save to localStorage on recordSuccess', () => {\n      memory.recordSuccess({\n        category: 'test',\n        description: 'Persist test',\n        filesModified: ['test.ts'],\n        fixSteps: ['step'],\n        issueKeywords: ['persist'],\n      });\n\n      expect(localStorageMock.setItem).toHaveBeenCalled();\n    });\n\n    it('should load from localStorage on construction', () => {\n      // Store a pattern\n      memory.recordSuccess({\n        category: 'persist_test',\n        description: 'Should survive reload',\n        filesModified: ['test.ts'],\n        fixSteps: ['step'],\n        issueKeywords: ['reload'],\n      });\n\n      // Create a new instance (simulates page reload)\n      const memory2 = new LearningMemory();\n      const stats = memory2.getStats();\n      expect(stats.totalPatterns).toBeGreaterThan(0);\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\__tests__\\ooda-controller.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 165,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 165,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4908, 4911], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4908, 4911], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” OODA Controller Tests\n * Unit tests for the OODAController orchestration logic.\n *\n * Tests cover:\n * - Task lifecycle (create â†’ observe â†’ orient â†’ decide â†’ act â†’ verify)\n * - Event emission at each phase\n * - Approval gate for high-risk tasks\n * - Cancellation mid-execution\n * - Iteration limits\n * - Error handling and rollback triggers\n */\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\n\n// â”€â”€â”€ Mock Dependencies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n// Mock SelfAnalysisEngine\nconst mockAnalyzeComponent = vi.fn().mockReturnValue({\n  filePath: 'test/file.ts',\n  componentName: 'TestComponent',\n  type: 'service',\n  lineCount: 100,\n  estimatedComplexity: 'medium',\n  exports: [{ name: 'TestComponent', type: 'class', isDefault: true }],\n  imports: [],\n  dependencies: [],\n  dependents: [],\n});\n\nconst mockFindRelatedFiles = vi.fn().mockReturnValue([\n  { path: 'test/file.ts', score: 0.9, reason: 'direct match' },\n  { path: 'test/helper.ts', score: 0.5, reason: 'related import' },\n]);\n\nconst mockTraceDependencies = vi.fn().mockReturnValue({\n  upstream: ['lib/utils.ts'],\n  downstream: ['components/app.tsx'],\n  circularDeps: [],\n});\n\nconst mockBuildProjectMap = vi.fn().mockReturnValue({\n  totalFiles: 50,\n  totalFolders: 10,\n  filesByExtension: { ts: 30, tsx: 15, css: 5 },\n  dependencyGraph: {},\n  entryPoints: ['app/page.tsx'],\n  configFiles: ['tsconfig.json'],\n  componentFiles: [],\n});\n\nvi.mock('../self-analysis-engine', () => ({\n  getSelfAnalysisEngine: () => ({\n    analyzeComponent: mockAnalyzeComponent,\n    findRelatedFiles: mockFindRelatedFiles,\n    traceDependencies: mockTraceDependencies,\n    buildProjectMap: mockBuildProjectMap,\n  }),\n  SelfAnalysisEngine: vi.fn(),\n}));\n\n// Mock FixExecutor\nconst mockExecutePlan = vi.fn().mockResolvedValue({\n  success: true,\n  filesModified: ['test/file.ts'],\n  backupData: new Map([['test/file.ts', 'original content']]),\n});\n\nconst mockRollback = vi.fn().mockResolvedValue(undefined);\n\nvi.mock('../fix-executor', () => ({\n  FixExecutor: vi.fn().mockImplementation(() => ({\n    executePlan: mockExecutePlan,\n    rollback: mockRollback,\n  })),\n}));\n\n// Mock VerificationEngine\nconst mockVerify = vi.fn().mockReturnValue({\n  passed: true,\n  score: 1.0,\n  checks: [\n    { name: 'file_existence', passed: true, message: 'All files exist' },\n    { name: 'import_validity', passed: true, message: 'All imports valid' },\n    { name: 'export_consistency', passed: true, message: 'Exports consistent' },\n    { name: 'syntax_sanity', passed: true, message: 'Syntax OK' },\n  ],\n  failedChecks: [],\n});\n\nvi.mock('../verification-engine', () => ({\n  VerificationEngine: vi.fn().mockImplementation(() => ({\n    verify: mockVerify,\n  })),\n}));\n\n// Mock LearningMemory\nconst mockRecordSuccess = vi.fn();\nconst mockRecordFailure = vi.fn();\nconst mockFindSimilar = vi.fn().mockReturnValue([]);\nconst mockGetStats = vi.fn().mockReturnValue({\n  totalPatterns: 0,\n  successfulPatterns: 0,\n  topCategories: [],\n  topFiles: [],\n});\n\nvi.mock('../learning-memory', () => ({\n  getLearningMemory: () => ({\n    recordSuccess: mockRecordSuccess,\n    recordFailure: mockRecordFailure,\n    findSimilar: mockFindSimilar,\n    getStats: mockGetStats,\n  }),\n  LearningMemory: vi.fn(),\n}));\n\n// â”€â”€â”€ Import after mocks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nimport { OODAController } from '../ooda-controller';\nimport type { OODAEvent } from '../ooda-controller';\n\n// â”€â”€â”€ Test Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction createMockFileLoader(): () => Promise<Map<string, string>> {\n  return vi.fn().mockResolvedValue(\n    new Map([\n      ['test/file.ts', 'export class TestComponent { /* bug here */ }'],\n      ['test/helper.ts', 'export function helper() { return true; }'],\n      ['lib/utils.ts', 'export const CONST = 42;'],\n      ['components/app.tsx', 'import { TestComponent } from \"../test/file\";'],\n    ])\n  );\n}\n\nfunction createMockToolBridge() {\n  return {\n    readFile: vi.fn().mockImplementation(async (path: string) => {\n      const files: Record<string, string> = {\n        'test/file.ts': 'export class TestComponent { /* bug here */ }',\n        'test/helper.ts': 'export function helper() { return true; }',\n      };\n      return files[path] || '';\n    }),\n    editFile: vi.fn().mockResolvedValue(true),\n    writeFile: vi.fn().mockResolvedValue(true),\n    deleteFile: vi.fn().mockResolvedValue(true),\n  };\n}\n\n// â”€â”€â”€ Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('OODAController', () => {\n  let controller: OODAController;\n  let fileLoader: ReturnType<typeof createMockFileLoader>;\n  let toolBridge: ReturnType<typeof createMockToolBridge>;\n  let collectedEvents: OODAEvent[];\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    fileLoader = createMockFileLoader();\n    toolBridge = createMockToolBridge();\n    collectedEvents = [];\n\n    controller = new OODAController(toolBridge as any, fileLoader);\n\n    // Subscribe to events\n    controller.on((event: OODAEvent) => {\n      collectedEvents.push(event);\n    });\n  });\n\n  // â”€â”€â”€ Task Lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Task Lifecycle', () => {\n    it('should create a task and return a task ID', () => {\n      const taskId = controller.startTask('Fix bug in TestComponent');\n      expect(taskId).toBeDefined();\n      expect(typeof taskId).toBe('string');\n      expect(taskId.length).toBeGreaterThan(0);\n    });\n\n    it('should emit events for each OODA phase', async () => {\n      controller.startTask('Fix bug in TestComponent');\n\n      // Wait for async execution\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      const phases = collectedEvents.map((e) => e.phase);\n      expect(phases).toContain('observe');\n      expect(phases).toContain('orient');\n      expect(phases).toContain('decide');\n      expect(phases).toContain('act');\n      expect(phases).toContain('verify');\n    });\n\n    it('should call analyzeComponent during observe phase', async () => {\n      controller.startTask('Fix bug in test/file.ts');\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      expect(mockFindRelatedFiles).toHaveBeenCalled();\n      expect(mockAnalyzeComponent).toHaveBeenCalled();\n    });\n\n    it('should call traceDependencies during orient phase', async () => {\n      controller.startTask('Fix bug in test/file.ts');\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      expect(mockTraceDependencies).toHaveBeenCalled();\n    });\n\n    it('should execute fix plan during act phase', async () => {\n      controller.startTask('Fix bug in test/file.ts');\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      expect(mockExecutePlan).toHaveBeenCalled();\n    });\n\n    it('should verify changes during verify phase', async () => {\n      controller.startTask('Fix bug in test/file.ts');\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      expect(mockVerify).toHaveBeenCalled();\n    });\n\n    it('should record success in learning memory on completion', async () => {\n      controller.startTask('Fix bug in test/file.ts');\n      await new Promise((resolve) => setTimeout(resolve, 100));\n\n      expect(mockRecordSuccess).toHaveBeenCalled();\n    });\n  });\n\n  // â”€â”€â”€ Task Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Task Status', () => {\n    it('should return null for unknown task ID', () => {\n      const status = controller.getTaskStatus('nonexistent-id');\n      expect(status).toBeNull();\n    });\n\n    it('should return task info for valid task ID', () => {\n      const taskId = controller.startTask('Test task');\n      const status = controller.getTaskStatus(taskId);\n      expect(status).toBeDefined();\n      expect(status!.id).toBe(taskId);\n      expect(status!.description).toBe('Test task');\n    });\n  });\n\n  // â”€â”€â”€ Cancellation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Cancellation', () => {\n    it('should cancel a running task', () => {\n      const taskId = controller.startTask('Task to cancel');\n      const cancelled = controller.cancelTask(taskId);\n      expect(cancelled).toBe(true);\n    });\n\n    it('should return false for cancelling non-existent task', () => {\n      const cancelled = controller.cancelTask('nonexistent');\n      expect(cancelled).toBe(false);\n    });\n\n    it('should emit cancellation event', () => {\n      const taskId = controller.startTask('Task to cancel');\n      controller.cancelTask(taskId);\n\n      const cancelEvent = collectedEvents.find(\n        (e) =>\n          e.type === 'cancelled' ||\n          e.message.includes('cancel') ||\n          e.message.includes('Ø¥Ù„ØºØ§Ø¡')\n      );\n      expect(cancelEvent).toBeDefined();\n    });\n  });\n\n  // â”€â”€â”€ Verification Failure & Retry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Verification Failure', () => {\n    it('should retry on verification failure', async () => {\n      // First call fails, second succeeds\n      mockVerify\n        .mockReturnValueOnce({\n          passed: false,\n          score: 0.5,\n          checks: [],\n          failedChecks: [\n            {\n              name: 'import_validity',\n              passed: false,\n              message: 'Broken import',\n            },\n          ],\n        })\n        .mockReturnValue({\n          passed: true,\n          score: 1.0,\n          checks: [],\n          failedChecks: [],\n        });\n\n      controller.startTask('Fix with retry');\n      await new Promise((resolve) => setTimeout(resolve, 200));\n\n      // Should have called verify at least 2 times\n      expect(mockVerify.mock.calls.length).toBeGreaterThanOrEqual(2);\n    });\n\n    it('should record failure after max iterations', async () => {\n      // Always fail verification\n      mockVerify.mockReturnValue({\n        passed: false,\n        score: 0.2,\n        checks: [],\n        failedChecks: [\n          { name: 'syntax_sanity', passed: false, message: 'Syntax error' },\n        ],\n      });\n\n      controller.startTask('Failing task');\n      await new Promise((resolve) => setTimeout(resolve, 500));\n\n      expect(mockRecordFailure).toHaveBeenCalled();\n    });\n  });\n\n  // â”€â”€â”€ Event System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Event System', () => {\n    it('should support multiple event listeners', () => {\n      const events1: OODAEvent[] = [];\n      const events2: OODAEvent[] = [];\n\n      controller.on((e) => events1.push(e));\n      controller.on((e) => events2.push(e));\n\n      controller.startTask('Multi-listener test');\n\n      // Both listeners should receive events (plus the original from beforeEach)\n      expect(events1.length).toBeGreaterThan(0);\n      expect(events2.length).toBeGreaterThan(0);\n    });\n\n    it('should support unsubscribing from events', () => {\n      const extraEvents: OODAEvent[] = [];\n      const unsubscribe = controller.on((e) => extraEvents.push(e));\n\n      controller.startTask('Unsub test');\n      const countBefore = extraEvents.length;\n\n      unsubscribe();\n      controller.startTask('After unsub');\n\n      // No new events after unsubscribe\n      expect(extraEvents.length).toBe(countBefore);\n    });\n  });\n\n  // â”€â”€â”€ Edge Cases â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Edge Cases', () => {\n    it('should handle empty task description gracefully', () => {\n      const taskId = controller.startTask('');\n      expect(taskId).toBeDefined();\n    });\n\n    it('should prevent starting a task while another is running', () => {\n      controller.startTask('First task');\n      // Second task should either queue or reject\n      const secondId = controller.startTask('Second task');\n      // Implementation may vary â€” just verify it doesn't crash\n      expect(secondId).toBeDefined();\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\__tests__\\verification-engine.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'vi' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 15,
        "column": 32,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 15,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Verification Engine Tests\n * Unit tests for the 7-check post-execution verification system.\n *\n * Tests cover:\n * - File existence verification\n * - Import validity checking\n * - Export consistency\n * - Protected path enforcement\n * - Scope integrity\n * - Syntax sanity (bracket balance)\n * - Downstream impact detection\n */\n\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\n\n// â”€â”€â”€ Mock Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n// We'll test VerificationEngine with controlled inputs\nimport { VerificationEngine } from '../verification-engine';\n\n// â”€â”€â”€ Test Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction createFileMap(files: Record<string, string>): Map<string, string> {\n  return new Map(Object.entries(files));\n}\n\n// â”€â”€â”€ Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('VerificationEngine', () => {\n  let engine: VerificationEngine;\n\n  beforeEach(() => {\n    engine = new VerificationEngine();\n  });\n\n  // â”€â”€â”€ File Existence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('File Existence Check', () => {\n    it('should pass when all modified files exist', () => {\n      const allFiles = createFileMap({\n        'src/app.ts': 'export const app = true;',\n        'src/utils.ts': 'export const util = 1;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts', 'src/utils.ts'],\n        declaredScope: ['src/app.ts', 'src/utils.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const fileCheck = result.checks.find((c) => c.name === 'file_existence');\n      expect(fileCheck?.passed).toBe(true);\n    });\n\n    it('should fail when a modified file does not exist', () => {\n      const allFiles = createFileMap({\n        'src/app.ts': 'export const app = true;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts', 'src/missing.ts'],\n        declaredScope: ['src/app.ts', 'src/missing.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const fileCheck = result.checks.find((c) => c.name === 'file_existence');\n      expect(fileCheck?.passed).toBe(false);\n    });\n  });\n\n  // â”€â”€â”€ Import Validity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Import Validity Check', () => {\n    it('should pass when all local imports resolve', () => {\n      const allFiles = createFileMap({\n        'src/app.ts':\n          'import { util } from \"./utils\";\\nexport const app = util;',\n        'src/utils.ts': 'export const util = 1;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const importCheck = result.checks.find(\n        (c) => c.name === 'import_validity'\n      );\n      expect(importCheck?.passed).toBe(true);\n    });\n\n    it('should fail when a local import does not resolve', () => {\n      const allFiles = createFileMap({\n        'src/app.ts':\n          'import { util } from \"./nonexistent\";\\nexport const app = util;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const importCheck = result.checks.find(\n        (c) => c.name === 'import_validity'\n      );\n      expect(importCheck?.passed).toBe(false);\n    });\n\n    it('should ignore npm package imports', () => {\n      const allFiles = createFileMap({\n        'src/app.ts':\n          'import React from \"react\";\\nimport { v4 } from \"uuid\";\\nexport const app = true;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const importCheck = result.checks.find(\n        (c) => c.name === 'import_validity'\n      );\n      expect(importCheck?.passed).toBe(true);\n    });\n  });\n\n  // â”€â”€â”€ Protected Paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Protected Paths Check', () => {\n    it('should pass when no protected paths are modified', () => {\n      const allFiles = createFileMap({\n        'src/app.ts': 'export const app = true;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: ['lib/agent/safety'],\n      });\n\n      const protectedCheck = result.checks.find(\n        (c) => c.name === 'protected_paths'\n      );\n      expect(protectedCheck?.passed).toBe(true);\n    });\n\n    it('should fail when a protected path is modified', () => {\n      const allFiles = createFileMap({\n        'lib/agent/safety/index.ts': 'export const safety = true;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['lib/agent/safety/index.ts'],\n        declaredScope: ['lib/agent/safety/index.ts'],\n        allFiles,\n        protectedPaths: ['lib/agent/safety'],\n      });\n\n      const protectedCheck = result.checks.find(\n        (c) => c.name === 'protected_paths'\n      );\n      expect(protectedCheck?.passed).toBe(false);\n    });\n  });\n\n  // â”€â”€â”€ Scope Integrity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Scope Integrity Check', () => {\n    it('should pass when all modifications are within declared scope', () => {\n      const allFiles = createFileMap({\n        'src/app.ts': 'export const app = true;',\n        'src/utils.ts': 'export const util = 1;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts', 'src/utils.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const scopeCheck = result.checks.find(\n        (c) => c.name === 'scope_integrity'\n      );\n      expect(scopeCheck?.passed).toBe(true);\n    });\n\n    it('should fail when modifications are outside declared scope', () => {\n      const allFiles = createFileMap({\n        'src/app.ts': 'export const app = true;',\n        'src/secret.ts': 'export const secret = true;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts', 'src/secret.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const scopeCheck = result.checks.find(\n        (c) => c.name === 'scope_integrity'\n      );\n      expect(scopeCheck?.passed).toBe(false);\n    });\n  });\n\n  // â”€â”€â”€ Syntax Sanity â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Syntax Sanity Check', () => {\n    it('should pass with balanced brackets', () => {\n      const allFiles = createFileMap({\n        'src/app.ts':\n          'function test() {\\n  if (true) {\\n    return [1, 2, 3];\\n  }\\n}',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const syntaxCheck = result.checks.find((c) => c.name === 'syntax_sanity');\n      expect(syntaxCheck?.passed).toBe(true);\n    });\n\n    it('should fail with unbalanced brackets', () => {\n      const allFiles = createFileMap({\n        'src/app.ts':\n          'function test() {\\n  if (true) {\\n    return [1, 2, 3;\\n  }\\n}',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const syntaxCheck = result.checks.find((c) => c.name === 'syntax_sanity');\n      expect(syntaxCheck?.passed).toBe(false);\n    });\n\n    it('should ignore brackets inside strings', () => {\n      const allFiles = createFileMap({\n        'src/app.ts':\n          'const str = \"this has {unbalanced brackets\";\\nfunction test() { return str; }',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      const syntaxCheck = result.checks.find((c) => c.name === 'syntax_sanity');\n      expect(syntaxCheck?.passed).toBe(true);\n    });\n  });\n\n  // â”€â”€â”€ Overall Result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  describe('Overall Result', () => {\n    it('should pass overall when all checks pass', () => {\n      const allFiles = createFileMap({\n        'src/app.ts': 'export const app = true;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      expect(result.passed).toBe(true);\n      expect(result.score).toBeGreaterThan(0.5);\n    });\n\n    it('should fail overall when any critical check fails', () => {\n      const allFiles = createFileMap({\n        'lib/agent/safety/index.ts': 'modified!',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['lib/agent/safety/index.ts'],\n        declaredScope: ['lib/agent/safety/index.ts'],\n        allFiles,\n        protectedPaths: ['lib/agent/safety'],\n      });\n\n      expect(result.passed).toBe(false);\n    });\n\n    it('should return score between 0 and 1', () => {\n      const allFiles = createFileMap({\n        'src/app.ts': 'export const app = true;',\n      });\n\n      const result = engine.verify({\n        modifiedFiles: ['src/app.ts'],\n        declaredScope: ['src/app.ts'],\n        allFiles,\n        protectedPaths: [],\n      });\n\n      expect(result.score).toBeGreaterThanOrEqual(0);\n      expect(result.score).toBeLessThanOrEqual(1);\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\fix-executor.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 98,
        "column": 37,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 98,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2302, 2305], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2302, 2305], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 241,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 241,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6547, 6550], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6547, 6550], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 243,
        "column": 27,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 243,
        "endColumn": 30,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6593, 6596], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6593, 6596], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Fix Executor\n * Converts a fix plan (FixStep[]) into actual tool commands.\n * Handles file reading, editing, creation, and rollback.\n *\n * Phase 2: OODA Loop Implementation.\n */\n\nimport type { FixStep, FileChange } from './types';\nimport { getSelfAnalysisEngine } from './self-analysis-engine';\n\n// â”€â”€â”€ Tool Bridge Interface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface ToolBridge {\n  readFile(filePath: string, branch?: string): Promise<string>;\n  editFile(\n    filePath: string,\n    oldStr: string,\n    newStr: string,\n    commitMessage?: string,\n    branch?: string\n  ): Promise<boolean>;\n  writeFile(\n    filePath: string,\n    content: string,\n    commitMessage?: string,\n    branch?: string\n  ): Promise<boolean>;\n  deleteFile(\n    filePath: string,\n    commitMessage?: string,\n    branch?: string\n  ): Promise<boolean>;\n}\n\n// â”€â”€â”€ Execution Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface ExecutionOptions {\n  protectedPaths: string[];\n  maxFiles: number;\n  dryRun?: boolean;\n  branch?: string;\n}\n\n// â”€â”€â”€ Plan Input (flat object form) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface PlanInput {\n  steps: PlanStep[];\n  protectedPaths: string[];\n  maxFiles: number;\n  dryRun?: boolean;\n  branch?: string;\n}\n\nexport interface PlanStep {\n  type: string;\n  filePath: string;\n  description: string;\n  oldStr?: string;\n  newStr?: string;\n}\n\n// â”€â”€â”€ Execution Result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface ExecutionResult {\n  success: boolean;\n  filesModified: string[];\n  backupData: Map<string, string>;\n  errors: string[];\n  changes: FileChange[];\n}\n\n// â”€â”€â”€ Fix Executor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport class FixExecutor {\n  private toolBridge: ToolBridge;\n  private rollbackStack: FileChange[] = [];\n\n  constructor(toolBridge: ToolBridge) {\n    this.toolBridge = toolBridge;\n  }\n\n  async executePlan(\n    planOrInput:\n      | FixStep[]\n      | PlanInput\n      | Record<string, unknown>\n      | undefined\n      | null,\n    allFiles?: Map<string, string>,\n    options?: ExecutionOptions\n  ): Promise<ExecutionResult | FileChange[]> {\n    if (\n      planOrInput &&\n      typeof planOrInput === 'object' &&\n      !Array.isArray(planOrInput) &&\n      'steps' in planOrInput &&\n      Array.isArray((planOrInput as any).steps) &&\n      'protectedPaths' in planOrInput\n    ) {\n      return this.executePlanFlat(planOrInput as PlanInput);\n    }\n\n    return this.executePlanLegacy(planOrInput, allFiles!, options!);\n  }\n\n  private async executePlanFlat(input: PlanInput): Promise<ExecutionResult> {\n    const backupData = new Map<string, string>();\n    const readCache = new Map<string, string>();\n    const filesModified: string[] = [];\n    const errors: string[] = [];\n    const changes: FileChange[] = [];\n    let filesModifiedCount = 0;\n\n    for (const step of input.steps) {\n      const filePath = step.filePath;\n      const action = step.type;\n\n      if (this.isProtected(filePath, input.protectedPaths)) {\n        continue;\n      }\n\n      if (\n        (action === 'edit' || action === 'create' || action === 'delete') &&\n        filesModifiedCount >= input.maxFiles\n      ) {\n        continue;\n      }\n\n      try {\n        if (action === 'read') {\n          const content = await this.toolBridge.readFile(filePath);\n          readCache.set(filePath, content);\n        } else if (action === 'edit') {\n          if (readCache.has(filePath)) {\n            backupData.set(filePath, readCache.get(filePath)!);\n          } else {\n            try {\n              const currentContent = await this.toolBridge.readFile(filePath);\n              readCache.set(filePath, currentContent);\n              backupData.set(filePath, currentContent);\n            } catch {\n              // File might not exist yet\n            }\n          }\n\n          if (input.dryRun) {\n            // Dry run â€” don't actually edit\n          } else {\n            const oldStr = step.oldStr || '';\n            const newStr = step.newStr || '';\n            const success = await this.toolBridge.editFile(\n              filePath,\n              oldStr,\n              newStr\n            );\n            if (success && !filesModified.includes(filePath)) {\n              filesModified.push(filePath);\n              filesModifiedCount++;\n            }\n          }\n\n          changes.push({\n            filePath,\n            changeType: 'modify',\n            oldContent: backupData.get(filePath),\n            timestamp: Date.now(),\n          });\n        } else if (action === 'create') {\n          if (!input.dryRun) {\n            await this.toolBridge.writeFile(filePath, step.newStr || '');\n            if (!filesModified.includes(filePath)) {\n              filesModified.push(filePath);\n              filesModifiedCount++;\n            }\n          }\n          changes.push({\n            filePath,\n            changeType: 'create',\n            timestamp: Date.now(),\n          });\n        } else if (action === 'delete') {\n          if (readCache.has(filePath)) {\n            backupData.set(filePath, readCache.get(filePath)!);\n          } else {\n            try {\n              const currentContent = await this.toolBridge.readFile(filePath);\n              backupData.set(filePath, currentContent);\n            } catch {\n              /* ignore */\n            }\n          }\n\n          if (!input.dryRun) {\n            await this.toolBridge.deleteFile(filePath);\n            if (!filesModified.includes(filePath)) {\n              filesModified.push(filePath);\n              filesModifiedCount++;\n            }\n          }\n          changes.push({\n            filePath,\n            changeType: 'delete',\n            oldContent: backupData.get(filePath),\n            timestamp: Date.now(),\n          });\n        }\n      } catch (error) {\n        errors.push(`${action} ${filePath}: ${(error as Error).message}`);\n        continue;\n      }\n    }\n\n    this.rollbackStack = changes;\n\n    return {\n      success: errors.length === 0,\n      filesModified,\n      backupData,\n      errors,\n      changes,\n    };\n  }\n\n  private async executePlanLegacy(\n    plan: FixStep[] | Record<string, unknown> | undefined | null,\n    allFiles: Map<string, string>,\n    options: ExecutionOptions\n  ): Promise<FileChange[]> {\n    const changes: FileChange[] = [];\n    this.rollbackStack = [];\n    let filesModified = 0;\n\n    let safePlan: FixStep[];\n    if (Array.isArray(plan)) {\n      safePlan = plan;\n    } else if (\n      plan &&\n      typeof plan === 'object' &&\n      'steps' in plan &&\n      Array.isArray((plan as any).steps)\n    ) {\n      safePlan = (plan as any).steps;\n    } else if (plan && typeof plan === 'object') {\n      safePlan = [plan as unknown as FixStep];\n    } else {\n      safePlan = [];\n    }\n\n    const sortedPlan = [...safePlan].sort(\n      (a, b) => (a.order ?? 0) - (b.order ?? 0)\n    );\n\n    for (const step of sortedPlan) {\n      if (step.completed) continue;\n\n      if (this.isProtected(step.target, options.protectedPaths)) {\n        step.completed = true;\n        step.result = `SKIPPED â€” ${step.target} is a protected path`;\n        continue;\n      }\n\n      if (\n        (step.action === 'edit' ||\n          step.action === 'create' ||\n          step.action === 'delete') &&\n        filesModified >= options.maxFiles\n      ) {\n        step.completed = true;\n        step.result = `SKIPPED â€” max file limit (${options.maxFiles}) reached`;\n        continue;\n      }\n\n      try {\n        const change = await this.executeStep(step, allFiles, options);\n        if (change) {\n          changes.push(change);\n          this.rollbackStack.push(change);\n          if (\n            change.changeType !== 'modify' ||\n            change.newContent !== change.oldContent\n          ) {\n            filesModified++;\n          }\n        }\n        step.completed = true;\n      } catch (error) {\n        step.completed = true;\n        step.result = `ERROR: ${(error as Error).message}`;\n        continue;\n      }\n    }\n\n    return changes;\n  }\n\n  async rollback(\n    backupOrOptions?: Map<string, string> | ExecutionOptions\n  ): Promise<number> {\n    let rolledBack = 0;\n\n    if (backupOrOptions instanceof Map) {\n      for (const [filePath, content] of backupOrOptions) {\n        try {\n          await this.toolBridge.writeFile(\n            filePath,\n            content,\n            `rollback: Restore ${filePath.split('/').pop()} to pre-fix state`\n          );\n          rolledBack++;\n        } catch (error) {\n          console.error(\n            `Rollback failed for ${filePath}: ${(error as Error).message}`\n          );\n        }\n      }\n      return rolledBack;\n    }\n\n    const stack = [...this.rollbackStack].reverse();\n    const branch = (backupOrOptions as ExecutionOptions)?.branch;\n\n    for (const change of stack) {\n      try {\n        if (change.changeType === 'modify' && change.oldContent !== undefined) {\n          await this.toolBridge.writeFile(\n            change.filePath,\n            change.oldContent,\n            `rollback: Restore ${change.filePath.split('/').pop()} to pre-fix state`,\n            branch\n          );\n          rolledBack++;\n        } else if (change.changeType === 'create') {\n          await this.toolBridge.deleteFile(\n            change.filePath,\n            `rollback: Remove ${change.filePath.split('/').pop()} (created during fix)`,\n            branch\n          );\n          rolledBack++;\n        } else if (\n          change.changeType === 'delete' &&\n          change.oldContent !== undefined\n        ) {\n          await this.toolBridge.writeFile(\n            change.filePath,\n            change.oldContent,\n            `rollback: Restore deleted ${change.filePath.split('/').pop()}`,\n            branch\n          );\n          rolledBack++;\n        }\n      } catch (error) {\n        console.error(\n          `Rollback failed for ${change.filePath}: ${(error as Error).message}`\n        );\n      }\n    }\n\n    this.rollbackStack = [];\n    return rolledBack;\n  }\n\n  getRollbackStack(): FileChange[] {\n    return [...this.rollbackStack];\n  }\n\n  // â”€â”€â”€ Private: Step Execution (Legacy) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private async executeStep(\n    step: FixStep,\n    allFiles: Map<string, string>,\n    options: ExecutionOptions\n  ): Promise<FileChange | null> {\n    switch (step.action) {\n      case 'read':\n        return this.executeRead(step, allFiles, options);\n      case 'analyze':\n        return this.executeAnalyze(step, allFiles);\n      case 'edit':\n        return this.executeEdit(step, allFiles, options);\n      case 'create':\n        return this.executeCreate(step, allFiles, options);\n      case 'delete':\n        return this.executeDelete(step, allFiles, options);\n      case 'verify':\n        step.result = 'Verification delegated to VerificationEngine';\n        return null;\n      default:\n        step.result = `Unknown action: ${step.action}`;\n        return null;\n    }\n  }\n\n  private async executeRead(\n    step: FixStep,\n    allFiles: Map<string, string>,\n    options: ExecutionOptions\n  ): Promise<FileChange | null> {\n    let content = allFiles.get(step.target);\n    if (!content) {\n      content = await this.toolBridge.readFile(step.target, options.branch);\n      allFiles.set(step.target, content);\n    }\n    step.result = `Read ${content.length} characters from ${step.target}`;\n    return null;\n  }\n\n  private async executeAnalyze(\n    step: FixStep,\n    allFiles: Map<string, string>\n  ): Promise<FileChange | null> {\n    const engine = getSelfAnalysisEngine();\n    const content = allFiles.get(step.target);\n    if (content) {\n      const analysis = engine.analyzeComponent(step.target, content);\n      step.result = `Analyzed: type=${analysis.type}, complexity=${analysis.estimatedComplexity}, deps=${analysis.dependencies.length}`;\n    } else {\n      step.result = `Cannot analyze â€” file not found: ${step.target}`;\n    }\n    return null;\n  }\n\n  private async executeEdit(\n    step: FixStep,\n    allFiles: Map<string, string>,\n    options: ExecutionOptions\n  ): Promise<FileChange> {\n    const oldContent = allFiles.get(step.target);\n    if (!oldContent) {\n      throw new Error(\n        `Cannot edit ${step.target} â€” file not loaded. Read it first.`\n      );\n    }\n\n    if (options.dryRun) {\n      step.result = `DRY RUN â€” would edit ${step.target}`;\n      return {\n        filePath: step.target,\n        changeType: 'modify',\n        oldContent,\n        newContent: oldContent,\n        timestamp: Date.now(),\n      };\n    }\n\n    step.result = `Edit prepared for ${step.target} â€” agent will provide specific changes`;\n    return {\n      filePath: step.target,\n      changeType: 'modify',\n      oldContent,\n      timestamp: Date.now(),\n    };\n  }\n\n  private async executeCreate(\n    step: FixStep,\n    allFiles: Map<string, string>,\n    options: ExecutionOptions\n  ): Promise<FileChange> {\n    if (options.dryRun) {\n      step.result = `DRY RUN â€” would create ${step.target}`;\n      return {\n        filePath: step.target,\n        changeType: 'create',\n        timestamp: Date.now(),\n      };\n    }\n    step.result = `Create prepared for ${step.target} â€” agent will provide content`;\n    return {\n      filePath: step.target,\n      changeType: 'create',\n      timestamp: Date.now(),\n    };\n  }\n\n  private async executeDelete(\n    step: FixStep,\n    allFiles: Map<string, string>,\n    options: ExecutionOptions\n  ): Promise<FileChange> {\n    const oldContent = allFiles.get(step.target);\n    if (options.dryRun) {\n      step.result = `DRY RUN â€” would delete ${step.target}`;\n      return {\n        filePath: step.target,\n        changeType: 'delete',\n        oldContent,\n        timestamp: Date.now(),\n      };\n    }\n    step.result = `Delete prepared for ${step.target} â€” requires user confirmation`;\n    return {\n      filePath: step.target,\n      changeType: 'delete',\n      oldContent,\n      timestamp: Date.now(),\n    };\n  }\n\n  private isProtected(filePath: string, protectedPaths: string[]): boolean {\n    return protectedPaths.some((p) => filePath.startsWith(p) || filePath === p);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\learning-memory.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 200,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 200,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5525, 5528], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5525, 5528], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 201,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 201,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5579, 5582], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5579, 5582], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 254,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 254,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7016, 7019], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7016, 7019], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 273,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 273,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7733, 7736], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7733, 7736], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 321,
        "column": 23,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 321,
        "endColumn": 26,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9090, 9093], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9090, 9093], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 402,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 402,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11232, 11235], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11232, 11235], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 412,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 412,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11463, 11466], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11463, 11466], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Learning Memory\n * Persists successful fix patterns for future reference.\n * Allows the agent to learn from past self-improvement tasks.\n *\n * Phase 2: OODA Loop Implementation.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport type {\n  SelfImprovementTask,\n  FixPattern,\n  SelfImproveStats,\n  IssueCategory,\n} from './types';\n\n// â”€â”€â”€ Storage Key â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst STORAGE_KEY = 'codeforge-self-improve-memory';\nconst MAX_PATTERNS = 100;\n\n// â”€â”€â”€ Direct Pattern Input (used by unit tests) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface PatternInput {\n  category: string;\n  description: string;\n  filesModified: string[];\n  fixSteps: string[];\n  issueKeywords: string[];\n}\n\nexport interface FailureInput {\n  category: string;\n  issueKeywords: string[];\n}\n\n// â”€â”€â”€ Extended Stats Interface â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface ExtendedSelfImproveStats extends SelfImproveStats {\n  totalPatterns: number;\n  successfulPatterns: number;\n  topCategories: Array<{ category: IssueCategory; count: number }>;\n  topFiles: Array<{ path: string; count: number }>;\n}\n\n// â”€â”€â”€ Learning Memory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport class LearningMemory {\n  private patterns: FixPattern[] = [];\n  private loaded: boolean = false;\n\n  constructor() {\n    this.load();\n  }\n\n  // â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /**\n   * Record a successful pattern. Accepts either:\n   *   1. PatternInput (flat: { category, description, filesModified, fixSteps, issueKeywords })\n   *   2. SelfImprovementTask (legacy)\n   */\n  recordSuccess(input: PatternInput | SelfImprovementTask): FixPattern | null {\n    // â”€â”€ Detect flat PatternInput form â”€â”€\n    if (this.isPatternInput(input)) {\n      return this.recordSuccessFlat(input);\n    }\n\n    // â”€â”€ Legacy SelfImprovementTask form â”€â”€\n    return this.recordSuccessLegacy(input as SelfImprovementTask);\n  }\n\n  /**\n   * Record a failure. Accepts either:\n   *   1. FailureInput (flat: { category, issueKeywords })\n   *   2. SelfImprovementTask (legacy)\n   */\n  recordFailure(input: FailureInput | SelfImprovementTask): void {\n    if (this.isFailureInput(input)) {\n      return this.recordFailureFlat(input);\n    }\n\n    return this.recordFailureLegacy(input as SelfImprovementTask);\n  }\n\n  /**\n   * Find similar patterns. Accepts either:\n   *   1. string[] keywords array\n   *   2. string description (legacy)\n   */\n  findSimilar(\n    input: string[] | string | undefined | null,\n    maxResults: number = 5\n  ): Array<{\n    pattern?: FixPattern;\n    similarity?: number;\n    description: string;\n    successRate: number;\n  }> {\n    if (Array.isArray(input)) {\n      return this.findSimilarByKeywords(input, maxResults);\n    }\n    return this.findSimilarByDescription(input, maxResults);\n  }\n\n  findByCategory(category: IssueCategory): FixPattern[] {\n    return this.patterns\n      .filter((p) => p.category === category)\n      .sort((a, b) => b.successRate - a.successRate);\n  }\n\n  getStats(): ExtendedSelfImproveStats {\n    const fileModCounts: Record<string, number> = {};\n    const categoryCounts: Record<string, number> = {};\n\n    for (const pattern of this.patterns) {\n      for (const file of pattern.filesInvolved) {\n        fileModCounts[file] = (fileModCounts[file] || 0) + pattern.timesUsed;\n      }\n      categoryCounts[pattern.category] =\n        (categoryCounts[pattern.category] || 0) + 1;\n    }\n\n    const totalTasks = this.patterns.reduce((sum, p) => sum + p.timesUsed, 0);\n    const completedTasks = this.patterns.reduce(\n      (sum, p) => sum + Math.round(p.timesUsed * p.successRate),\n      0\n    );\n\n    const mostModifiedFiles = Object.entries(fileModCounts)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10)\n      .map(([path, count]) => ({ path, count }));\n\n    const commonCategories = Object.entries(categoryCounts)\n      .sort(([, a], [, b]) => b - a)\n      .map(([category, count]) => ({\n        category: category as IssueCategory,\n        count,\n      }));\n\n    const successfulPatterns = this.patterns.filter(\n      (p) => p.successRate > 0.5\n    ).length;\n\n    return {\n      totalTasks,\n      completedTasks,\n      failedTasks: totalTasks - completedTasks,\n      averageIterations: 0,\n      mostModifiedFiles,\n      commonCategories,\n      totalPatterns: this.patterns.length,\n      successfulPatterns,\n      topCategories: commonCategories,\n      topFiles: mostModifiedFiles,\n    };\n  }\n\n  getAllPatterns(): FixPattern[] {\n    return [...this.patterns];\n  }\n\n  clear(): void {\n    this.patterns = [];\n    this.save();\n  }\n\n  // â”€â”€â”€ Flat Form: recordSuccess â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private recordSuccessFlat(input: PatternInput): FixPattern {\n    const signature = [input.category, ...input.issueKeywords].join(' | ');\n\n    const existing = this.findExactMatch(signature);\n    if (existing) {\n      existing.timesUsed++;\n      existing.lastUsed = Date.now();\n      existing.successRate = Math.min(\n        1.0,\n        (existing.successRate * (existing.timesUsed - 1) + 1) /\n          existing.timesUsed\n      );\n      this.save();\n      return existing;\n    }\n\n    const pattern: FixPattern = {\n      id: uuidv4(),\n      problemSignature: signature,\n      category: input.category as IssueCategory,\n      solution: input.fixSteps.join(', '),\n      filesInvolved: input.filesModified,\n      successRate: 1.0,\n      timesUsed: 1,\n      lastUsed: Date.now(),\n      createdAt: Date.now(),\n    };\n\n    // Store keywords in the problemSignature for similarity search\n    (pattern as any)._keywords = input.issueKeywords;\n    (pattern as any)._description = input.description;\n\n    this.patterns.push(pattern);\n\n    if (this.patterns.length > MAX_PATTERNS) {\n      this.prunePatterns();\n    }\n\n    this.save();\n    return pattern;\n  }\n\n  // â”€â”€â”€ Flat Form: recordFailure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private recordFailureFlat(input: FailureInput): void {\n    // Find best matching pattern by keywords\n    const matches = this.findSimilarByKeywords(input.issueKeywords, 1);\n    if (matches.length > 0 && matches[0].pattern) {\n      const pattern = matches[0].pattern;\n      pattern.timesUsed++;\n      pattern.successRate = Math.max(\n        0,\n        (pattern.successRate * (pattern.timesUsed - 1)) / pattern.timesUsed\n      );\n      pattern.lastUsed = Date.now();\n      this.save();\n    }\n  }\n\n  // â”€â”€â”€ Flat Form: findSimilar by keywords â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private findSimilarByKeywords(\n    keywords: string[],\n    maxResults: number\n  ): Array<{\n    pattern: FixPattern;\n    similarity: number;\n    description: string;\n    successRate: number;\n  }> {\n    const inputSet = new Set(keywords.map((k) => k.toLowerCase()));\n    const results: Array<{\n      pattern: FixPattern;\n      similarity: number;\n      description: string;\n      successRate: number;\n    }> = [];\n\n    for (const pattern of this.patterns) {\n      // Get keywords from pattern\n      const patternKeywords = new Set<string>();\n\n      // From stored _keywords\n      const storedKw = (pattern as any)._keywords as string[] | undefined;\n      if (storedKw) {\n        storedKw.forEach((k) => patternKeywords.add(k.toLowerCase()));\n      }\n\n      // From problemSignature\n      const sigWords = this.extractKeywords(pattern.problemSignature);\n      sigWords.forEach((k) => patternKeywords.add(k));\n\n      // From category\n      patternKeywords.add(pattern.category.toLowerCase());\n\n      // Calculate Jaccard similarity\n      const intersection = [...inputSet].filter((k) => patternKeywords.has(k));\n      const union = new Set([...inputSet, ...patternKeywords]);\n      const similarity = union.size > 0 ? intersection.length / union.size : 0;\n\n      if (similarity > 0) {\n        const desc =\n          (pattern as any)._description ||\n          pattern.solution ||\n          pattern.problemSignature;\n        results.push({\n          pattern,\n          similarity,\n          description: desc,\n          successRate: pattern.successRate,\n        });\n      }\n    }\n\n    return results\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, maxResults);\n  }\n\n  // â”€â”€â”€ Legacy Form: findSimilar by description â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private findSimilarByDescription(\n    description: string | undefined | null,\n    maxResults: number\n  ): Array<{\n    pattern: FixPattern;\n    similarity: number;\n    description: string;\n    successRate: number;\n  }> {\n    const descKeywords = this.extractKeywords(description);\n    const results: Array<{\n      pattern: FixPattern;\n      similarity: number;\n      description: string;\n      successRate: number;\n    }> = [];\n\n    for (const pattern of this.patterns) {\n      const patternKeywords = this.extractKeywords(pattern.problemSignature);\n\n      const intersection = descKeywords.filter((k) =>\n        patternKeywords.includes(k)\n      );\n      const union = new Set([...descKeywords, ...patternKeywords]);\n      const similarity = union.size > 0 ? intersection.length / union.size : 0;\n      const score = similarity * 0.7 + pattern.successRate * 0.3;\n\n      if (score > 0.15) {\n        const desc =\n          (pattern as any)._description ||\n          pattern.solution ||\n          pattern.problemSignature;\n        results.push({\n          pattern,\n          similarity: score,\n          description: desc,\n          successRate: pattern.successRate,\n        });\n      }\n    }\n\n    return results\n      .sort((a, b) => b.similarity - a.similarity)\n      .slice(0, maxResults);\n  }\n\n  // â”€â”€â”€ Legacy Form: recordSuccess â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private recordSuccessLegacy(task: SelfImprovementTask): FixPattern | null {\n    if (task.status !== 'completed') return null;\n    if (!task.execution?.verificationResult?.passed) return null;\n\n    const signature = this.buildSignature(task);\n\n    const existing = this.findExactMatch(signature);\n    if (existing) {\n      existing.timesUsed++;\n      existing.lastUsed = Date.now();\n      existing.successRate = Math.min(\n        1.0,\n        (existing.successRate * (existing.timesUsed - 1) + 1) /\n          existing.timesUsed\n      );\n      this.save();\n      return existing;\n    }\n\n    const changes = task.execution?.changes || [];\n\n    const pattern: FixPattern = {\n      id: uuidv4(),\n      problemSignature: signature,\n      category: task.category,\n      solution: this.buildSolutionSummary(task),\n      filesInvolved: changes.map((c) => c.filePath),\n      successRate: 1.0,\n      timesUsed: 1,\n      lastUsed: Date.now(),\n      createdAt: Date.now(),\n    };\n\n    this.patterns.push(pattern);\n\n    if (this.patterns.length > MAX_PATTERNS) {\n      this.prunePatterns();\n    }\n\n    this.save();\n    return pattern;\n  }\n\n  // â”€â”€â”€ Legacy Form: recordFailure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private recordFailureLegacy(task: SelfImprovementTask): void {\n    const signature = this.buildSignature(task);\n    const existing = this.findExactMatch(signature);\n\n    if (existing) {\n      existing.timesUsed++;\n      existing.successRate = Math.max(\n        0,\n        (existing.successRate * (existing.timesUsed - 1)) / existing.timesUsed\n      );\n      existing.lastUsed = Date.now();\n      this.save();\n    }\n  }\n\n  // â”€â”€â”€ Type Guards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private isPatternInput(input: any): input is PatternInput {\n    return (\n      input &&\n      typeof input === 'object' &&\n      'issueKeywords' in input &&\n      'filesModified' in input &&\n      'fixSteps' in input\n    );\n  }\n\n  private isFailureInput(input: any): input is FailureInput {\n    return (\n      input &&\n      typeof input === 'object' &&\n      'issueKeywords' in input &&\n      !('filesModified' in input) &&\n      !('status' in input)\n    );\n  }\n\n  // â”€â”€â”€ Private Methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private buildSignature(task: SelfImprovementTask): string {\n    const parts: string[] = [];\n\n    if (task.category) parts.push(task.category);\n    if (task.observation?.affectedArea)\n      parts.push(task.observation.affectedArea);\n    if (task.orientation?.rootCause)\n      parts.push(task.orientation.rootCause.substring(0, 100));\n    if (task.observation?.detectedFiles) {\n      parts.push(...task.observation.detectedFiles.slice(0, 3));\n    }\n\n    if (parts.length === 0 && task.description) {\n      parts.push(task.description.substring(0, 150));\n    }\n\n    return parts.filter(Boolean).join(' | ');\n  }\n\n  private buildSolutionSummary(task: SelfImprovementTask): string {\n    const changes = task.execution?.changes || [];\n    if (changes.length === 0) return 'No changes made';\n\n    const parts = changes.map((c) => {\n      const fileName = c.filePath.split('/').pop();\n      return `${c.changeType} ${fileName}`;\n    });\n\n    const rootCause = task.orientation?.rootCause || 'Unknown cause';\n    return `${rootCause.substring(0, 80)} \\u2192 ${parts.join(', ')}`;\n  }\n\n  private findExactMatch(signature: string): FixPattern | undefined {\n    return this.patterns.find((p) => p.problemSignature === signature);\n  }\n\n  private extractKeywords(text: string | undefined | null): string[] {\n    const safeText = String(text || '');\n    if (!safeText.trim()) return [];\n\n    return safeText\n      .toLowerCase()\n      .split(/[\\s|,;:.!?()\\[\\]{}'\"/\\\\\\u2192]+/)\n      .filter((k) => k.length > 2)\n      .filter(\n        (k) =>\n          !['the', 'and', 'for', 'from', 'with', 'that', 'this'].includes(k)\n      );\n  }\n\n  private prunePatterns(): void {\n    const now = Date.now();\n    const scored = this.patterns.map((p) => ({\n      pattern: p,\n      score:\n        p.successRate * 0.4 +\n        Math.min(1, p.timesUsed / 10) * 0.3 +\n        Math.max(0, 1 - (now - p.lastUsed) / (30 * 24 * 60 * 60 * 1000)) * 0.3,\n    }));\n\n    scored.sort((a, b) => b.score - a.score);\n    this.patterns = scored.slice(0, MAX_PATTERNS).map((s) => s.pattern);\n  }\n\n  private load(): void {\n    if (this.loaded) return;\n    this.loaded = true;\n\n    try {\n      if (typeof localStorage !== 'undefined') {\n        const stored = localStorage.getItem(STORAGE_KEY);\n        if (stored) {\n          const parsed = JSON.parse(stored);\n          if (Array.isArray(parsed)) {\n            this.patterns = parsed;\n          }\n        }\n      }\n    } catch {\n      this.patterns = [];\n    }\n  }\n\n  private save(): void {\n    try {\n      if (typeof localStorage !== 'undefined') {\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(this.patterns));\n      }\n    } catch {\n      // localStorage not available or full\n    }\n  }\n}\n\n// â”€â”€â”€ Singleton â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nlet memoryInstance: LearningMemory | null = null;\n\nexport function getLearningMemory(): LearningMemory {\n  if (!memoryInstance) {\n    memoryInstance = new LearningMemory();\n  }\n  return memoryInstance;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\ooda-controller.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'DependencyTrace' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 22,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 22,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'ProjectMap' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 23,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 23,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 75,
        "column": 54,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 75,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2270, 2273], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2270, 2273], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 362,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 362,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9775, 9778], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9775, 9778], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 368,
        "column": 59,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 368,
        "endColumn": 62,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9991, 9994], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9991, 9994], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 422,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 422,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11815, 11818], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11815, 11818], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'allFiles' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 508,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 508,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 629,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 629,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [18353, 18356], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [18353, 18356], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 743,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 743,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [21637, 21640], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [21637, 21640], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 759,
        "column": 42,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 759,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [22074, 22077], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [22074, 22077], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 770,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 770,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [22339, 22342], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [22339, 22342], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 779,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 779,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [22582, 22585], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [22582, 22585], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 780,
        "column": 18,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 780,
        "endColumn": 21,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [22618, 22621], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [22618, 22621], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 13,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” OODA Controller\n * Orchestrates the full Self-Improvement loop:\n * Observe â†’ Orient â†’ Decide â†’ Act â†’ Verify\n *\n * This is the \"conductor\" that coordinates all self-improvement components.\n * Phase 2: OODA Loop Implementation.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { getSelfAnalysisEngine } from './self-analysis-engine';\nimport { FixExecutor, type ToolBridge } from './fix-executor';\nimport { VerificationEngine } from './verification-engine';\nimport type {\n  SelfImprovementTask,\n  TaskTrigger,\n  TaskStatus,\n  IssueCategory,\n  FixStep,\n  FileChange,\n  ComponentAnalysis,\n  DependencyTrace,\n  ProjectMap,\n  VerificationResult,\n} from './types';\nimport {\n  SELF_IMPROVE_MAX_ITERATIONS,\n  SELF_IMPROVE_MAX_FILES,\n  SELF_IMPROVE_PROTECTED_PATHS,\n} from '../constants';\n\n// â”€â”€â”€ Event Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport type OODAPhase = 'observe' | 'orient' | 'decide' | 'act' | 'verify';\n\nexport interface OODAEvent {\n  taskId: string;\n  phase: OODAPhase;\n  status: 'started' | 'completed' | 'failed';\n  message: string;\n  type?: string;\n  data?: Record<string, unknown>;\n  timestamp: number;\n}\n\nexport type OODAEventListener = (event: OODAEvent) => void;\n\n// â”€â”€â”€ File Loader Type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport type FileLoader = () => Promise<Map<string, string>>;\n\n// â”€â”€â”€ OODA Controller â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport class OODAController {\n  private activeTasks: Map<string, SelfImprovementTask> = new Map();\n  private completedTasks: SelfImprovementTask[] = [];\n  private eventListeners: OODAEventListener[] = [];\n  private fixExecutor: FixExecutor;\n  private verificationEngine: VerificationEngine;\n  private fileLoader: FileLoader | null;\n  private toolBridge: ToolBridge;\n  private runningTaskId: string | null = null;\n\n  constructor(toolBridge: ToolBridge, fileLoader?: FileLoader) {\n    this.toolBridge = toolBridge;\n    this.fixExecutor = new FixExecutor(toolBridge);\n    this.verificationEngine = new VerificationEngine();\n    this.fileLoader = fileLoader || null;\n  }\n\n  /**\n   * Get learning memory instance via dynamic import().\n   * This is critical: vi.mock() intercepts import() but NOT require().\n   */\n  private async getLearningMemoryInstance(): Promise<any> {\n    try {\n      const lm = await import('./learning-memory');\n      if (lm && lm.getLearningMemory) {\n        return lm.getLearningMemory();\n      }\n    } catch {\n      // LearningMemory not available\n    }\n    return null;\n  }\n\n  // â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /** Register an event listener for OODA phase transitions */\n  onEvent(listener: OODAEventListener): () => void {\n    this.eventListeners.push(listener);\n    return () => {\n      this.eventListeners = this.eventListeners.filter((l) => l !== listener);\n    };\n  }\n\n  /**\n   * Alias for onEvent â€” backward compatibility.\n   */\n  on(listener: OODAEventListener): () => void {\n    return this.onEvent(listener);\n  }\n\n  /**\n   * Simplified task start â€” returns a task ID synchronously\n   * and runs the OODA cycle in the background.\n   */\n  startTask(description: string): string {\n    const safeDescription =\n      description && description.trim()\n        ? description.trim()\n        : 'No description provided';\n\n    if (this.runningTaskId) {\n      const task = this.createTask('user_report', safeDescription);\n      this.activeTasks.set(task.id, task);\n      this.emit(\n        task.id,\n        'observe',\n        'started',\n        `Task queued: ${safeDescription}`,\n        undefined,\n        'queued'\n      );\n      return task.id;\n    }\n\n    const task = this.createTask('user_report', safeDescription);\n    this.activeTasks.set(task.id, task);\n    this.runningTaskId = task.id;\n\n    this.emit(\n      task.id,\n      'observe',\n      'started',\n      `Starting task: ${safeDescription}`,\n      undefined,\n      'started'\n    );\n\n    this.runOODACycle(task).catch(() => {\n      // Error already handled inside runOODACycle\n    });\n\n    return task.id;\n  }\n\n  /**\n   * Get task status by ID.\n   */\n  getTaskStatus(taskId: string): {\n    id: string;\n    description: string;\n    status: TaskStatus;\n    phase?: OODAPhase;\n  } | null {\n    const task =\n      this.activeTasks.get(taskId) ||\n      this.completedTasks.find((t) => t.id === taskId);\n    if (!task) return null;\n    return {\n      id: task.id,\n      description: task.description,\n      status: task.status,\n    };\n  }\n\n  /** Start a new self-improvement task (full API) */\n  async startImprovement(\n    trigger: TaskTrigger,\n    description: string,\n    allFiles: Map<string, string>,\n    options?: {\n      category?: IssueCategory;\n      onApprovalRequired?: (task: SelfImprovementTask) => Promise<boolean>;\n    }\n  ): Promise<SelfImprovementTask> {\n    if (this.activeTasks.size > 0) {\n      throw new Error(\n        'Another task is already running. Cancel it first or wait for completion.'\n      );\n    }\n\n    const task = this.createTask(trigger, description);\n    this.activeTasks.set(task.id, task);\n\n    try {\n      await this.phaseObserve(task, allFiles);\n      await this.phaseOrient(task, allFiles);\n\n      if (options?.category) {\n        task.category = options.category;\n      }\n\n      await this.phaseDecide(task, allFiles);\n\n      if (task.decision.requiresApproval && options?.onApprovalRequired) {\n        const approved = await options.onApprovalRequired(task);\n        if (!approved) {\n          task.status = 'cancelled';\n          task.updatedAt = Date.now();\n          this.emit(\n            task.id,\n            'decide',\n            'failed',\n            'Task cancelled by user â€” approval denied'\n          );\n          this.finalizeTask(task);\n          return task;\n        }\n      }\n\n      await this.phaseActAndVerify(task, allFiles);\n    } catch (error) {\n      task.status = 'failed';\n      task.execution.status = 'failed';\n      task.execution.errors.push((error as Error).message);\n      task.updatedAt = Date.now();\n      this.emit(\n        task.id,\n        'act',\n        'failed',\n        `Task failed: ${(error as Error).message}`\n      );\n    }\n\n    this.finalizeTask(task);\n    return task;\n  }\n\n  getTask(taskId: string): SelfImprovementTask | undefined {\n    return (\n      this.activeTasks.get(taskId) ||\n      this.completedTasks.find((t) => t.id === taskId)\n    );\n  }\n\n  getTaskInfo(taskId: string): SelfImprovementTask | null {\n    return this.getTask(taskId) || null;\n  }\n\n  getActiveTasks(): SelfImprovementTask[] {\n    return Array.from(this.activeTasks.values());\n  }\n\n  getHistory(): SelfImprovementTask[] {\n    return [...this.completedTasks];\n  }\n\n  cancelTask(taskId: string): boolean {\n    const task = this.activeTasks.get(taskId);\n    if (!task) return false;\n\n    task.status = 'cancelled';\n    task.updatedAt = Date.now();\n    this.emit(\n      taskId,\n      'act',\n      'failed',\n      'Task cancelled by user',\n      undefined,\n      'cancelled'\n    );\n    this.finalizeTask(task);\n\n    if (this.runningTaskId === taskId) {\n      this.runningTaskId = null;\n    }\n\n    return true;\n  }\n\n  // â”€â”€â”€ Background OODA Cycle (for startTask) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private async runOODACycle(task: SelfImprovementTask): Promise<void> {\n    try {\n      let allFiles: Map<string, string>;\n      if (this.fileLoader) {\n        allFiles = await this.fileLoader();\n      } else {\n        allFiles = new Map();\n      }\n\n      await this.phaseObserve(task, allFiles);\n      if (task.status === 'cancelled') return;\n\n      await this.phaseOrient(task, allFiles);\n      if (task.status === 'cancelled') return;\n\n      await this.phaseDecide(task, allFiles);\n      if (task.status === 'cancelled') return;\n\n      await this.phaseActAndVerify(task, allFiles);\n\n      // Record outcome in learning memory via dynamic import\n      const memory = await this.getLearningMemoryInstance();\n      if (task.status === 'completed' && memory?.recordSuccess) {\n        memory.recordSuccess({\n          description: task.description,\n          category: task.category,\n          filesInvolved: task.execution.changes.map(\n            (c: FileChange) => c.filePath\n          ),\n        });\n      } else if (task.status === 'failed' && memory?.recordFailure) {\n        memory.recordFailure({\n          description: task.description,\n          category: task.category,\n          errors: task.execution.errors,\n        });\n      }\n    } catch (error) {\n      task.status = 'failed';\n      task.execution.status = 'failed';\n      task.execution.errors.push((error as Error).message);\n      task.updatedAt = Date.now();\n      this.emit(\n        task.id,\n        'act',\n        'failed',\n        `Task failed: ${(error as Error).message}`\n      );\n\n      // Record failure\n      try {\n        const memory = await this.getLearningMemoryInstance();\n        if (memory?.recordFailure) {\n          memory.recordFailure({\n            description: task.description,\n            category: task.category,\n            errors: task.execution.errors,\n          });\n        }\n      } catch {\n        // Ignore learning memory errors\n      }\n    }\n\n    this.finalizeTask(task);\n    this.runningTaskId = null;\n  }\n\n  // â”€â”€â”€ Phase 1: OBSERVE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private async phaseObserve(\n    task: SelfImprovementTask,\n    allFiles: Map<string, string>\n  ): Promise<void> {\n    task.status = 'observing';\n    task.updatedAt = Date.now();\n    this.emit(task.id, 'observe', 'started', 'Gathering evidence...');\n\n    const engine = getSelfAnalysisEngine();\n\n    const rawRelatedFiles = engine.findRelatedFiles(\n      task.observation.userMessage,\n      allFiles,\n      15\n    );\n\n    // Normalize: accept both {path, score} and {filePath, relevanceScore}\n    const relatedFiles = (rawRelatedFiles || []).map((f: any) => ({\n      filePath: f.filePath || f.path || '',\n      relevanceScore: f.relevanceScore ?? f.score ?? 0,\n      reason: f.reason || 'unknown',\n    }));\n\n    task.observation.detectedFiles = relatedFiles.map((f: any) => f.filePath);\n\n    const topFiles = relatedFiles.slice(0, 5);\n    const analyses: ComponentAnalysis[] = [];\n\n    for (const file of topFiles) {\n      const content = allFiles.get(file.filePath);\n      if (content) {\n        const analysis = engine.analyzeComponent(file.filePath, content);\n        analyses.push(analysis);\n        task.observation.evidence.push(\n          `${file.filePath}: type=${analysis.type}, complexity=${analysis.estimatedComplexity}, ` +\n            `imports=${(analysis.imports || []).length}, exports=${(analysis.exports || []).length}, ` +\n            `lines=${analysis.lineCount} (relevance: ${file.relevanceScore}, reason: ${file.reason})`\n        );\n      }\n    }\n\n    if (analyses.length > 0) {\n      const types = [...new Set(analyses.map((a) => a.type))];\n      const areas = [\n        ...new Set(\n          analyses.map((a) =>\n            (a.filePath || '').split('/').slice(0, -1).join('/')\n          )\n        ),\n      ];\n      task.observation.affectedArea = `${types.join(', ')} in ${areas.join(', ')}`;\n    } else {\n      task.observation.affectedArea = 'unknown â€” no matching files found';\n    }\n\n    this.emit(\n      task.id,\n      'observe',\n      'completed',\n      `Found ${relatedFiles.length} related files, analyzed top ${topFiles.length}`,\n      { fileCount: relatedFiles.length, analyses: analyses.length }\n    );\n  }\n\n  // â”€â”€â”€ Phase 2: ORIENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private async phaseOrient(\n    task: SelfImprovementTask,\n    allFiles: Map<string, string>\n  ): Promise<void> {\n    task.status = 'orienting';\n    task.updatedAt = Date.now();\n    this.emit(task.id, 'orient', 'started', 'Analyzing root cause...');\n\n    const engine = getSelfAnalysisEngine();\n    const topFiles = task.observation.detectedFiles.slice(0, 5);\n\n    const allTraces: any[] = [];\n    const relatedComponents = new Set<string>();\n\n    for (const filePath of topFiles) {\n      const trace = engine.traceDependencies(filePath, allFiles, 3);\n      allTraces.push(trace);\n      const upstream = Array.isArray(trace.upstream) ? trace.upstream : [];\n      const downstream = Array.isArray(trace.downstream)\n        ? trace.downstream\n        : [];\n      upstream.forEach((f: string) => relatedComponents.add(f));\n      downstream.forEach((f: string) => relatedComponents.add(f));\n    }\n\n    const scope = new Set<string>(topFiles);\n    for (const trace of allTraces) {\n      const downstream = Array.isArray(trace.downstream)\n        ? trace.downstream\n        : [];\n      downstream.forEach((f: string) => scope.add(f));\n    }\n\n    const filteredScope = Array.from(scope).filter(\n      (f) => !SELF_IMPROVE_PROTECTED_PATHS.some((p) => f.startsWith(p))\n    );\n\n    const skills = new Set<string>();\n    for (const filePath of filteredScope) {\n      const content = allFiles.get(filePath);\n      if (!content) continue;\n\n      if (filePath.endsWith('.tsx') || filePath.endsWith('.jsx'))\n        skills.add('React');\n      if (filePath.endsWith('.ts') || filePath.endsWith('.tsx'))\n        skills.add('TypeScript');\n      if (filePath.endsWith('.css') || filePath.endsWith('.scss'))\n        skills.add('CSS');\n      if (content.includes('zustand') || content.includes('create('))\n        skills.add('Zustand');\n      if (content.includes('fetch(') || content.includes('axios'))\n        skills.add('API Integration');\n      if (content.includes('useEffect') || content.includes('useState'))\n        skills.add('React Hooks');\n    }\n\n    const circularDeps = allTraces.flatMap((t) => t.circularDeps || []);\n    const constraints = [\n      ...SELF_IMPROVE_PROTECTED_PATHS.map((p) => `Protected: ${p}`),\n      `Max files: ${SELF_IMPROVE_MAX_FILES}`,\n      `Max iterations: ${SELF_IMPROVE_MAX_ITERATIONS}`,\n    ];\n    if (circularDeps.length > 0) {\n      constraints.push(`Circular deps detected: ${circularDeps.join(', ')}`);\n    }\n\n    const rootCause = this.inferRootCause(task, allFiles, topFiles);\n\n    task.orientation = {\n      rootCause,\n      scope: filteredScope,\n      constraints,\n      skills: Array.from(skills),\n      standards: [\n        'All imports/exports must remain valid',\n        'No unrelated code modifications',\n        'Match existing code style',\n        'Meaningful commit messages',\n      ],\n      relatedComponents: Array.from(relatedComponents).slice(0, 20),\n    };\n\n    task.category = this.detectCategory(task);\n\n    this.emit(\n      task.id,\n      'orient',\n      'completed',\n      `Root cause identified. Scope: ${filteredScope.length} files. Skills: ${Array.from(skills).join(', ')}`,\n      { scope: filteredScope.length, skills: Array.from(skills) }\n    );\n  }\n\n  // â”€â”€â”€ Phase 3: DECIDE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private async phaseDecide(\n    task: SelfImprovementTask,\n    allFiles: Map<string, string>\n  ): Promise<void> {\n    task.status = 'deciding';\n    task.updatedAt = Date.now();\n    this.emit(task.id, 'decide', 'started', 'Creating fix plan...');\n\n    const scope = task.orientation.scope;\n    const plan: FixStep[] = [];\n    let stepOrder = 1;\n\n    for (const filePath of scope) {\n      plan.push({\n        order: stepOrder++,\n        action: 'read',\n        target: filePath,\n        description: `Read current state of ${filePath.split('/').pop()}`,\n        completed: false,\n      });\n    }\n\n    plan.push({\n      order: stepOrder++,\n      action: 'analyze',\n      target: scope[0] || '',\n      description: 'Analyze dependency impact of planned changes',\n      completed: false,\n    });\n\n    const primaryTargets = task.observation.detectedFiles.slice(0, 3);\n    for (const filePath of primaryTargets) {\n      if (SELF_IMPROVE_PROTECTED_PATHS.some((p) => filePath.startsWith(p)))\n        continue;\n\n      plan.push({\n        order: stepOrder++,\n        action: 'edit',\n        target: filePath,\n        description: `Apply fix to ${filePath.split('/').pop()} â€” address: ${task.orientation.rootCause.substring(0, 80)}`,\n        completed: false,\n      });\n    }\n\n    for (const filePath of primaryTargets) {\n      plan.push({\n        order: stepOrder++,\n        action: 'verify',\n        target: filePath,\n        description: `Verify changes in ${filePath.split('/').pop()}`,\n        completed: false,\n      });\n    }\n\n    const riskLevel = this.assessRisk(task, plan);\n\n    const requiresApproval =\n      riskLevel === 'high' ||\n      riskLevel === 'critical' ||\n      primaryTargets.length >= 3;\n\n    const rollbackPlan = primaryTargets\n      .map((f) => `Revert ${f.split('/').pop()} to pre-edit state`)\n      .join('; ');\n\n    task.decision = {\n      plan,\n      riskLevel,\n      rollbackPlan: rollbackPlan || 'No files modified â€” no rollback needed',\n      estimatedImpact:\n        `${primaryTargets.length} files directly modified, ` +\n        `${task.orientation.relatedComponents.length} related components`,\n      requiresApproval,\n    };\n\n    this.emit(\n      task.id,\n      'decide',\n      'completed',\n      `Plan created: ${plan.length} steps, risk=${riskLevel}, approval=${requiresApproval}`,\n      { steps: plan.length, riskLevel, requiresApproval }\n    );\n  }\n\n  // â”€â”€â”€ Phase 4+5: ACT + VERIFY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private async phaseActAndVerify(\n    task: SelfImprovementTask,\n    allFiles: Map<string, string>\n  ): Promise<void> {\n    const maxIterations = task.execution.maxIterations;\n\n    while (task.execution.iterations < maxIterations) {\n      if (task.status === 'cancelled') return;\n\n      task.execution.iterations++;\n\n      task.status = 'acting';\n      task.execution.status = 'in_progress';\n      task.updatedAt = Date.now();\n      this.emit(\n        task.id,\n        'act',\n        'started',\n        `Executing fix plan (iteration ${task.execution.iterations}/${maxIterations})...`\n      );\n\n      try {\n        const rawResult = await this.fixExecutor.executePlan(\n          task.decision.plan,\n          allFiles,\n          {\n            protectedPaths: SELF_IMPROVE_PROTECTED_PATHS as unknown as string[],\n            maxFiles: SELF_IMPROVE_MAX_FILES,\n            dryRun: false,\n          }\n        );\n\n        // Normalize: executePlan may return FileChange[] or {success, filesModified, ...}\n        let changes: FileChange[];\n        if (Array.isArray(rawResult)) {\n          changes = rawResult;\n        } else if (rawResult && typeof rawResult === 'object') {\n          const obj = rawResult as any;\n          const modifiedFiles: string[] = obj.filesModified || [];\n          changes = modifiedFiles.map((fp: string) => ({\n            filePath: fp,\n            changeType: 'modify' as const,\n            oldContent: allFiles.get(fp),\n            newContent: allFiles.get(fp),\n            timestamp: Date.now(),\n          }));\n        } else {\n          changes = [];\n        }\n\n        task.execution.changes.push(...changes);\n\n        for (const change of changes) {\n          if (\n            change.changeType === 'modify' ||\n            change.changeType === 'create'\n          ) {\n            if (change.newContent) {\n              allFiles.set(change.filePath, change.newContent);\n            }\n          } else if (change.changeType === 'delete') {\n            allFiles.delete(change.filePath);\n          }\n        }\n\n        this.emit(\n          task.id,\n          'act',\n          'completed',\n          `Applied ${changes.length} changes`,\n          { changesCount: changes.length }\n        );\n      } catch (error) {\n        task.execution.errors.push(\n          `Act phase error: ${(error as Error).message}`\n        );\n        this.emit(task.id, 'act', 'failed', (error as Error).message);\n\n        if (task.execution.iterations >= maxIterations) {\n          task.status = 'failed';\n          task.execution.status = 'failed';\n          return;\n        }\n        continue;\n      }\n\n      // â•â•â• VERIFY â•â•â•\n      task.status = 'verifying';\n      task.execution.status = 'verifying';\n      task.updatedAt = Date.now();\n      this.emit(task.id, 'verify', 'started', 'Verifying changes...');\n\n      const rawVerification = await this.verificationEngine.verify(\n        task,\n        allFiles,\n        task.execution.changes\n      );\n\n      const verification: VerificationResult =\n        this.normalizeVerification(rawVerification);\n      task.execution.verificationResult = verification;\n\n      if (verification.passed) {\n        task.status = 'completed';\n        task.execution.status = 'completed';\n        task.updatedAt = Date.now();\n        this.emit(\n          task.id,\n          'verify',\n          'completed',\n          'All checks passed! Task complete.',\n          {\n            checks: verification.checks.length,\n            passed: verification.checks.filter((c) => c.passed).length,\n          }\n        );\n        return;\n      }\n\n      const reason = verification.reason || 'Verification checks failed';\n      this.emit(\n        task.id,\n        'verify',\n        'failed',\n        `Verification failed: ${reason}. ` +\n          `Retry ${task.execution.iterations}/${maxIterations}`,\n        { reason }\n      );\n\n      if (\n        !verification.retryNeeded ||\n        task.execution.iterations >= maxIterations\n      ) {\n        task.status = 'failed';\n        task.execution.status = 'failed';\n        task.execution.errors.push(\n          `Verification failed after ${task.execution.iterations} iterations: ${reason}`\n        );\n        return;\n      }\n    }\n\n    task.status = 'failed';\n    task.execution.status = 'failed';\n    task.execution.errors.push(\n      `Exhausted ${maxIterations} iterations without passing verification`\n    );\n  }\n\n  // â”€â”€â”€ Verification Normalizer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private normalizeVerification(raw: any): VerificationResult {\n    if (!raw || typeof raw !== 'object') {\n      return {\n        passed: false,\n        checks: [],\n        retryNeeded: true,\n        reason: 'No verification result',\n      };\n    }\n\n    const passed = !!raw.passed;\n\n    let checks = Array.isArray(raw.checks) ? raw.checks : [];\n\n    if (Array.isArray(raw.failedChecks)) {\n      for (const fc of raw.failedChecks) {\n        const existing = checks.find((c: any) => c.name === fc.name);\n        if (!existing) {\n          checks.push({\n            name: fc.name,\n            passed: fc.passed ?? false,\n            details: fc.message || fc.details || '',\n          });\n        }\n      }\n    }\n\n    checks = checks.map((c: any) => ({\n      name: c.name || 'unknown',\n      passed: c.passed ?? true,\n      details: c.details || c.message || '',\n    }));\n\n    let reason = raw.reason;\n    if (!reason && !passed) {\n      const failedNames = checks\n        .filter((c: any) => !c.passed)\n        .map((c: any) => c.name);\n      reason =\n        failedNames.length > 0\n          ? `Failed checks: ${failedNames.join(', ')}`\n          : 'Verification failed';\n    }\n\n    const retryNeeded =\n      raw.retryNeeded !== undefined ? raw.retryNeeded : !passed;\n\n    return { passed, checks, retryNeeded, reason };\n  }\n\n  // â”€â”€â”€ Helper Methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private createTask(\n    trigger: TaskTrigger,\n    description: string\n  ): SelfImprovementTask {\n    const safeDescription =\n      description && description.trim()\n        ? description.trim()\n        : 'No description provided';\n    const now = Date.now();\n    return {\n      id: uuidv4(),\n      trigger,\n      description: safeDescription,\n      category: 'ui_bug',\n      status: 'observing',\n      createdAt: now,\n      updatedAt: now,\n      observation: {\n        userMessage: safeDescription,\n        affectedArea: '',\n        detectedFiles: [],\n        evidence: [],\n      },\n      orientation: {\n        rootCause: '',\n        scope: [],\n        constraints: [],\n        skills: [],\n        standards: [],\n        relatedComponents: [],\n      },\n      decision: {\n        plan: [],\n        riskLevel: 'low',\n        rollbackPlan: '',\n        estimatedImpact: '',\n        requiresApproval: false,\n      },\n      execution: {\n        status: 'pending',\n        changes: [],\n        iterations: 0,\n        maxIterations: SELF_IMPROVE_MAX_ITERATIONS,\n        errors: [],\n      },\n    };\n  }\n\n  private inferRootCause(\n    task: SelfImprovementTask,\n    allFiles: Map<string, string>,\n    topFiles: string[]\n  ): string {\n    const description = task.observation.userMessage.toLowerCase();\n\n    if (\n      description.includes('style') ||\n      description.includes('css') ||\n      description.includes('color') ||\n      description.includes('size') ||\n      description.includes('position') ||\n      description.includes('layout') ||\n      description.includes('Ù„ÙˆÙ†') ||\n      description.includes('Ø­Ø¬Ù…') ||\n      description.includes('ÙˆØ§Ø¬Ù‡Ø©')\n    ) {\n      const cssFiles = topFiles.filter(\n        (f) => f.endsWith('.css') || f.endsWith('.scss')\n      );\n      if (cssFiles.length > 0) {\n        return `CSS/Style issue in ${cssFiles.join(', ')} â€” layout or visual properties may need adjustment`;\n      }\n      return 'Style issue â€” CSS properties may need correction in component or module stylesheet';\n    }\n\n    if (\n      description.includes('render') ||\n      description.includes('display') ||\n      description.includes('show') ||\n      description.includes('appear') ||\n      description.includes('ÙŠØ¸Ù‡Ø±') ||\n      description.includes('Ø¹Ø±Ø¶')\n    ) {\n      return `Component rendering issue â€” conditional logic or state management in ${topFiles[0] || 'unknown'} may need fixing`;\n    }\n\n    if (\n      description.includes('work') ||\n      description.includes('function') ||\n      description.includes('click') ||\n      description.includes('button') ||\n      description.includes('ÙŠØ¹Ù…Ù„') ||\n      description.includes('Ø²Ø±')\n    ) {\n      return `Logic/functionality issue â€” event handler or state update in ${topFiles[0] || 'unknown'} may be broken`;\n    }\n\n    if (\n      description.includes('slow') ||\n      description.includes('perf') ||\n      description.includes('lag') ||\n      description.includes('Ø¨Ø·ÙŠØ¡')\n    ) {\n      return `Performance issue â€” potential unnecessary re-renders or heavy computation in ${topFiles[0] || 'unknown'}`;\n    }\n\n    return `Issue detected in ${topFiles.slice(0, 3).join(', ')} â€” requires manual analysis of: ${description.substring(0, 100)}`;\n  }\n\n  private detectCategory(task: SelfImprovementTask): IssueCategory {\n    const desc = task.observation.userMessage.toLowerCase();\n    const rootCause = task.orientation.rootCause.toLowerCase();\n    const combined = `${desc} ${rootCause}`;\n\n    if (\n      combined.includes('css') ||\n      combined.includes('style') ||\n      combined.includes('Ù„ÙˆÙ†')\n    )\n      return 'style';\n    if (\n      combined.includes('slow') ||\n      combined.includes('perf') ||\n      combined.includes('Ø¨Ø·ÙŠØ¡')\n    )\n      return 'performance';\n    if (\n      combined.includes('access') ||\n      combined.includes('aria') ||\n      combined.includes('screen reader')\n    )\n      return 'accessibility';\n    if (\n      combined.includes('feature') ||\n      combined.includes('add') ||\n      combined.includes('Ø¥Ø¶Ø§ÙØ©')\n    )\n      return 'feature_enhancement';\n    if (\n      combined.includes('render') ||\n      combined.includes('display') ||\n      combined.includes('ui') ||\n      combined.includes('ÙˆØ§Ø¬Ù‡Ø©')\n    )\n      return 'ui_bug';\n    return 'logic_error';\n  }\n\n  private assessRisk(\n    task: SelfImprovementTask,\n    plan: FixStep[]\n  ): SelfImprovementTask['decision']['riskLevel'] {\n    const editSteps = plan.filter(\n      (s) =>\n        s.action === 'edit' || s.action === 'create' || s.action === 'delete'\n    );\n    const scope = task.orientation.scope;\n\n    if (\n      editSteps.length > 5 ||\n      scope.some((f) => f.includes('agent-service') || f.includes('safety'))\n    ) {\n      return 'critical';\n    }\n\n    if (\n      editSteps.length > 3 ||\n      task.orientation.skills.includes('Zustand') ||\n      scope.some((f) => f.includes('store') || f.includes('provider'))\n    ) {\n      return 'high';\n    }\n\n    if (editSteps.length >= 2) {\n      return 'medium';\n    }\n\n    return 'low';\n  }\n\n  private emit(\n    taskId: string,\n    phase: OODAPhase,\n    status: OODAEvent['status'],\n    message: string,\n    data?: Record<string, unknown>,\n    type?: string\n  ): void {\n    const event: OODAEvent = {\n      taskId,\n      phase,\n      status,\n      message,\n      type,\n      data,\n      timestamp: Date.now(),\n    };\n\n    for (const listener of this.eventListeners) {\n      try {\n        listener(event);\n      } catch {\n        // Don't let listener errors break the loop\n      }\n    }\n  }\n\n  private finalizeTask(task: SelfImprovementTask): void {\n    task.updatedAt = Date.now();\n    this.activeTasks.delete(task.id);\n    this.completedTasks.push(task);\n\n    if (this.completedTasks.length > 50) {\n      this.completedTasks = this.completedTasks.slice(-50);\n    }\n  }\n}\n\n// â”€â”€â”€ Singleton â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nlet controllerInstance: OODAController | null = null;\n\nexport function getOODAController(toolBridge: ToolBridge): OODAController {\n  if (!controllerInstance) {\n    controllerInstance = new OODAController(toolBridge);\n  }\n  return controllerInstance;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\ooda-tool-definitions.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'service' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 852,
        "column": 38,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 852,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'commitMessage' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 859,
        "column": 48,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 859,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” OODA Phase 3 Tool Definitions & Executors\n * 5 tools that power the active OODA improvement loop.\n *\n * These tools are in the 'ooda' category (separate from 'self-improve').\n * They orchestrate the full lifecycle: start â†’ execute â†’ verify â†’ learn â†’ status.\n *\n * Tool List:\n *   1. ooda_start_cycle   (ğŸŸ¡ NOTIFY) â€” Begin a tracked improvement cycle\n *   2. ooda_execute_fix    (ğŸŸ¡ NOTIFY) â€” Apply fixes with backup/rollback\n *   3. ooda_verify_fix     (ğŸŸ¢ AUTO)   â€” Run automated verification checks\n *   4. ooda_learn_pattern  (ğŸŸ¡ NOTIFY) â€” Save pattern to learning memory\n *   5. ooda_get_status     (ğŸŸ¢ AUTO)   â€” Query cycle status\n */\n\nimport type { ToolDefinition, ToolCallResult } from '../types';\nimport type { AgentService } from '../agent-service';\nimport { getOODAController } from './ooda-controller';\nimport { getLearningMemory } from './learning-memory';\nimport type { ToolBridge } from './fix-executor';\nimport type { IssueCategory } from './types';\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Tool Definitions (5 tools)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport const oodaPhase3ToolDefinitions: ToolDefinition[] = [\n  // â”€â”€â”€ 1. ooda_start_cycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  {\n    name: 'ooda_start_cycle',\n    description:\n      'Initialize a new OODA improvement cycle. Creates a tracked task with a unique cycle ID, ' +\n      'issue description, affected components, and phase tracking ' +\n      '(observe â†’ orient â†’ decide â†’ act â†’ verify). ' +\n      'Use this AFTER self_analyze_component and self_trace_dependency have gathered context. ' +\n      'The cycle has a 30-minute timeout and max 5 iterations.',\n    parameters: {\n      type: 'object',\n      properties: {\n        issue: {\n          type: 'string',\n          description: 'Description of the problem or improvement to address',\n        },\n        category: {\n          type: 'string',\n          enum: [\n            'ui_bug',\n            'logic_error',\n            'performance',\n            'style',\n            'accessibility',\n          ],\n          description: 'Category of the issue',\n        },\n        affectedFiles: {\n          type: 'array',\n          items: { type: 'string' },\n          description:\n            'Array of file paths identified during analysis as affected',\n        },\n      },\n      required: ['issue', 'category', 'affectedFiles'],\n    },\n    riskLevel: 'notify',\n    category: 'ooda',\n  },\n\n  // â”€â”€â”€ 2. ooda_execute_fix â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  {\n    name: 'ooda_execute_fix',\n    description:\n      'Execute a planned fix within an active OODA cycle. ' +\n      'Applies file changes (edit or rewrite) with automatic backup for rollback. ' +\n      'Validates the cycle is in DECIDE or ACT phase, enforces protected paths ' +\n      '(lib/agent/safety/*, .env*), and limits to 10 files per cycle. ' +\n      \"All fixes are reversible through the cycle's backup system.\",\n    parameters: {\n      type: 'object',\n      properties: {\n        cycleId: {\n          type: 'string',\n          description: 'The ID of the active OODA cycle',\n        },\n        fixes: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              filePath: {\n                type: 'string',\n                description: 'Path to the file to fix',\n              },\n              type: {\n                type: 'string',\n                enum: ['edit', 'rewrite'],\n                description:\n                  'edit = surgical old_str/new_str replacement, rewrite = full file content',\n              },\n              oldStr: {\n                type: 'string',\n                description: 'Text to find and replace (for edit type)',\n              },\n              newStr: {\n                type: 'string',\n                description: 'Replacement text (for edit type)',\n              },\n              content: {\n                type: 'string',\n                description: 'Full new file content (for rewrite type)',\n              },\n              commitMessage: {\n                type: 'string',\n                description: 'Commit message for this change',\n              },\n            },\n            required: ['filePath', 'type', 'commitMessage'],\n          },\n          description: 'Array of fix operations to apply',\n        },\n      },\n      required: ['cycleId', 'fixes'],\n    },\n    riskLevel: 'notify',\n    category: 'ooda',\n  },\n\n  // â”€â”€â”€ 3. ooda_verify_fix â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  {\n    name: 'ooda_verify_fix',\n    description:\n      'Verify that applied fixes are correct within an active OODA cycle. ' +\n      'Runs automated checks: file existence, content verification, import/export validation, ' +\n      'protected path check, syntax spot-check, and related component check. ' +\n      'Returns a verification report with pass/fail per check and recommended action ' +\n      '(COMPLETE, RETRY_FIX, or ESCALATE).',\n    parameters: {\n      type: 'object',\n      properties: {\n        cycleId: {\n          type: 'string',\n          description: 'The ID of the active OODA cycle to verify',\n        },\n        checks: {\n          type: 'array',\n          items: {\n            type: 'string',\n            enum: [\n              'exists',\n              'content',\n              'imports',\n              'protected',\n              'syntax',\n              'related',\n            ],\n          },\n          description: 'Specific checks to run (defaults to all 6 if omitted)',\n        },\n      },\n      required: ['cycleId'],\n    },\n    riskLevel: 'auto',\n    category: 'ooda',\n  },\n\n  // â”€â”€â”€ 4. ooda_learn_pattern â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  {\n    name: 'ooda_learn_pattern',\n    description:\n      'Save a learned pattern from a completed OODA cycle to persistent memory. ' +\n      \"Builds the agent's experience database for future improvements. \" +\n      'Patterns include root cause, fix approach, affected file types, ' +\n      'success/failure outcome, and similarity tags for matching. ' +\n      'Use this AFTER ooda_verify_fix passes to capture knowledge.',\n    parameters: {\n      type: 'object',\n      properties: {\n        cycleId: {\n          type: 'string',\n          description: 'The ID of the completed OODA cycle',\n        },\n        pattern: {\n          type: 'object',\n          properties: {\n            description: {\n              type: 'string',\n              description: 'What was learned from this fix',\n            },\n            rootCause: {\n              type: 'string',\n              description: 'The root cause identified',\n            },\n            fixApproach: {\n              type: 'string',\n              description: 'The approach used to fix it',\n            },\n            tags: {\n              type: 'array',\n              items: { type: 'string' },\n              description:\n                'Tags for future similarity matching (e.g., [\"css\", \"rtl\", \"sidebar\"])',\n            },\n            confidence: {\n              type: 'number',\n              description:\n                'Confidence level 0â€“1 (1 = very confident the pattern is correct)',\n            },\n          },\n          required: [\n            'description',\n            'rootCause',\n            'fixApproach',\n            'tags',\n            'confidence',\n          ],\n          description: 'The pattern to save',\n        },\n      },\n      required: ['cycleId', 'pattern'],\n    },\n    riskLevel: 'notify',\n    category: 'ooda',\n  },\n\n  // â”€â”€â”€ 5. ooda_get_status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  {\n    name: 'ooda_get_status',\n    description:\n      'Get the current status of an active or completed OODA cycle. ' +\n      'Returns: current phase, phase history with timestamps, files analyzed/modified, ' +\n      'fix attempts, verification results, time elapsed, and learning patterns extracted. ' +\n      'If no cycleId is provided, returns status of all active cycles.',\n    parameters: {\n      type: 'object',\n      properties: {\n        cycleId: {\n          type: 'string',\n          description:\n            'The ID of the cycle to check (omit for all active cycles)',\n        },\n      },\n      required: [],\n    },\n    riskLevel: 'auto',\n    category: 'ooda',\n  },\n];\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Tool Executors Factory\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/** Protected paths that OODA tools cannot modify */\nconst PROTECTED_PATHS = [\n  'lib/agent/safety/',\n  'lib/agent/constants.ts',\n  '.env',\n  '.env.local',\n  '.env.production',\n];\n\nfunction isProtectedPath(filePath: string): boolean {\n  return PROTECTED_PATHS.some((p) => filePath.startsWith(p) || filePath === p);\n}\n\n/**\n * Create executor functions for all 5 OODA Phase 3 tools.\n * Wires into OODAController and LearningMemory instances.\n */\nexport function createOODAPhase3Executors(\n  toolBridge: ToolBridge,\n  getAllFiles: () => Promise<Map<string, string>>\n): Record<string, (args: Record<string, unknown>) => Promise<ToolCallResult>> {\n  const controller = getOODAController(toolBridge);\n  const memory = getLearningMemory();\n\n  return {\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // 1. ooda_start_cycle\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    ooda_start_cycle: async (args): Promise<ToolCallResult> => {\n      const issue = args.issue as string;\n      const category = args.category as IssueCategory;\n      const affectedFiles = args.affectedFiles as string[];\n\n      if (!issue || !category || !affectedFiles?.length) {\n        return {\n          success: false,\n          error:\n            'Required: issue (string), category (string), affectedFiles (string[])',\n        };\n      }\n\n      // Check for protected paths in affected files\n      const protectedFound = affectedFiles.filter(isProtectedPath);\n      if (protectedFound.length > 0) {\n        return {\n          success: false,\n          error: `â›” Cannot start cycle â€” protected paths detected: ${protectedFound.join(', ')}`,\n        };\n      }\n\n      try {\n        const allFiles = await getAllFiles();\n        const task = await controller.startImprovement(\n          'user_report',\n          issue,\n          allFiles,\n          { category }\n        );\n\n        return {\n          success: true,\n          data: {\n            cycleId: task.id,\n            status: task.status,\n            category: task.category,\n            phase: 'observe',\n            affectedFiles,\n            message: `ğŸš€ OODA cycle started: ${task.id}`,\n            startedAt: new Date(task.createdAt).toISOString(),\n            timeout: '30 minutes',\n            maxIterations: 5,\n          },\n        };\n      } catch (error) {\n        return { success: false, error: (error as Error).message };\n      }\n    },\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // 2. ooda_execute_fix\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    ooda_execute_fix: async (args): Promise<ToolCallResult> => {\n      const cycleId = args.cycleId as string;\n      const fixes = args.fixes as Array<{\n        filePath: string;\n        type: 'edit' | 'rewrite';\n        oldStr?: string;\n        newStr?: string;\n        content?: string;\n        commitMessage: string;\n      }>;\n\n      if (!cycleId || !fixes?.length) {\n        return {\n          success: false,\n          error: 'Required: cycleId (string), fixes (array of fix operations)',\n        };\n      }\n\n      // Validate fixes limit\n      if (fixes.length > 10) {\n        return {\n          success: false,\n          error: `â›” Maximum 10 files per cycle. Received: ${fixes.length}`,\n        };\n      }\n\n      // Check protected paths\n      const protectedFound = fixes\n        .map((f) => f.filePath)\n        .filter(isProtectedPath);\n      if (protectedFound.length > 0) {\n        return {\n          success: false,\n          error: `â›” Cannot modify protected paths: ${protectedFound.join(', ')}`,\n        };\n      }\n\n      // Verify cycle exists\n      const task = controller.getTask(cycleId);\n      if (!task) {\n        return { success: false, error: `Cycle not found: ${cycleId}` };\n      }\n      if (task.status === 'completed' || task.status === 'failed') {\n        return {\n          success: false,\n          error: `Cycle already ${task.status}: ${cycleId}`,\n        };\n      }\n\n      const results: Array<{\n        filePath: string;\n        success: boolean;\n        error?: string;\n      }> = [];\n      const backups: Array<{ filePath: string; originalContent: string }> = [];\n\n      try {\n        for (const fix of fixes) {\n          try {\n            // Create backup before modification\n            let originalContent = '';\n            try {\n              originalContent = await toolBridge.readFile(fix.filePath);\n              backups.push({ filePath: fix.filePath, originalContent });\n            } catch {\n              // File doesn't exist yet (new file) â€” no backup needed\n            }\n\n            let success = false;\n            if (fix.type === 'edit' && fix.oldStr && fix.newStr) {\n              success = await toolBridge.editFile(\n                fix.filePath,\n                fix.oldStr,\n                fix.newStr,\n                fix.commitMessage\n              );\n            } else if (fix.type === 'rewrite' && fix.content) {\n              success = await toolBridge.writeFile(\n                fix.filePath,\n                fix.content,\n                fix.commitMessage\n              );\n            } else {\n              results.push({\n                filePath: fix.filePath,\n                success: false,\n                error:\n                  'Invalid fix: edit requires oldStr+newStr, rewrite requires content',\n              });\n              continue;\n            }\n\n            results.push({ filePath: fix.filePath, success });\n          } catch (error) {\n            results.push({\n              filePath: fix.filePath,\n              success: false,\n              error: (error as Error).message,\n            });\n          }\n        }\n\n        const successCount = results.filter((r) => r.success).length;\n        const failCount = results.filter((r) => !r.success).length;\n\n        return {\n          success: failCount === 0,\n          data: {\n            cycleId,\n            applied: successCount,\n            failed: failCount,\n            results,\n            backupsCreated: backups.length,\n            message:\n              failCount === 0\n                ? `âœ… All ${successCount} fixes applied successfully`\n                : `âš ï¸ ${successCount} applied, ${failCount} failed`,\n            rollbackAvailable: backups.length > 0,\n          },\n        };\n      } catch (error) {\n        // Attempt rollback on catastrophic failure\n        for (const backup of backups) {\n          try {\n            await toolBridge.writeFile(\n              backup.filePath,\n              backup.originalContent,\n              'Rollback: catastrophic failure'\n            );\n          } catch {\n            // Best-effort rollback\n          }\n        }\n        return {\n          success: false,\n          error: `Catastrophic failure (rollback attempted): ${(error as Error).message}`,\n        };\n      }\n    },\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // 3. ooda_verify_fix\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    ooda_verify_fix: async (args): Promise<ToolCallResult> => {\n      const cycleId = args.cycleId as string;\n      const requestedChecks = args.checks as string[] | undefined;\n\n      if (!cycleId) {\n        return { success: false, error: 'Required: cycleId (string)' };\n      }\n\n      const task = controller.getTask(cycleId);\n      if (!task) {\n        return { success: false, error: `Cycle not found: ${cycleId}` };\n      }\n\n      const allChecks = [\n        'exists',\n        'content',\n        'imports',\n        'protected',\n        'syntax',\n        'related',\n      ];\n      const checksToRun = requestedChecks?.length ? requestedChecks : allChecks;\n      const results: Array<{\n        check: string;\n        passed: boolean;\n        details: string;\n      }> = [];\n\n      const modifiedFiles = task.execution.changes.map((c) => c.filePath);\n\n      for (const check of checksToRun) {\n        try {\n          switch (check) {\n            case 'exists': {\n              for (const filePath of modifiedFiles) {\n                try {\n                  await toolBridge.readFile(filePath);\n                  results.push({\n                    check: `exists:${filePath}`,\n                    passed: true,\n                    details: 'File exists',\n                  });\n                } catch {\n                  results.push({\n                    check: `exists:${filePath}`,\n                    passed: false,\n                    details: 'File not found',\n                  });\n                }\n              }\n              break;\n            }\n            case 'content': {\n              for (const change of task.execution.changes) {\n                try {\n                  const content = await toolBridge.readFile(change.filePath);\n                  const hasContent = content.length > 0;\n                  results.push({\n                    check: `content:${change.filePath}`,\n                    passed: hasContent,\n                    details: hasContent\n                      ? `${content.length} chars`\n                      : 'Empty file',\n                  });\n                } catch {\n                  results.push({\n                    check: `content:${change.filePath}`,\n                    passed: false,\n                    details: 'Cannot read file',\n                  });\n                }\n              }\n              break;\n            }\n            case 'imports': {\n              for (const filePath of modifiedFiles) {\n                try {\n                  const content = await toolBridge.readFile(filePath);\n                  const importLines =\n                    content.match(/^import\\s.+from\\s+['\"](.+)['\"];?$/gm) || [];\n                  const brokenImports: string[] = [];\n                  for (const line of importLines) {\n                    const match = line.match(/from\\s+['\"](.+)['\"]/);\n                    if (match?.[1]?.startsWith('.')) {\n                      // Local import â€” check if file exists\n                      const importPath = match[1];\n                      // Basic validation: path shouldn't be empty\n                      if (!importPath || importPath === '.') {\n                        brokenImports.push(importPath);\n                      }\n                    }\n                  }\n                  results.push({\n                    check: `imports:${filePath}`,\n                    passed: brokenImports.length === 0,\n                    details:\n                      brokenImports.length === 0\n                        ? `${importLines.length} imports OK`\n                        : `Broken: ${brokenImports.join(', ')}`,\n                  });\n                } catch {\n                  results.push({\n                    check: `imports:${filePath}`,\n                    passed: false,\n                    details: 'Cannot read',\n                  });\n                }\n              }\n              break;\n            }\n            case 'protected': {\n              const violations = modifiedFiles.filter(isProtectedPath);\n              results.push({\n                check: 'protected',\n                passed: violations.length === 0,\n                details:\n                  violations.length === 0\n                    ? 'No protected files modified'\n                    : `â›” VIOLATION: ${violations.join(', ')}`,\n              });\n              break;\n            }\n            case 'syntax': {\n              for (const filePath of modifiedFiles) {\n                try {\n                  const content = await toolBridge.readFile(filePath);\n                  // Basic syntax checks\n                  const openBraces = (content.match(/\\{/g) || []).length;\n                  const closeBraces = (content.match(/\\}/g) || []).length;\n                  const openParens = (content.match(/\\(/g) || []).length;\n                  const closeParens = (content.match(/\\)/g) || []).length;\n                  const balanced =\n                    openBraces === closeBraces && openParens === closeParens;\n                  results.push({\n                    check: `syntax:${filePath}`,\n                    passed: balanced,\n                    details: balanced\n                      ? 'Braces and parens balanced'\n                      : `Unbalanced: {${openBraces}/${closeBraces}} (${openParens}/${closeParens})`,\n                  });\n                } catch {\n                  results.push({\n                    check: `syntax:${filePath}`,\n                    passed: false,\n                    details: 'Cannot read',\n                  });\n                }\n              }\n              break;\n            }\n            case 'related': {\n              // Check that no related files were accidentally affected\n              results.push({\n                check: 'related',\n                passed: true,\n                details: `${modifiedFiles.length} files modified, within scope`,\n              });\n              break;\n            }\n            default:\n              results.push({\n                check,\n                passed: false,\n                details: `Unknown check: ${check}`,\n              });\n          }\n        } catch (error) {\n          results.push({\n            check,\n            passed: false,\n            details: (error as Error).message,\n          });\n        }\n      }\n\n      const passedCount = results.filter((r) => r.passed).length;\n      const failedCount = results.filter((r) => !r.passed).length;\n      const allPassed = failedCount === 0;\n\n      let recommendedAction: 'COMPLETE' | 'RETRY_FIX' | 'ESCALATE';\n      if (allPassed) {\n        recommendedAction = 'COMPLETE';\n      } else if (failedCount <= 2) {\n        recommendedAction = 'RETRY_FIX';\n      } else {\n        recommendedAction = 'ESCALATE';\n      }\n\n      return {\n        success: true,\n        data: {\n          cycleId,\n          overallPassed: allPassed,\n          passed: passedCount,\n          failed: failedCount,\n          total: results.length,\n          recommendedAction,\n          results,\n          message: allPassed\n            ? `âœ… All ${passedCount} checks passed â€” recommended: COMPLETE`\n            : `âš ï¸ ${failedCount}/${results.length} checks failed â€” recommended: ${recommendedAction}`,\n        },\n      };\n    },\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // 4. ooda_learn_pattern\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    ooda_learn_pattern: async (args): Promise<ToolCallResult> => {\n      const cycleId = args.cycleId as string;\n      const pattern = args.pattern as {\n        description: string;\n        rootCause: string;\n        fixApproach: string;\n        tags: string[];\n        confidence: number;\n      };\n\n      if (!cycleId || !pattern) {\n        return {\n          success: false,\n          error:\n            'Required: cycleId (string), pattern (object with description, rootCause, fixApproach, tags, confidence)',\n        };\n      }\n\n      // Validate confidence range\n      if (pattern.confidence < 0 || pattern.confidence > 1) {\n        return {\n          success: false,\n          error: 'confidence must be between 0 and 1',\n        };\n      }\n\n      const task = controller.getTask(cycleId);\n      if (!task) {\n        return { success: false, error: `Cycle not found: ${cycleId}` };\n      }\n\n      try {\n        // Record as success pattern in memory\n        memory.recordSuccess({\n          ...task,\n          // Enrich with pattern metadata\n          description: `${task.description} | Pattern: ${pattern.description}`,\n        });\n\n        // Check for similar existing patterns\n        const similar = memory.findSimilar(pattern.description, 3);\n\n        const allPatterns = memory.getAllPatterns();\n\n        return {\n          success: true,\n          data: {\n            cycleId,\n            patternSaved: true,\n            description: pattern.description,\n            rootCause: pattern.rootCause,\n            fixApproach: pattern.fixApproach,\n            tags: pattern.tags,\n            confidence: `${Math.round(pattern.confidence * 100)}%`,\n            totalPatternsInMemory: allPatterns.length,\n            similarExisting: similar.map((s) => ({\n              problem: s.pattern.problemSignature.substring(0, 60),\n              similarity: `${Math.round(s.similarity * 100)}%`,\n            })),\n            message: `ğŸ§  Pattern saved! Total patterns: ${allPatterns.length}`,\n          },\n        };\n      } catch (error) {\n        return { success: false, error: (error as Error).message };\n      }\n    },\n\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    // 5. ooda_get_status\n    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n    ooda_get_status: async (args): Promise<ToolCallResult> => {\n      const cycleId = args.cycleId as string | undefined;\n\n      if (cycleId) {\n        const task = controller.getTask(cycleId);\n        if (!task) {\n          return { success: false, error: `Cycle not found: ${cycleId}` };\n        }\n\n        return {\n          success: true,\n          data: {\n            cycleId: task.id,\n            status: task.status,\n            category: task.category,\n            description: task.description,\n            createdAt: new Date(task.createdAt).toISOString(),\n            updatedAt: new Date(task.updatedAt).toISOString(),\n            elapsedMs: Date.now() - task.createdAt,\n            observation: {\n              affectedArea: task.observation.affectedArea,\n              filesDetected: task.observation.detectedFiles.length,\n              evidence: task.observation.evidence.slice(0, 5),\n            },\n            orientation: {\n              rootCause: task.orientation.rootCause,\n              scope: task.orientation.scope,\n              skills: task.orientation.skills,\n            },\n            decision: {\n              planSteps: task.decision.plan.length,\n              riskLevel: task.decision.riskLevel,\n              requiresApproval: task.decision.requiresApproval,\n            },\n            execution: {\n              changesCount: task.execution.changes.length,\n              changes: task.execution.changes.map((c) => ({\n                file: c.filePath,\n                type: c.changeType,\n              })),\n              iterations: `${task.execution.iterations}/${task.execution.maxIterations}`,\n              verified: task.execution.verificationResult?.passed ?? null,\n              errors: task.execution.errors,\n            },\n          },\n        };\n      }\n\n      // Return all active + recent completed\n      const activeTasks = controller.getActiveTasks();\n      const history = controller.getHistory().slice(-10);\n      const stats = memory.getStats();\n\n      return {\n        success: true,\n        data: {\n          activeCycles: activeTasks.map((t) => ({\n            id: t.id,\n            status: t.status,\n            category: t.category,\n            description: t.description.substring(0, 80),\n            elapsedMs: Date.now() - t.createdAt,\n            changes: t.execution.changes.length,\n            iterations: t.execution.iterations,\n          })),\n          recentHistory: history.map((t) => ({\n            id: t.id,\n            status: t.status,\n            category: t.category,\n            description: t.description.substring(0, 80),\n            changes: t.execution.changes.length,\n          })),\n          memoryStats: stats,\n          totalPatternsLearned: memory.getAllPatterns().length,\n        },\n      };\n    },\n  };\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Registration Helper\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/** Helper: Load all project files from local workspace */\nasync function loadProjectFiles(): Promise<Map<string, string>> {\n  const { getAllNodes } = await import('@/lib/db/file-operations');\n  const allNodes = await getAllNodes();\n  const fileMap = new Map<string, string>();\n  for (const node of allNodes) {\n    if (node.type === 'file' && node.content) {\n      fileMap.set(node.path, node.content);\n    }\n  }\n  return fileMap;\n}\n\n/** Helper: Create ToolBridge from AgentService */\nfunction createToolBridgeFromService(service: AgentService): ToolBridge {\n  return {\n    readFile: async (filePath: string) => {\n      const { readFileByPath } = await import('@/lib/db/file-operations');\n      const file = await readFileByPath(filePath);\n      return file.content || '';\n    },\n    editFile: async (filePath, oldStr, newStr, commitMessage) => {\n      const { readFileByPath, updateFileContent } =\n        await import('@/lib/db/file-operations');\n      const file = await readFileByPath(filePath);\n      const content = file.content || '';\n      const newContent = content.replace(oldStr, newStr);\n      if (newContent === content) return false;\n      await updateFileContent(filePath, newContent);\n      return true;\n    },\n    writeFile: async (filePath, content, _commitMessage) => {\n      const { updateFileContent } = await import('@/lib/db/file-operations');\n      await updateFileContent(filePath, content);\n      return true;\n    },\n    deleteFile: async (filePath, _commitMessage) => {\n      const { deleteNode } = await import('@/lib/db/file-operations');\n      await deleteNode(filePath);\n      return true;\n    },\n  };\n}\n\n/**\n * Register all 5 OODA Phase 3 tool executors with the AgentService.\n * Call this from the main tool registry (lib/agent/tools/index.ts).\n */\nexport function registerOODAPhase3Executors(service: AgentService): void {\n  const bridge = createToolBridgeFromService(service);\n  const executors = createOODAPhase3Executors(bridge, loadProjectFiles);\n\n  for (const [toolName, executor] of Object.entries(executors)) {\n    service.registerToolExecutor(toolName, executor);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\ooda-tools.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\self-analysis-engine.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\self-improve-connector.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'event' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 234,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 234,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'event' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 275,
        "column": 28,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 275,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Self-Improve Connector v1.0\n * Bridge layer between the React UI panel (self-improve-panel.tsx)\n * and the OODA engine (ooda-controller.ts).\n *\n * This connector:\n * - Converts OODA events into UI-friendly format\n * - Manages active cycle state for the panel\n * - Provides Arabic labels and status descriptions\n * - Handles cleanup on unmount\n */\n\nimport type {\n  OODAController,\n  OODACycle,\n  OODAPhase,\n  OODAEvent,\n} from './ooda-controller';\nimport type { LearningMemory, LearnedPattern } from './learning-memory';\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Types â€” UI-friendly data structures for the panel\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n/** Phase info with Arabic labels for the UI */\nexport interface UIPhase {\n  id: OODAPhase;\n  label: string;\n  labelAr: string;\n  icon: string;\n  active: boolean;\n  completed: boolean;\n  timestamp?: number;\n}\n\n/** Timeline event for the activity feed */\nexport interface UITimelineEvent {\n  id: string;\n  timestamp: number;\n  type: 'info' | 'success' | 'warning' | 'error' | 'phase';\n  icon: string;\n  message: string;\n  messageAr: string;\n  details?: string;\n}\n\n/** Task card data for the panel */\nexport interface UITaskCard {\n  cycleId: string;\n  title: string;\n  titleAr: string;\n  category: string;\n  categoryAr: string;\n  startedAt: number;\n  elapsedMs: number;\n  currentPhase: UIPhase;\n  phases: UIPhase[];\n  filesAnalyzed: string[];\n  filesModified: string[];\n  fixAttempts: number;\n  maxAttempts: number;\n  expanded: boolean;\n}\n\n/** Stats summary for the stats tab */\nexport interface UIStats {\n  totalCycles: number;\n  successfulCycles: number;\n  failedCycles: number;\n  activeCycles: number;\n  totalFilesModified: number;\n  totalPatternsLearned: number;\n  avgCycleTimeMs: number;\n  categoryBreakdown: Record<string, number>;\n  topModifiedFiles: Array<{ path: string; count: number }>;\n}\n\n/** Connector state pushed to React */\nexport interface ConnectorState {\n  activeTask: UITaskCard | null;\n  timeline: UITimelineEvent[];\n  stats: UIStats;\n  patterns: LearnedPattern[];\n  isRunning: boolean;\n}\n\n/** Callback type for state updates */\nexport type StateUpdateCallback = (state: ConnectorState) => void;\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Constants â€” Arabic labels and mappings\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nconst PHASE_CONFIG: Record<\n  OODAPhase,\n  { label: string; labelAr: string; icon: string }\n> = {\n  observe: { label: 'Observe', labelAr: 'Ø±ØµØ¯', icon: 'ğŸ‘ï¸' },\n  orient: { label: 'Orient', labelAr: 'ØªØ­Ù„ÙŠÙ„', icon: 'ğŸ§­' },\n  decide: { label: 'Decide', labelAr: 'Ù‚Ø±Ø§Ø±', icon: 'ğŸ“‹' },\n  act: { label: 'Act', labelAr: 'ØªÙ†ÙÙŠØ°', icon: 'âš¡' },\n  verify: { label: 'Verify', labelAr: 'ØªØ­Ù‚Ù‚', icon: 'âœ…' },\n};\n\nconst PHASE_ORDER: OODAPhase[] = [\n  'observe',\n  'orient',\n  'decide',\n  'act',\n  'verify',\n];\n\nconst CATEGORY_LABELS: Record<string, string> = {\n  ui_bug: 'Ø®Ù„Ù„ ÙˆØ§Ø¬Ù‡Ø©',\n  logic_error: 'Ø®Ø·Ø£ Ù…Ù†Ø·Ù‚ÙŠ',\n  performance: 'Ø£Ø¯Ø§Ø¡',\n  style: 'ØªÙ†Ø³ÙŠÙ‚',\n  accessibility: 'Ø¥ØªØ§Ø­Ø©',\n};\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// SelfImproveConnector\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport class SelfImproveConnector {\n  private controller: OODAController;\n  private memory: LearningMemory;\n  private listeners: Set<StateUpdateCallback> = new Set();\n  private timeline: UITimelineEvent[] = [];\n  private activeTask: UITaskCard | null = null;\n  private completedCycleIds: Set<string> = new Set();\n  private eventCounter = 0;\n  private disposed = false;\n\n  // Bound event handler references for cleanup\n  private boundHandlers: Map<string, (event: OODAEvent) => void> = new Map();\n\n  constructor(controller: OODAController, memory: LearningMemory) {\n    this.controller = controller;\n    this.memory = memory;\n    this.setupEventListeners();\n  }\n\n  // â”€â”€â”€ Event Listeners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private setupEventListeners(): void {\n    const events: Array<{ name: string; handler: (event: OODAEvent) => void }> =\n      [\n        { name: 'cycle:started', handler: (e) => this.onCycleStarted(e) },\n        { name: 'phase:changed', handler: (e) => this.onPhaseChanged(e) },\n        { name: 'fix:applied', handler: (e) => this.onFixApplied(e) },\n        { name: 'fix:failed', handler: (e) => this.onFixFailed(e) },\n        { name: 'verify:passed', handler: (e) => this.onVerifyPassed(e) },\n        { name: 'verify:failed', handler: (e) => this.onVerifyFailed(e) },\n        { name: 'cycle:completed', handler: (e) => this.onCycleCompleted(e) },\n        { name: 'cycle:failed', handler: (e) => this.onCycleFailed(e) },\n        { name: 'cycle:cancelled', handler: (e) => this.onCycleCancelled(e) },\n        { name: 'pattern:learned', handler: (e) => this.onPatternLearned(e) },\n      ];\n\n    for (const { name, handler } of events) {\n      this.boundHandlers.set(name, handler);\n      this.controller.on(name, handler);\n    }\n  }\n\n  // â”€â”€â”€ Event Handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private onCycleStarted(event: OODAEvent): void {\n    const cycle = event.data as OODACycle;\n    this.activeTask = this.buildTaskCard(cycle);\n    this.addTimelineEvent(\n      'phase',\n      'ğŸš€',\n      'Improvement cycle started',\n      'Ø¨Ø¯Ø£Øª Ø¯ÙˆØ±Ø© Ø§Ù„ØªØ­Ø³ÙŠÙ†',\n      cycle.issue\n    );\n    this.notifyListeners();\n  }\n\n  private onPhaseChanged(event: OODAEvent): void {\n    const { phase, cycleId } = event.data as {\n      phase: OODAPhase;\n      cycleId: string;\n    };\n    if (this.activeTask?.cycleId === cycleId) {\n      this.updateTaskPhases(phase);\n      const config = PHASE_CONFIG[phase];\n      this.addTimelineEvent(\n        'phase',\n        config.icon,\n        `Phase: ${config.label}`,\n        `Ø§Ù„Ù…Ø±Ø­Ù„Ø©: ${config.labelAr}`\n      );\n      this.notifyListeners();\n    }\n  }\n\n  private onFixApplied(event: OODAEvent): void {\n    const { filePath, type } = event.data as { filePath: string; type: string };\n    if (this.activeTask) {\n      if (!this.activeTask.filesModified.includes(filePath)) {\n        this.activeTask.filesModified.push(filePath);\n      }\n      this.activeTask.fixAttempts++;\n    }\n    const shortPath = filePath.split('/').slice(-2).join('/');\n    this.addTimelineEvent(\n      'success',\n      'ğŸ”§',\n      `Fix applied: ${shortPath} (${type})`,\n      `ØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­: ${shortPath} (${type === 'edit' ? 'ØªØ¹Ø¯ÙŠÙ„' : 'Ø¥Ø¹Ø§Ø¯Ø© ÙƒØªØ§Ø¨Ø©'})`\n    );\n    this.notifyListeners();\n  }\n\n  private onFixFailed(event: OODAEvent): void {\n    const { filePath, error } = event.data as {\n      filePath: string;\n      error: string;\n    };\n    const shortPath = filePath.split('/').slice(-2).join('/');\n    this.addTimelineEvent(\n      'error',\n      'âŒ',\n      `Fix failed: ${shortPath}`,\n      `ÙØ´Ù„ Ø§Ù„Ø¥ØµÙ„Ø§Ø­: ${shortPath}`,\n      error\n    );\n    this.notifyListeners();\n  }\n\n  private onVerifyPassed(event: OODAEvent): void {\n    this.addTimelineEvent('success', 'âœ…', 'Verification passed', 'Ù†Ø¬Ø­ Ø§Ù„ØªØ­Ù‚Ù‚');\n    this.notifyListeners();\n  }\n\n  private onVerifyFailed(event: OODAEvent): void {\n    const { reason } = event.data as { reason: string };\n    this.addTimelineEvent(\n      'warning',\n      'âš ï¸',\n      'Verification failed',\n      'ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚',\n      reason\n    );\n    this.notifyListeners();\n  }\n\n  private onCycleCompleted(event: OODAEvent): void {\n    const { cycleId } = event.data as { cycleId: string };\n    this.completedCycleIds.add(cycleId);\n    this.addTimelineEvent(\n      'success',\n      'ğŸ‰',\n      'Cycle completed successfully',\n      'Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ø¯ÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­'\n    );\n    this.activeTask = null;\n    this.notifyListeners();\n  }\n\n  private onCycleFailed(event: OODAEvent): void {\n    const { cycleId, reason } = event.data as {\n      cycleId: string;\n      reason: string;\n    };\n    this.completedCycleIds.add(cycleId);\n    this.addTimelineEvent('error', 'ğŸ’¥', 'Cycle failed', 'ÙØ´Ù„Øª Ø§Ù„Ø¯ÙˆØ±Ø©', reason);\n    this.activeTask = null;\n    this.notifyListeners();\n  }\n\n  private onCycleCancelled(event: OODAEvent): void {\n    this.addTimelineEvent(\n      'warning',\n      'ğŸ›‘',\n      'Cycle cancelled',\n      'ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¯ÙˆØ±Ø©'\n    );\n    this.activeTask = null;\n    this.notifyListeners();\n  }\n\n  private onPatternLearned(event: OODAEvent): void {\n    const { description } = event.data as { description: string };\n    this.addTimelineEvent(\n      'info',\n      'ğŸ§ ',\n      'Pattern learned',\n      'ØªÙ… Ø­ÙØ¸ Ù†Ù…Ø· Ø¬Ø¯ÙŠØ¯',\n      description\n    );\n    this.notifyListeners();\n  }\n\n  // â”€â”€â”€ Task Card Builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private buildTaskCard(cycle: OODACycle): UITaskCard {\n    const currentPhaseConfig = PHASE_CONFIG[cycle.currentPhase];\n    return {\n      cycleId: cycle.id,\n      title: cycle.issue,\n      titleAr: cycle.issue,\n      category: cycle.category,\n      categoryAr: CATEGORY_LABELS[cycle.category] || cycle.category,\n      startedAt: cycle.startedAt,\n      elapsedMs: Date.now() - cycle.startedAt,\n      currentPhase: {\n        id: cycle.currentPhase,\n        label: currentPhaseConfig.label,\n        labelAr: currentPhaseConfig.labelAr,\n        icon: currentPhaseConfig.icon,\n        active: true,\n        completed: false,\n      },\n      phases: this.buildPhaseList(cycle.currentPhase, cycle.phaseHistory),\n      filesAnalyzed: cycle.affectedFiles || [],\n      filesModified: cycle.modifiedFiles || [],\n      fixAttempts: cycle.fixAttempts || 0,\n      maxAttempts: 5,\n      expanded: true,\n    };\n  }\n\n  private buildPhaseList(\n    currentPhase: OODAPhase,\n    phaseHistory?: Array<{ phase: OODAPhase; timestamp: number }>\n  ): UIPhase[] {\n    const currentIndex = PHASE_ORDER.indexOf(currentPhase);\n    const historyMap = new Map<string, number>();\n    if (phaseHistory) {\n      for (const entry of phaseHistory) {\n        historyMap.set(entry.phase, entry.timestamp);\n      }\n    }\n\n    return PHASE_ORDER.map((phase, index) => {\n      const config = PHASE_CONFIG[phase];\n      return {\n        id: phase,\n        label: config.label,\n        labelAr: config.labelAr,\n        icon: config.icon,\n        active: index === currentIndex,\n        completed: index < currentIndex,\n        timestamp: historyMap.get(phase),\n      };\n    });\n  }\n\n  private updateTaskPhases(newPhase: OODAPhase): void {\n    if (!this.activeTask) return;\n    const config = PHASE_CONFIG[newPhase];\n    this.activeTask.currentPhase = {\n      id: newPhase,\n      label: config.label,\n      labelAr: config.labelAr,\n      icon: config.icon,\n      active: true,\n      completed: false,\n    };\n    this.activeTask.phases = this.buildPhaseList(newPhase);\n    this.activeTask.elapsedMs = Date.now() - this.activeTask.startedAt;\n  }\n\n  // â”€â”€â”€ Timeline Manager â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private addTimelineEvent(\n    type: UITimelineEvent['type'],\n    icon: string,\n    message: string,\n    messageAr: string,\n    details?: string\n  ): void {\n    this.eventCounter++;\n    const event: UITimelineEvent = {\n      id: `evt-${this.eventCounter}-${Date.now()}`,\n      timestamp: Date.now(),\n      type,\n      icon,\n      message,\n      messageAr,\n      details,\n    };\n    this.timeline.push(event);\n\n    // Keep timeline manageable (max 200 events)\n    if (this.timeline.length > 200) {\n      this.timeline = this.timeline.slice(-150);\n    }\n  }\n\n  // â”€â”€â”€ Stats Builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private buildStats(): UIStats {\n    const status = this.controller.getStatus();\n    const allPatterns = this.memory.getAllPatterns();\n\n    // Calculate category breakdown from patterns\n    const categoryBreakdown: Record<string, number> = {};\n    for (const pattern of allPatterns) {\n      for (const tag of pattern.tags) {\n        categoryBreakdown[tag] = (categoryBreakdown[tag] || 0) + 1;\n      }\n    }\n\n    // Build top modified files from timeline\n    const fileModCounts = new Map<string, number>();\n    for (const event of this.timeline) {\n      if (\n        event.type === 'success' &&\n        event.message.startsWith('Fix applied:')\n      ) {\n        const match = event.message.match(/Fix applied: (.+?) \\(/);\n        if (match) {\n          const path = match[1];\n          fileModCounts.set(path, (fileModCounts.get(path) || 0) + 1);\n        }\n      }\n    }\n    const topModifiedFiles = Array.from(fileModCounts.entries())\n      .map(([path, count]) => ({ path, count }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    return {\n      totalCycles:\n        status.totalCompleted + status.totalFailed + status.activeCount,\n      successfulCycles: status.totalCompleted,\n      failedCycles: status.totalFailed,\n      activeCycles: status.activeCount,\n      totalFilesModified: this.activeTask?.filesModified.length || 0,\n      totalPatternsLearned: allPatterns.length,\n      avgCycleTimeMs: status.avgCycleTimeMs || 0,\n      categoryBreakdown,\n      topModifiedFiles,\n    };\n  }\n\n  // â”€â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /** Subscribe to state updates */\n  subscribe(callback: StateUpdateCallback): () => void {\n    this.listeners.add(callback);\n    // Send initial state immediately\n    callback(this.getState());\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n\n  /** Get current state snapshot */\n  getState(): ConnectorState {\n    // Update elapsed time if task is active\n    if (this.activeTask) {\n      this.activeTask.elapsedMs = Date.now() - this.activeTask.startedAt;\n    }\n\n    return {\n      activeTask: this.activeTask,\n      timeline: [...this.timeline],\n      stats: this.buildStats(),\n      patterns: this.memory.getAllPatterns(),\n      isRunning: this.activeTask !== null,\n    };\n  }\n\n  /** Start a new improvement cycle from the UI */\n  async startImprovement(\n    issue: string,\n    category: string,\n    affectedFiles: string[]\n  ): Promise<string> {\n    const cycleId = await this.controller.startCycle({\n      issue,\n      category: category as\n        | 'ui_bug'\n        | 'logic_error'\n        | 'performance'\n        | 'style'\n        | 'accessibility',\n      affectedFiles,\n    });\n    return cycleId;\n  }\n\n  /** Cancel the active cycle */\n  async cancelCycle(cycleId: string): Promise<void> {\n    await this.controller.cancelCycle(cycleId);\n  }\n\n  /** Get stats for the stats tab */\n  getStats(): UIStats {\n    return this.buildStats();\n  }\n\n  /** Get all learned patterns for the memory tab */\n  getPatterns(): LearnedPattern[] {\n    return this.memory.getAllPatterns();\n  }\n\n  /** Search patterns by similarity */\n  searchPatterns(query: string): LearnedPattern[] {\n    return this.memory.searchPatterns(query);\n  }\n\n  /** Get timeline events (optionally filtered) */\n  getTimeline(filter?: UITimelineEvent['type']): UITimelineEvent[] {\n    if (!filter) return [...this.timeline];\n    return this.timeline.filter((e) => e.type === filter);\n  }\n\n  /** Clear timeline history */\n  clearTimeline(): void {\n    this.timeline = [];\n    this.notifyListeners();\n  }\n\n  // â”€â”€â”€ Notification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private notifyListeners(): void {\n    if (this.disposed) return;\n    const state = this.getState();\n    for (const listener of this.listeners) {\n      try {\n        listener(state);\n      } catch (err) {\n        console.error('[SelfImproveConnector] Listener error:', err);\n      }\n    }\n  }\n\n  // â”€â”€â”€ Cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  /** Dispose the connector and remove all event listeners */\n  dispose(): void {\n    this.disposed = true;\n    for (const [name, handler] of this.boundHandlers) {\n      this.controller.off(name, handler);\n    }\n    this.boundHandlers.clear();\n    this.listeners.clear();\n    this.timeline = [];\n    this.activeTask = null;\n  }\n}\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// Factory â€” create a connector from existing instances\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nexport function createSelfImproveConnector(\n  controller: OODAController,\n  memory: LearningMemory\n): SelfImproveConnector {\n  return new SelfImproveConnector(controller, memory);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\self-improve-tools.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'service' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 145,
        "column": 27,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 145,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'commitMessage' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 152,
        "column": 48,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 152,
        "endColumn": 61
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'commitMessage' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 162,
        "column": 42,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 162,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'commitMessage' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 167,
        "column": 34,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 167,
        "endColumn": 47
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Self-Improvement Tools\n * Agent tools for self-analysis, dependency tracing, project mapping,\n * and OODA loop operations.\n *\n * Phase 1: 3 tools (ğŸŸ¢ AUTO read-only) â€” category: 'self-improve'\n *   - self_analyze_component, self_trace_dependency, self_map_project\n *\n * Phase 2: 5 tools (mixed risk levels) â€” category: 'self-improve'\n *   - self_start_improvement (ğŸ”´ CONFIRM), self_get_task_status (ğŸŸ¢ AUTO),\n *   - self_cancel_task (ğŸŸ¡ NOTIFY), self_get_suggestions (ğŸŸ¢ AUTO),\n *   - self_get_stats (ğŸŸ¢ AUTO)\n *\n * Phase 3: 5 tools â€” category: 'ooda' (separate file: ooda-tool-definitions.ts)\n *   - ooda_start_cycle, ooda_execute_fix, ooda_verify_fix,\n *   - ooda_learn_pattern, ooda_get_status\n *\n * This file handles self-improve category (8 tools).\n * For ooda category (5 tools), see ooda-tool-definitions.ts.\n * Total across both: 13 self-improvement tools.\n */\n\nimport type { ToolDefinition } from '../types';\nimport type { AgentService } from '../agent-service';\nimport { getSelfAnalysisEngine } from './self-analysis-engine';\nimport { oodaToolDefinitions, createOODAToolExecutors } from './ooda-tools';\nimport type { ToolBridge } from './fix-executor';\n\n// â”€â”€â”€ Phase 1 Tool Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst phase1Tools: ToolDefinition[] = [\n  {\n    name: 'self_analyze_component',\n    description:\n      'Analyze a component/file from the CodeForge project itself. ' +\n      'Returns detailed information: type (React component, hook, store, service, etc.), ' +\n      'imports, exports, dependencies, dependents, props, state usage, complexity level, ' +\n      'and line count. Use this to understand any file before modifying it.',\n    parameters: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description:\n            'Path to the file to analyze, relative to project root. ' +\n            'Example: \"lib/agent/agent-service.ts\" or \"components/codeforge/layout/sidebar.tsx\"',\n        },\n      },\n      required: ['filePath'],\n    },\n    riskLevel: 'auto',\n    category: 'self-improve',\n  },\n  {\n    name: 'self_trace_dependency',\n    description:\n      'Trace the full dependency chain for a file. Shows upstream dependencies ' +\n      '(files this file imports from) and downstream dependents (files that import this file). ' +\n      'Also detects circular dependencies. Use this to understand the impact of changing a file.',\n    parameters: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description:\n            'Path to the file to trace dependencies for. ' +\n            'Example: \"lib/agent/types.ts\"',\n        },\n        maxDepth: {\n          type: 'number',\n          description:\n            'Maximum depth to trace (default: 5). Higher values are slower.',\n        },\n      },\n      required: ['filePath'],\n    },\n    riskLevel: 'auto',\n    category: 'self-improve',\n  },\n  {\n    name: 'self_map_project',\n    description:\n      'Build a complete map of the CodeForge project structure. Returns: total files/folders, ' +\n      'files grouped by extension, dependency graph, entry points, config files, and component files. ' +\n      'Use this as the first step when starting a self-improvement task to understand the full project layout.',\n    parameters: {\n      type: 'object',\n      properties: {\n        includeGraph: {\n          type: 'boolean',\n          description:\n            'Whether to include the full dependency graph (default: true). Set false for a lighter overview.',\n        },\n      },\n      required: [],\n    },\n    riskLevel: 'auto',\n    category: 'self-improve',\n  },\n];\n\n// â”€â”€â”€ Phase 2 Tool Definitions (with risk levels) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nconst phase2Tools: ToolDefinition[] = oodaToolDefinitions.map((tool) => {\n  // Assign risk levels based on tool behavior\n  let riskLevel: 'auto' | 'notify' | 'confirm' = 'auto';\n  if (tool.name === 'self_start_improvement') riskLevel = 'confirm';\n  if (tool.name === 'self_cancel_task') riskLevel = 'notify';\n\n  return { ...tool, riskLevel };\n});\n\n// â”€â”€â”€ Combined Exports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/** All 8 self-improve tool definitions */\nexport const selfImproveTools: ToolDefinition[] = [\n  ...phase1Tools,\n  ...phase2Tools,\n];\n\n/** Alias for backward compatibility */\nexport const selfImproveToolDefinitions = selfImproveTools;\n\n/** Alias for executor registration (used by barrel re-export) */\nexport const selfImproveToolExecutors = selfImproveTools;\n\n// â”€â”€â”€ Helper: Load All Project Files â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nasync function loadProjectFiles(): Promise<Map<string, string>> {\n  const { getAllNodes } = await import('@/lib/db/file-operations');\n  const allNodes = await getAllNodes();\n  const fileMap = new Map<string, string>();\n\n  for (const node of allNodes) {\n    if (node.type === 'file' && node.content) {\n      fileMap.set(node.path, node.content);\n    }\n  }\n\n  return fileMap;\n}\n\n// â”€â”€â”€ Helper: Create Tool Bridge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction createToolBridge(service: AgentService): ToolBridge {\n  return {\n    readFile: async (filePath: string) => {\n      const { readFileByPath } = await import('@/lib/db/file-operations');\n      const file = await readFileByPath(filePath);\n      return file.content || '';\n    },\n    editFile: async (filePath, oldStr, newStr, commitMessage) => {\n      const { readFileByPath, updateFileContent } =\n        await import('@/lib/db/file-operations');\n      const file = await readFileByPath(filePath);\n      const content = file.content || '';\n      const newContent = content.replace(oldStr, newStr);\n      if (newContent === content) return false;\n      await updateFileContent(filePath, newContent);\n      return true;\n    },\n    writeFile: async (filePath, content, commitMessage) => {\n      const { updateFileContent } = await import('@/lib/db/file-operations');\n      await updateFileContent(filePath, content);\n      return true;\n    },\n    deleteFile: async (filePath, commitMessage) => {\n      const { deleteNode } = await import('@/lib/db/file-operations');\n      await deleteNode(filePath);\n      return true;\n    },\n  };\n}\n\n// â”€â”€â”€ Tool Executors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/** Register all self-improvement tool executors (Phase 1 + Phase 2) */\nexport function registerSelfImproveExecutors(service: AgentService): void {\n  const engine = getSelfAnalysisEngine();\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // Phase 1 Executors (read-only analysis)\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  // â”€â”€ self_analyze_component â”€â”€\n  service.registerToolExecutor('self_analyze_component', async (args) => {\n    try {\n      const filePath = args.filePath as string;\n      if (!filePath) {\n        return { success: false, error: 'filePath is required' };\n      }\n\n      let content: string;\n      try {\n        const { readFileByPath } = await import('@/lib/db/file-operations');\n        const file = await readFileByPath(filePath);\n        content = file.content || '';\n      } catch {\n        return {\n          success: false,\n          error: `File not found in local workspace: ${filePath}`,\n        };\n      }\n\n      if (!content) {\n        return { success: false, error: `File is empty: ${filePath}` };\n      }\n\n      const analysis = engine.analyzeComponent(filePath, content);\n\n      try {\n        const allFiles = await loadProjectFiles();\n        const trace = engine.traceDependencies(filePath, allFiles, 1);\n        analysis.dependents = trace.downstream;\n      } catch {\n        // Dependents will remain empty\n      }\n\n      return {\n        success: true,\n        data: {\n          ...analysis,\n          summary:\n            `${analysis.componentName} is a ${analysis.type} with ${analysis.lineCount} lines ` +\n            `(${analysis.estimatedComplexity} complexity). ` +\n            `Imports from ${analysis.dependencies.length} local files, ` +\n            `exported by ${analysis.exports.length} symbols.`,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // â”€â”€ self_trace_dependency â”€â”€\n  service.registerToolExecutor('self_trace_dependency', async (args) => {\n    try {\n      const filePath = args.filePath as string;\n      if (!filePath) {\n        return { success: false, error: 'filePath is required' };\n      }\n\n      const maxDepth = (args.maxDepth as number) || 5;\n      const allFiles = await loadProjectFiles();\n\n      if (!allFiles.has(filePath)) {\n        return {\n          success: false,\n          error: `File not found: ${filePath}. Available files: ${allFiles.size}`,\n        };\n      }\n\n      const trace = engine.traceDependencies(filePath, allFiles, maxDepth);\n\n      const summary = [\n        `ğŸ“ Dependency trace for: ${filePath}`,\n        ``,\n        `â¬†ï¸ Upstream (${trace.upstream.length} files this file imports from):`,\n        ...trace.upstream.map((f) => `   â†’ ${f}`),\n        ``,\n        `â¬‡ï¸ Downstream (${trace.downstream.length} files that import this file):`,\n        ...trace.downstream.map((f) => `   â† ${f}`),\n      ];\n\n      if (trace.circularDeps.length > 0) {\n        summary.push(``, `âš ï¸ Circular dependencies detected:`);\n        for (const dep of trace.circularDeps) {\n          summary.push(`   ğŸ”„ ${dep}`);\n        }\n      }\n\n      return {\n        success: true,\n        data: { ...trace, summary: summary.join('\\n') },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // â”€â”€ self_map_project â”€â”€\n  service.registerToolExecutor('self_map_project', async (args) => {\n    try {\n      const includeGraph = args.includeGraph !== false;\n      const allFiles = await loadProjectFiles();\n\n      if (allFiles.size === 0) {\n        return {\n          success: false,\n          error: 'No files found in the local workspace. Open a project first.',\n        };\n      }\n\n      const projectMap = engine.buildProjectMap(allFiles);\n\n      const extSummary = Object.entries(projectMap.filesByExtension)\n        .sort((a, b) => b[1] - a[1])\n        .slice(0, 10)\n        .map(([ext, count]) => `  .${ext}: ${count} files`)\n        .join('\\n');\n\n      const summary = [\n        `ğŸ“Š Project Map`,\n        `Total: ${projectMap.totalFiles} files in ${projectMap.totalFolders} folders`,\n        ``,\n        `ğŸ“ Files by extension:`,\n        extSummary,\n        ``,\n        `ğŸš€ Entry points: ${projectMap.entryPoints.length}`,\n        ...projectMap.entryPoints.map((e) => `   ${e}`),\n        ``,\n        `âš™ï¸ Config files: ${projectMap.configFiles.length}`,\n        ...projectMap.configFiles.map((c) => `   ${c}`),\n        ``,\n        `ğŸ§© Component files: ${projectMap.componentFiles.length}`,\n      ].join('\\n');\n\n      const result: Record<string, unknown> = {\n        totalFiles: projectMap.totalFiles,\n        totalFolders: projectMap.totalFolders,\n        filesByExtension: projectMap.filesByExtension,\n        entryPoints: projectMap.entryPoints,\n        configFiles: projectMap.configFiles,\n        componentCount: projectMap.componentFiles.length,\n        summary,\n      };\n\n      if (includeGraph) {\n        const simplifiedGraph: Record<string, string[]> = {};\n        for (const [path, node] of Object.entries(projectMap.dependencyGraph)) {\n          simplifiedGraph[path] = node.imports.filter(\n            (i) => i.startsWith('.') || i.startsWith('@/')\n          );\n        }\n        result.dependencyGraph = simplifiedGraph;\n      }\n\n      return { success: true, data: result };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // Phase 2 Executors (OODA loop operations)\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n  const toolBridge = createToolBridge(service);\n  const oodaExecutors = createOODAToolExecutors(toolBridge, loadProjectFiles);\n\n  for (const [toolName, executor] of Object.entries(oodaExecutors)) {\n    service.registerToolExecutor(toolName, executor);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\types.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'ToolCallResult' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 7,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Self-Improvement Types\n * All TypeScript interfaces for the self-improving agent system.\n * Part of Phase 1: Foundation.\n */\n\nimport type { RiskLevel, ToolCallResult, FileDiff } from '../types';\n\n// â”€â”€â”€ OODA Loop Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/** Trigger source for a self-improvement task */\nexport type TaskTrigger = 'user_report' | 'self_detected' | 'scheduled';\n\n/** Category of the issue being addressed */\nexport type IssueCategory =\n  | 'ui_bug'\n  | 'logic_error'\n  | 'performance'\n  | 'style'\n  | 'accessibility'\n  | 'feature_enhancement';\n\n/** Status of a self-improvement task */\nexport type TaskStatus =\n  | 'observing'\n  | 'orienting'\n  | 'deciding'\n  | 'acting'\n  | 'verifying'\n  | 'completed'\n  | 'failed'\n  | 'cancelled';\n\n/** A single step in the fix plan */\nexport interface FixStep {\n  order: number;\n  action: 'read' | 'analyze' | 'edit' | 'create' | 'delete' | 'verify';\n  target: string; // file path\n  description: string;\n  completed: boolean;\n  result?: string;\n}\n\n/** Result of a verification check */\nexport interface VerificationCheck {\n  name: string;\n  passed: boolean;\n  details: string;\n}\n\n/** Result of the verification phase */\nexport interface VerificationResult {\n  passed: boolean;\n  checks: VerificationCheck[];\n  retryNeeded: boolean;\n  reason?: string;\n}\n\n/** Record of a file change made during self-improvement */\nexport interface FileChange {\n  filePath: string;\n  changeType: 'create' | 'modify' | 'delete';\n  oldContent?: string;\n  newContent?: string;\n  diff?: FileDiff;\n  timestamp: number;\n}\n\n// â”€â”€â”€ Main Self-Improvement Task â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/** Complete self-improvement task with all OODA phases */\nexport interface SelfImprovementTask {\n  id: string;\n  trigger: TaskTrigger;\n  description: string;\n  category: IssueCategory;\n  status: TaskStatus;\n  createdAt: number;\n  updatedAt: number;\n\n  /** Phase 1: Observation â€” what was detected */\n  observation: {\n    userMessage: string;\n    affectedArea: string;\n    detectedFiles: string[];\n    evidence: string[];\n  };\n\n  /** Phase 2: Orientation â€” analysis of the problem */\n  orientation: {\n    rootCause: string;\n    scope: string[];\n    constraints: string[];\n    skills: string[];\n    standards: string[];\n    relatedComponents: string[];\n  };\n\n  /** Phase 3: Decision â€” the fix plan */\n  decision: {\n    plan: FixStep[];\n    riskLevel: RiskLevel;\n    rollbackPlan: string;\n    estimatedImpact: string;\n    requiresApproval: boolean;\n  };\n\n  /** Phase 4 & 5: Execution and Verification */\n  execution: {\n    status: 'pending' | 'in_progress' | 'verifying' | 'completed' | 'failed';\n    changes: FileChange[];\n    verificationResult?: VerificationResult;\n    iterations: number;\n    maxIterations: number;\n    errors: string[];\n  };\n}\n\n// â”€â”€â”€ Project Analysis Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/** A node in the project dependency graph */\nexport interface DependencyNode {\n  filePath: string;\n  imports: string[];\n  exportedSymbols: string[];\n  importedBy: string[];\n  language: string;\n  size: number;\n  lastModified?: number;\n}\n\n/** Map of the entire project structure */\nexport interface ProjectMap {\n  rootPath: string;\n  totalFiles: number;\n  totalFolders: number;\n  filesByExtension: Record<string, number>;\n  dependencyGraph: Record<string, DependencyNode>;\n  entryPoints: string[];\n  configFiles: string[];\n  componentFiles: string[];\n  buildTimestamp: number;\n}\n\n/** Result of analyzing a single component */\nexport interface ComponentAnalysis {\n  filePath: string;\n  componentName: string;\n  type:\n    | 'react_component'\n    | 'hook'\n    | 'utility'\n    | 'store'\n    | 'service'\n    | 'type_definition'\n    | 'config'\n    | 'style'\n    | 'test'\n    | 'unknown';\n  imports: Array<{ source: string; symbols: string[] }>;\n  exports: string[];\n  dependencies: string[];\n  dependents: string[];\n  props?: string[];\n  stateUsage?: string[];\n  estimatedComplexity: 'low' | 'medium' | 'high';\n  lineCount: number;\n  hasTests: boolean;\n}\n\n/** Result of tracing dependencies */\nexport interface DependencyTrace {\n  rootFile: string;\n  depth: number;\n  upstream: string[]; // files that this file imports from\n  downstream: string[]; // files that import this file\n  circularDeps: string[];\n  traceTree: DependencyTreeNode;\n}\n\n/** Tree node for dependency visualization */\nexport interface DependencyTreeNode {\n  filePath: string;\n  children: DependencyTreeNode[];\n  depth: number;\n  isCircular: boolean;\n}\n\n// â”€â”€â”€ Learning Memory Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n/** A recorded fix pattern for future reference */\nexport interface FixPattern {\n  id: string;\n  problemSignature: string;\n  category: IssueCategory;\n  solution: string;\n  filesInvolved: string[];\n  successRate: number;\n  timesUsed: number;\n  lastUsed: number;\n  createdAt: number;\n}\n\n/** Summary of self-improvement activity */\nexport interface SelfImproveStats {\n  totalTasks: number;\n  completedTasks: number;\n  failedTasks: number;\n  averageIterations: number;\n  mostModifiedFiles: Array<{ path: string; count: number }>;\n  commonCategories: Array<{ category: IssueCategory; count: number }>;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\self-improve\\verification-engine.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 217,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 217,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6582, 6585], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6582, 6585], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 219,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 219,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6634, 6637], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6634, 6637], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'deletedFile' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 466,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 466,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Verification Engine\n * Validates changes after the ACT phase of the OODA loop.\n * Checks imports, exports, side effects, and overall integrity.\n *\n * Phase 2: OODA Loop Implementation.\n */\n\nimport type {\n  SelfImprovementTask,\n  FileChange,\n  VerificationResult,\n  VerificationCheck,\n} from './types';\nimport { getSelfAnalysisEngine } from './self-analysis-engine';\n\n// â”€â”€â”€ Flat Verify Input (used by unit tests) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport interface VerifyInput {\n  modifiedFiles: string[];\n  declaredScope: string[];\n  allFiles: Map<string, string>;\n  protectedPaths: string[];\n}\n\n// â”€â”€â”€ Verification Engine â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport class VerificationEngine {\n  /**\n   * Verify changes. Accepts either:\n   *   1. Flat form: verify({ modifiedFiles, declaredScope, allFiles, protectedPaths })\n   *   2. Legacy form: verify(task, allFiles, changes)\n   */\n  verify(\n    taskOrInput: SelfImprovementTask | VerifyInput,\n    allFilesArg?: Map<string, string>,\n    changes?: FileChange[] | Record<string, unknown> | null\n  ): VerificationResult {\n    // â”€â”€ Detect flat VerifyInput form â”€â”€\n    if (\n      taskOrInput &&\n      typeof taskOrInput === 'object' &&\n      'modifiedFiles' in taskOrInput &&\n      'allFiles' in taskOrInput &&\n      'protectedPaths' in taskOrInput\n    ) {\n      return this.verifyFlat(taskOrInput as VerifyInput);\n    }\n\n    // â”€â”€ Legacy 3-arg form â”€â”€\n    return this.verifyLegacy(\n      taskOrInput as SelfImprovementTask,\n      allFilesArg!,\n      changes\n    );\n  }\n\n  // â”€â”€â”€ Flat Form Implementation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private verifyFlat(input: VerifyInput): VerificationResult {\n    const checks: VerificationCheck[] = [];\n\n    // Check 1: File existence\n    checks.push(this.checkFileExistenceFlat(input));\n\n    // Check 2: Import validity\n    checks.push(this.checkImportValidityFlat(input));\n\n    // Check 3: Protected paths\n    checks.push(this.checkProtectedPathsFlat(input));\n\n    // Check 4: Scope integrity\n    checks.push(this.checkScopeIntegrityFlat(input));\n\n    // Check 5: Syntax sanity\n    checks.push(this.checkSyntaxSanityFlat(input));\n\n    const failedChecks = checks.filter((c) => !c.passed);\n    const passed = failedChecks.length === 0;\n    const score =\n      checks.length > 0\n        ? checks.filter((c) => c.passed).length / checks.length\n        : 0;\n\n    return {\n      passed,\n      checks,\n      score,\n      retryNeeded: failedChecks.some(\n        (c) => c.name === 'import_validity' || c.name === 'syntax_sanity'\n      ),\n      reason: passed\n        ? undefined\n        : `Failed checks: ${failedChecks.map((c) => c.name).join(', ')}`,\n    };\n  }\n\n  private checkFileExistenceFlat(input: VerifyInput): VerificationCheck {\n    const missing: string[] = [];\n    for (const file of input.modifiedFiles) {\n      if (!input.allFiles.has(file)) {\n        missing.push(file);\n      }\n    }\n    return {\n      name: 'file_existence',\n      passed: missing.length === 0,\n      details:\n        missing.length === 0\n          ? `All ${input.modifiedFiles.length} modified files exist`\n          : `Missing files: ${missing.join(', ')}`,\n    };\n  }\n\n  private checkImportValidityFlat(input: VerifyInput): VerificationCheck {\n    const brokenImports: Array<{ file: string; import: string }> = [];\n\n    for (const file of input.modifiedFiles) {\n      const content = input.allFiles.get(file);\n      if (!content) continue;\n\n      // Extract import statements\n      const importRegex = /import\\s+(?:.*?)\\s+from\\s+['\"]([^'\"]+)['\"]/g;\n      let match: RegExpExecArray | null;\n      while ((match = importRegex.exec(content)) !== null) {\n        const source = match[1];\n        // Skip npm packages (don't start with . or @/)\n        if (!source.startsWith('.') && !source.startsWith('@/')) continue;\n\n        const resolved = this.resolveImport(file, source, input.allFiles);\n        if (!resolved) {\n          brokenImports.push({ file, import: source });\n        }\n      }\n    }\n\n    return {\n      name: 'import_validity',\n      passed: brokenImports.length === 0,\n      details:\n        brokenImports.length === 0\n          ? 'All local imports resolve correctly'\n          : `Broken imports: ${brokenImports.map((b) => `${b.file} \\u2192 ${b.import}`).join('; ')}`,\n    };\n  }\n\n  private checkProtectedPathsFlat(input: VerifyInput): VerificationCheck {\n    const violations: string[] = [];\n    for (const file of input.modifiedFiles) {\n      for (const pp of input.protectedPaths) {\n        if (file.startsWith(pp) || file === pp) {\n          violations.push(`${file} (protected: ${pp})`);\n        }\n      }\n    }\n    return {\n      name: 'protected_paths',\n      passed: violations.length === 0,\n      details:\n        violations.length === 0\n          ? 'No protected paths were modified'\n          : `VIOLATION: Modified protected paths: ${violations.join('; ')}`,\n    };\n  }\n\n  private checkScopeIntegrityFlat(input: VerifyInput): VerificationCheck {\n    const scope = new Set(input.declaredScope);\n    const outOfScope: string[] = [];\n    for (const file of input.modifiedFiles) {\n      if (scope.size > 0 && !scope.has(file)) {\n        outOfScope.push(file);\n      }\n    }\n    return {\n      name: 'scope_integrity',\n      passed: outOfScope.length === 0,\n      details:\n        outOfScope.length === 0\n          ? `All changes within declared scope (${scope.size} files)`\n          : `Out-of-scope modifications: ${outOfScope.join('; ')}`,\n    };\n  }\n\n  private checkSyntaxSanityFlat(input: VerifyInput): VerificationCheck {\n    const syntaxErrors: string[] = [];\n    for (const file of input.modifiedFiles) {\n      const content = input.allFiles.get(file);\n      if (!content) continue;\n      if (!file.match(/\\.(ts|tsx|js|jsx|json)$/)) continue;\n      const issues = this.checkBracketBalance(content, file);\n      syntaxErrors.push(...issues);\n    }\n    return {\n      name: 'syntax_sanity',\n      passed: syntaxErrors.length === 0,\n      details:\n        syntaxErrors.length === 0\n          ? 'All files pass basic syntax check'\n          : `Syntax issues: ${syntaxErrors.join('; ')}`,\n    };\n  }\n\n  // â”€â”€â”€ Legacy Form Implementation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private verifyLegacy(\n    task: SelfImprovementTask,\n    allFiles: Map<string, string>,\n    changes?: FileChange[] | Record<string, unknown> | null\n  ): VerificationResult {\n    let safeChanges: FileChange[];\n    if (Array.isArray(changes)) {\n      safeChanges = changes;\n    } else if (\n      changes &&\n      typeof changes === 'object' &&\n      'items' in changes &&\n      Array.isArray((changes as any).items)\n    ) {\n      safeChanges = (changes as any).items;\n    } else if (\n      changes &&\n      typeof changes === 'object' &&\n      !Array.isArray(changes)\n    ) {\n      safeChanges = [changes as unknown as FileChange];\n    } else {\n      safeChanges = [];\n    }\n\n    const checks: VerificationCheck[] = [];\n\n    checks.push(this.checkFileExistence(safeChanges, allFiles));\n    checks.push(this.checkImportValidity(safeChanges, allFiles));\n    checks.push(this.checkExportConsistency(safeChanges, allFiles));\n    checks.push(this.checkProtectedPaths(safeChanges, task));\n    checks.push(this.checkScopeIntegrity(safeChanges, task));\n    checks.push(this.checkSyntaxSanity(safeChanges, allFiles));\n    checks.push(this.checkDownstreamImpact(safeChanges, allFiles));\n\n    const failedChecks = checks.filter((c) => !c.passed);\n    const passed = failedChecks.length === 0;\n    const retryNeeded = failedChecks.some(\n      (c) =>\n        c.name === 'import_validity' ||\n        c.name === 'syntax_sanity' ||\n        c.name === 'export_consistency'\n    );\n    const score =\n      checks.length > 0\n        ? checks.filter((c) => c.passed).length / checks.length\n        : 0;\n\n    return {\n      passed,\n      checks,\n      score,\n      retryNeeded,\n      reason: passed\n        ? undefined\n        : `Failed checks: ${failedChecks.map((c) => c.name).join(', ')}`,\n    };\n  }\n\n  // â”€â”€â”€ Legacy Individual Checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private checkFileExistence(\n    changes: FileChange[],\n    allFiles: Map<string, string>\n  ): VerificationCheck {\n    const missing: string[] = [];\n    for (const change of changes) {\n      if (change.changeType === 'delete') continue;\n      if (!allFiles.has(change.filePath)) {\n        missing.push(change.filePath);\n      }\n    }\n    return {\n      name: 'file_existence',\n      passed: missing.length === 0,\n      details:\n        missing.length === 0\n          ? `All ${changes.length} modified files exist`\n          : `Missing files: ${missing.join(', ')}`,\n    };\n  }\n\n  private checkImportValidity(\n    changes: FileChange[],\n    allFiles: Map<string, string>\n  ): VerificationCheck {\n    const brokenImports: Array<{ file: string; import: string }> = [];\n    const engine = getSelfAnalysisEngine();\n\n    for (const change of changes) {\n      if (change.changeType === 'delete') continue;\n      const content = allFiles.get(change.filePath);\n      if (!content) continue;\n\n      const analysis = engine.analyzeComponent(change.filePath, content);\n\n      for (const imp of analysis.imports) {\n        if (!imp.source.startsWith('.') && !imp.source.startsWith('@/'))\n          continue;\n        const resolved = this.resolveImport(\n          change.filePath,\n          imp.source,\n          allFiles\n        );\n        if (!resolved) {\n          brokenImports.push({ file: change.filePath, import: imp.source });\n        }\n      }\n    }\n\n    return {\n      name: 'import_validity',\n      passed: brokenImports.length === 0,\n      details:\n        brokenImports.length === 0\n          ? 'All local imports resolve correctly'\n          : `Broken imports: ${brokenImports.map((b) => `${b.file} \\u2192 ${b.import}`).join('; ')}`,\n    };\n  }\n\n  private checkExportConsistency(\n    changes: FileChange[],\n    allFiles: Map<string, string>\n  ): VerificationCheck {\n    const issues: string[] = [];\n    const engine = getSelfAnalysisEngine();\n\n    for (const change of changes) {\n      if (change.changeType === 'delete') continue;\n      const content = allFiles.get(change.filePath);\n      if (!content) continue;\n\n      engine.clearCache();\n      const analysis = engine.analyzeComponent(change.filePath, content);\n\n      for (const exp of analysis.exports) {\n        const definitionPatterns = [\n          new RegExp(\n            `(?:function|class|const|let|var|interface|type|enum)\\\\s+${exp}\\\\b`\n          ),\n          new RegExp(`export\\\\s+default\\\\s+${exp}\\\\b`),\n        ];\n\n        const isDefined = definitionPatterns.some((p) => p.test(content));\n        if (!isDefined) {\n          const isReExport =\n            content.includes(`export { ${exp}`) ||\n            content.includes(`export {${exp}`);\n          if (!isReExport) {\n            issues.push(\n              `${change.filePath}: exported '${exp}' may not be defined`\n            );\n          }\n        }\n      }\n    }\n\n    return {\n      name: 'export_consistency',\n      passed: issues.length === 0,\n      details:\n        issues.length === 0\n          ? 'All exports are properly defined'\n          : `Export issues: ${issues.join('; ')}`,\n    };\n  }\n\n  private checkProtectedPaths(\n    changes: FileChange[],\n    task: SelfImprovementTask\n  ): VerificationCheck {\n    const protectedPaths = (task.orientation?.constraints || [])\n      .filter((c) => c.startsWith('Protected:'))\n      .map((c) => c.replace('Protected: ', ''));\n\n    const violations: string[] = [];\n    for (const change of changes) {\n      if (change.changeType === 'modify' || change.changeType === 'delete') {\n        for (const pp of protectedPaths) {\n          if (change.filePath.startsWith(pp)) {\n            violations.push(`${change.filePath} (protected: ${pp})`);\n          }\n        }\n      }\n    }\n\n    return {\n      name: 'protected_paths',\n      passed: violations.length === 0,\n      details:\n        violations.length === 0\n          ? 'No protected paths were modified'\n          : `VIOLATION: Modified protected paths: ${violations.join('; ')}`,\n    };\n  }\n\n  private checkScopeIntegrity(\n    changes: FileChange[],\n    task: SelfImprovementTask\n  ): VerificationCheck {\n    const scope = new Set(task.orientation?.scope || []);\n    const outOfScope: string[] = [];\n\n    for (const change of changes) {\n      if (\n        (change.changeType === 'modify' || change.changeType === 'delete') &&\n        scope.size > 0 &&\n        !scope.has(change.filePath)\n      ) {\n        outOfScope.push(change.filePath);\n      }\n    }\n\n    return {\n      name: 'scope_integrity',\n      passed: outOfScope.length === 0,\n      details:\n        outOfScope.length === 0\n          ? `All changes within declared scope (${scope.size} files)`\n          : `Out-of-scope modifications: ${outOfScope.join('; ')}`,\n    };\n  }\n\n  private checkSyntaxSanity(\n    changes: FileChange[],\n    allFiles: Map<string, string>\n  ): VerificationCheck {\n    const syntaxErrors: string[] = [];\n\n    for (const change of changes) {\n      if (change.changeType === 'delete') continue;\n      const content = allFiles.get(change.filePath);\n      if (!content) continue;\n      if (!change.filePath.match(/\\.(ts|tsx|js|jsx|json)$/)) continue;\n      const issues = this.checkBracketBalance(content, change.filePath);\n      syntaxErrors.push(...issues);\n    }\n\n    return {\n      name: 'syntax_sanity',\n      passed: syntaxErrors.length === 0,\n      details:\n        syntaxErrors.length === 0\n          ? 'All files pass basic syntax check'\n          : `Syntax issues: ${syntaxErrors.join('; ')}`,\n    };\n  }\n\n  private checkDownstreamImpact(\n    changes: FileChange[],\n    allFiles: Map<string, string>\n  ): VerificationCheck {\n    const engine = getSelfAnalysisEngine();\n    const issues: string[] = [];\n    const modifiedFiles = new Set(\n      changes.filter((c) => c.changeType !== 'delete').map((c) => c.filePath)\n    );\n    const deletedFiles = new Set(\n      changes.filter((c) => c.changeType === 'delete').map((c) => c.filePath)\n    );\n\n    for (const deletedFile of deletedFiles) {\n      for (const [filePath, content] of allFiles.entries()) {\n        if (deletedFiles.has(filePath)) continue;\n        const analysis = engine.analyzeComponent(filePath, content);\n        for (const imp of analysis.imports) {\n          const resolved = this.resolveImport(filePath, imp.source, allFiles);\n          if (resolved && deletedFiles.has(resolved)) {\n            issues.push(`${filePath} imports from deleted file ${resolved}`);\n          }\n        }\n      }\n    }\n\n    for (const modifiedFile of modifiedFiles) {\n      const newContent = allFiles.get(modifiedFile);\n      if (!newContent) continue;\n\n      engine.clearCache();\n      const newAnalysis = engine.analyzeComponent(modifiedFile, newContent);\n      const newExports = new Set(newAnalysis.exports);\n\n      for (const [filePath, content] of allFiles.entries()) {\n        if (filePath === modifiedFile) continue;\n        const analysis = engine.analyzeComponent(filePath, content);\n        for (const imp of analysis.imports) {\n          const resolved = this.resolveImport(filePath, imp.source, allFiles);\n          if (resolved === modifiedFile) {\n            for (const symbol of imp.symbols) {\n              if (symbol && !newExports.has(symbol)) {\n                issues.push(\n                  `${filePath} imports '${symbol}' from ${modifiedFile} but it's no longer exported`\n                );\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      name: 'downstream_impact',\n      passed: issues.length === 0,\n      details:\n        issues.length === 0\n          ? 'No downstream files are broken'\n          : `Downstream issues: ${issues.join('; ')}`,\n    };\n  }\n\n  // â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  private checkBracketBalance(content: string, filePath: string): string[] {\n    const issues: string[] = [];\n    const stack: Array<{ char: string; line: number }> = [];\n    const pairs: Record<string, string> = { '(': ')', '[': ']', '{': '}' };\n    const closers = new Set(Object.values(pairs));\n    let inString = false;\n    let stringChar = '';\n    let inComment = false;\n    let inLineComment = false;\n    let lineNum = 1;\n\n    for (let i = 0; i < content.length; i++) {\n      const c = content[i];\n      const next = content[i + 1];\n      const prev = content[i - 1];\n\n      if (c === '\\n') {\n        lineNum++;\n        inLineComment = false;\n        continue;\n      }\n\n      if (inLineComment) continue;\n      if (inComment) {\n        if (c === '*' && next === '/') {\n          inComment = false;\n          i++;\n        }\n        continue;\n      }\n      if (c === '/' && next === '/') {\n        inLineComment = true;\n        continue;\n      }\n      if (c === '/' && next === '*') {\n        inComment = true;\n        i++;\n        continue;\n      }\n\n      if (inString) {\n        if (c === stringChar && prev !== '\\\\') inString = false;\n        continue;\n      }\n      if (c === '\"' || c === \"'\" || c === '`') {\n        inString = true;\n        stringChar = c;\n        continue;\n      }\n\n      if (pairs[c]) {\n        stack.push({ char: c, line: lineNum });\n      } else if (closers.has(c)) {\n        const last = stack.pop();\n        if (!last) {\n          issues.push(\n            `${filePath}:${lineNum} \\u2014 unexpected '${c}' with no matching opener`\n          );\n        } else if (pairs[last.char] !== c) {\n          issues.push(\n            `${filePath}:${lineNum} \\u2014 mismatched '${c}', expected '${pairs[last.char]}' (opened at line ${last.line})`\n          );\n        }\n      }\n    }\n\n    for (const unclosed of stack) {\n      issues.push(\n        `${filePath}:${unclosed.line} \\u2014 unclosed '${unclosed.char}'`\n      );\n    }\n\n    return issues;\n  }\n\n  private resolveImport(\n    fromFile: string,\n    importSource: string,\n    allFiles: Map<string, string>\n  ): string | null {\n    if (!importSource.startsWith('.') && !importSource.startsWith('@/')) {\n      return null;\n    }\n\n    let resolvedBase: string;\n\n    if (importSource.startsWith('@/')) {\n      resolvedBase = importSource.replace('@/', '');\n    } else {\n      const fromDir = fromFile.split('/').slice(0, -1).join('/');\n      const parts = importSource.split('/');\n      const baseParts = fromDir.split('/').filter(Boolean);\n\n      for (const part of parts) {\n        if (part === '..') baseParts.pop();\n        else if (part !== '.') baseParts.push(part);\n      }\n      resolvedBase = baseParts.join('/');\n    }\n\n    const extensions = [\n      '',\n      '.ts',\n      '.tsx',\n      '.js',\n      '.jsx',\n      '/index.ts',\n      '/index.tsx',\n      '/index.js',\n    ];\n    for (const ext of extensions) {\n      const candidate = resolvedBase + ext;\n      if (allFiles.has(candidate)) return candidate;\n    }\n\n    return null;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\system-prompt.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\tools\\file-tools.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'ToolCallResult' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 15,
        "column": 31,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 15,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'refreshFileTree' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 26,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 26,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” File System Tools (with Store Bridge)\n * Agent tools for local file operations.\n * All WRITE operations sync with File Explorer and Editor via store-bridge.\n * All READ operations use direct DB calls for speed.\n *\n * v2.0 â€” All tools renamed with fs_* prefix to avoid collision with\n *         github_* tools. Names now match System Prompt v2.0 exactly.\n *\n * 9 tools: fs_list_files, fs_read_file, fs_search_files, fs_create_file,\n *          fs_update_file, fs_create_folder, fs_delete_file, fs_rename_file,\n *          fs_move_file.\n */\n\nimport type { ToolDefinition, ToolCallResult } from '../types';\nimport type { AgentService } from '../agent-service';\nimport {\n  readFile as dbReadFile,\n  getAllNodes as dbGetAllNodes,\n  searchFiles as dbSearchFiles,\n  getChildren as dbGetChildren,\n  readFileByPath as dbReadFileByPath,\n} from '@/lib/db/file-operations';\nimport type { FileNode } from '@/lib/db/schema';\nimport {\n  refreshFileTree,\n  refreshOpenFile,\n  closeDeletedFileTab,\n  expandParentFolder,\n  sendNotification,\n} from '../bridge';\n\n// â”€â”€â”€ Tool Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport const fileTools: ToolDefinition[] = [\n  {\n    name: 'fs_list_files',\n    description:\n      'List all files and folders in the local project workspace, or list children of a specific folder. Returns file tree with names, paths, types, and sizes.',\n    parameters: {\n      type: 'object',\n      properties: {\n        parentId: {\n          type: 'string',\n          description:\n            'ID of the parent folder. Omit or pass null to get root-level files.',\n        },\n      },\n      required: [],\n    },\n    riskLevel: 'auto',\n    category: 'filesystem',\n  },\n  {\n    name: 'fs_read_file',\n    description:\n      'Read the content of a local file by its ID or path. Returns the full file content, language, and metadata.',\n    parameters: {\n      type: 'object',\n      properties: {\n        fileId: {\n          type: 'string',\n          description: 'The UUID of the file to read.',\n        },\n        filePath: {\n          type: 'string',\n          description: 'The path of the file to read (alternative to fileId).',\n        },\n      },\n      required: [],\n    },\n    riskLevel: 'auto',\n    category: 'filesystem',\n  },\n  {\n    name: 'fs_search_files',\n    description:\n      'Search for files by name in the local project workspace. Returns matching files with their paths and types.',\n    parameters: {\n      type: 'object',\n      properties: {\n        query: {\n          type: 'string',\n          description: 'Search query to match against file names.',\n        },\n      },\n      required: ['query'],\n    },\n    riskLevel: 'auto',\n    category: 'filesystem',\n  },\n  {\n    name: 'fs_create_file',\n    description:\n      'Create a new file in the local workspace with the specified name, content, and language. The file appears immediately in the File Explorer.',\n    parameters: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description:\n            'File name with extension (e.g., \"index.ts\", \"styles.css\").',\n        },\n        parentId: {\n          type: 'string',\n          description: 'ID of the parent folder. Null for root level.',\n          nullable: true,\n        },\n        content: {\n          type: 'string',\n          description: 'Initial file content.',\n        },\n        language: {\n          type: 'string',\n          description:\n            'Programming language (e.g., \"typescript\", \"javascript\", \"css\").',\n        },\n      },\n      required: ['name', 'content'],\n    },\n    riskLevel: 'notify',\n    category: 'filesystem',\n  },\n  {\n    name: 'fs_update_file',\n    description:\n      'Update the content of an existing local file. The editor tab refreshes automatically if the file is open.',\n    parameters: {\n      type: 'object',\n      properties: {\n        fileId: {\n          type: 'string',\n          description: 'The UUID of the file to update.',\n        },\n        filePath: {\n          type: 'string',\n          description:\n            'The path of the file to update (alternative to fileId).',\n        },\n        newContent: {\n          type: 'string',\n          description: 'The new content to replace the file content with.',\n        },\n      },\n      required: ['newContent'],\n    },\n    riskLevel: 'notify',\n    category: 'filesystem',\n  },\n  {\n    name: 'fs_create_folder',\n    description:\n      'Create a new folder in the local project workspace. Appears immediately in the File Explorer.',\n    parameters: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Folder name.',\n        },\n        parentId: {\n          type: 'string',\n          description: 'ID of the parent folder. Null for root level.',\n          nullable: true,\n        },\n      },\n      required: ['name'],\n    },\n    riskLevel: 'notify',\n    category: 'filesystem',\n  },\n  {\n    name: 'fs_delete_file',\n    description:\n      'Delete a local file or folder (and all its children). Closes the editor tab if open. Requires user confirmation.',\n    parameters: {\n      type: 'object',\n      properties: {\n        nodeId: {\n          type: 'string',\n          description: 'The UUID of the file or folder to delete.',\n        },\n      },\n      required: ['nodeId'],\n    },\n    riskLevel: 'confirm',\n    category: 'filesystem',\n  },\n  {\n    name: 'fs_rename_file',\n    description:\n      'Rename a local file or folder. Updates the File Explorer immediately.',\n    parameters: {\n      type: 'object',\n      properties: {\n        nodeId: {\n          type: 'string',\n          description: 'The UUID of the file or folder to rename.',\n        },\n        newName: {\n          type: 'string',\n          description: 'The new name for the file or folder.',\n        },\n      },\n      required: ['nodeId', 'newName'],\n    },\n    riskLevel: 'notify',\n    category: 'filesystem',\n  },\n  {\n    name: 'fs_move_file',\n    description:\n      'Move a local file or folder to a different parent folder. Updates the File Explorer.',\n    parameters: {\n      type: 'object',\n      properties: {\n        nodeId: {\n          type: 'string',\n          description: 'The UUID of the file or folder to move.',\n        },\n        newParentId: {\n          type: 'string',\n          description:\n            'The UUID of the new parent folder. Null for root level.',\n          nullable: true,\n        },\n      },\n      required: ['nodeId'],\n    },\n    riskLevel: 'notify',\n    category: 'filesystem',\n  },\n];\n\n// â”€â”€â”€ Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nfunction formatNode(node: FileNode): Record<string, unknown> {\n  return {\n    id: node.id,\n    name: node.name,\n    path: node.path,\n    type: node.type,\n    language: node.language,\n    size: node.size,\n    updatedAt: new Date(node.updatedAt).toISOString(),\n  };\n}\n\n// â”€â”€â”€ Tool Executors (with Store Bridge) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport function registerFileExecutors(service: AgentService): void {\n  // â”€â”€ READ OPERATIONS (direct DB â€” fast path) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  // fs_list_files\n  service.registerToolExecutor('fs_list_files', async (args) => {\n    try {\n      const parentId = (args.parentId as string) || null;\n      let nodes: FileNode[];\n\n      if (parentId) {\n        nodes = await dbGetChildren(parentId);\n      } else {\n        nodes = await dbGetAllNodes();\n      }\n\n      return { success: true, data: nodes.map(formatNode) };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // fs_read_file\n  service.registerToolExecutor('fs_read_file', async (args) => {\n    try {\n      let file: FileNode;\n      if (args.fileId) {\n        file = await dbReadFile(args.fileId as string);\n      } else if (args.filePath) {\n        file = await dbReadFileByPath(args.filePath as string);\n      } else {\n        return {\n          success: false,\n          error: 'Either fileId or filePath is required',\n        };\n      }\n\n      return {\n        success: true,\n        data: { ...formatNode(file), content: file.content || '' },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // fs_search_files\n  service.registerToolExecutor('fs_search_files', async (args) => {\n    try {\n      const results = await dbSearchFiles(args.query as string);\n      return { success: true, data: results.map(formatNode) };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // â”€â”€ WRITE OPERATIONS (via Files Store â†’ auto-syncs UI) â”€â”€\n\n  // fs_create_file â€” uses filesStore to auto-refresh File Explorer\n  service.registerToolExecutor('fs_create_file', async (args) => {\n    try {\n      const { useFilesStore } = await import('@/lib/stores/files-store');\n      const store = useFilesStore.getState();\n\n      const file = await store.createFile(\n        args.name as string,\n        (args.parentId as string) || null,\n        (args.content as string) || '',\n        args.language as string | undefined\n      );\n\n      // Expand parent folder so the new file is visible\n      await expandParentFolder((args.parentId as string) || null);\n\n      // Notify user\n      await sendNotification(`ğŸ¤– ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù: ${file.name}`, 'success');\n\n      return {\n        success: true,\n        data: formatNode(file),\n        diff: {\n          filePath: file.path,\n          oldContent: '',\n          newContent: file.content || '',\n          type: 'create' as const,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // fs_update_file â€” uses filesStore + refreshes open editor tab\n  service.registerToolExecutor('fs_update_file', async (args) => {\n    try {\n      // Resolve file ID from path if needed\n      let fileId = args.fileId as string;\n      if (!fileId && args.filePath) {\n        const file = await dbReadFileByPath(args.filePath as string);\n        fileId = file.id;\n      }\n      if (!fileId) {\n        return {\n          success: false,\n          error: 'Either fileId or filePath is required',\n        };\n      }\n\n      // Read old content for diff\n      const oldFile = await dbReadFile(fileId);\n      const oldContent = oldFile.content || '';\n      const newContent = args.newContent as string;\n\n      // Update via filesStore (auto-syncs file tree)\n      const { useFilesStore } = await import('@/lib/stores/files-store');\n      const updated = await useFilesStore.getState().updateFile(fileId, {\n        content: newContent,\n      });\n\n      // â˜… KEY: Refresh the editor tab if this file is currently open\n      await refreshOpenFile(fileId, newContent);\n\n      // Notify user\n      await sendNotification(`ğŸ¤– ØªÙ… ØªØ­Ø¯ÙŠØ«: ${updated.name}`, 'info');\n\n      return {\n        success: true,\n        data: formatNode(updated),\n        diff: {\n          filePath: updated.path,\n          oldContent,\n          newContent,\n          type: 'modify' as const,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // fs_create_folder â€” uses filesStore to auto-refresh\n  service.registerToolExecutor('fs_create_folder', async (args) => {\n    try {\n      const { useFilesStore } = await import('@/lib/stores/files-store');\n      const store = useFilesStore.getState();\n\n      const folder = await store.createFolder(\n        args.name as string,\n        (args.parentId as string) || null\n      );\n\n      await sendNotification(`ğŸ¤– ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯: ${folder.name}`, 'success');\n\n      return { success: true, data: formatNode(folder) };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // fs_delete_file â€” uses filesStore + closes editor tab\n  service.registerToolExecutor('fs_delete_file', async (args) => {\n    try {\n      const nodeId = args.nodeId as string;\n\n      // Read file info before deleting (for diff)\n      const node = await dbReadFile(nodeId);\n\n      // Delete via filesStore (auto-refreshes tree)\n      const { useFilesStore } = await import('@/lib/stores/files-store');\n      await useFilesStore.getState().deleteNode(nodeId);\n\n      // â˜… KEY: Close the editor tab if this file was open\n      await closeDeletedFileTab(nodeId);\n\n      // Notify user\n      await sendNotification(`ğŸ¤– ØªÙ… Ø­Ø°Ù: ${node.name}`, 'warning');\n\n      return {\n        success: true,\n        data: { deleted: formatNode(node) },\n        diff: {\n          filePath: node.path,\n          oldContent: node.content || '',\n          newContent: '',\n          type: 'delete' as const,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // fs_rename_file â€” uses filesStore to auto-refresh\n  service.registerToolExecutor('fs_rename_file', async (args) => {\n    try {\n      const { useFilesStore } = await import('@/lib/stores/files-store');\n      const renamed = await useFilesStore\n        .getState()\n        .renameNode(args.nodeId as string, args.newName as string);\n\n      await sendNotification(\n        `ğŸ¤– ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ³Ù…ÙŠØ© Ø¥Ù„Ù‰: ${renamed.name}`,\n        'info'\n      );\n\n      return { success: true, data: formatNode(renamed) };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // fs_move_file â€” uses filesStore to auto-refresh\n  service.registerToolExecutor('fs_move_file', async (args) => {\n    try {\n      const { useFilesStore } = await import('@/lib/stores/files-store');\n      const moved = await useFilesStore\n        .getState()\n        .moveNode(args.nodeId as string, (args.newParentId as string) || null);\n\n      await sendNotification(`ğŸ¤– ØªÙ… Ù†Ù‚Ù„: ${moved.name}`, 'info');\n\n      return { success: true, data: formatNode(moved) };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\tools\\git-tools.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'ToolCallResult' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 13,
        "column": 31,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 13,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 180,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 180,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5128, 5131], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5128, 5131], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 209,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 209,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6143, 6146], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6143, 6146], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 211,
        "column": 43,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 211,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6232, 6235], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6232, 6235], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 256,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 256,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7602, 7605], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7602, 7605], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Git Tools (with Store Bridge)\n * Agent tools for Git version control operations.\n * All operations sync git-store state after execution.\n *\n * v2.0 â€” Added git_log tool to match System Prompt v2.0.\n *         All tool names now aligned with prompt sections.\n *\n * 8 tools: git_status, git_diff, git_log, git_stage, git_commit,\n *          git_push, git_create_branch, git_create_pr.\n */\n\nimport type { ToolDefinition, ToolCallResult } from '../types';\nimport type { AgentService } from '../agent-service';\nimport { refreshGitState, sendNotification } from '../bridge';\n\n// â”€â”€â”€ Tool Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport const gitTools: ToolDefinition[] = [\n  {\n    name: 'git_status',\n    description:\n      'Get the current Git status â€” shows which files are modified, staged, or untracked.',\n    parameters: { type: 'object', properties: {}, required: [] },\n    riskLevel: 'auto',\n    category: 'git',\n  },\n  {\n    name: 'git_diff',\n    description:\n      'Show the diff (changes) for a specific file or all modified files. Returns the actual content differences.',\n    parameters: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path of specific file to diff. Omit for all files.',\n        },\n      },\n      required: [],\n    },\n    riskLevel: 'auto',\n    category: 'git',\n  },\n  // â”€â”€ NEW: git_log â€” Show recent commit history â”€â”€\n  {\n    name: 'git_log',\n    description:\n      'Show recent commit log from the local Git repository. Returns commit messages, SHAs, authors, and dates.',\n    parameters: {\n      type: 'object',\n      properties: {\n        maxCount: {\n          type: 'number',\n          description: 'Maximum number of commits to return. Defaults to 10.',\n        },\n      },\n      required: [],\n    },\n    riskLevel: 'auto',\n    category: 'git',\n  },\n  {\n    name: 'git_stage',\n    description: 'Stage files for commit (add to staging area).',\n    parameters: {\n      type: 'object',\n      properties: {\n        paths: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Array of file paths to stage. Use [\".\"] to stage all.',\n        },\n      },\n      required: ['paths'],\n    },\n    riskLevel: 'notify',\n    category: 'git',\n  },\n  {\n    name: 'git_commit',\n    description: 'Create a Git commit with the staged changes.',\n    parameters: {\n      type: 'object',\n      properties: {\n        message: {\n          type: 'string',\n          description: 'Commit message describing the changes.',\n        },\n      },\n      required: ['message'],\n    },\n    riskLevel: 'notify',\n    category: 'git',\n  },\n  {\n    name: 'git_push',\n    description:\n      'Push committed changes to GitHub remote repository. Requires user confirmation.',\n    parameters: {\n      type: 'object',\n      properties: {\n        branch: {\n          type: 'string',\n          description: 'Branch to push to. Defaults to current branch.',\n        },\n      },\n      required: [],\n    },\n    riskLevel: 'confirm',\n    category: 'git',\n  },\n  {\n    name: 'git_create_branch',\n    description:\n      'Create a new local Git branch from the current branch or a specified base.',\n    parameters: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Name for the new branch.',\n        },\n        fromBranch: {\n          type: 'string',\n          description:\n            'Base branch to create from. Defaults to current branch.',\n        },\n      },\n      required: ['name'],\n    },\n    riskLevel: 'notify',\n    category: 'git',\n  },\n  {\n    name: 'git_create_pr',\n    description:\n      'Create a Pull Request on GitHub from a local branch. Requires user confirmation.',\n    parameters: {\n      type: 'object',\n      properties: {\n        title: { type: 'string', description: 'Title of the Pull Request.' },\n        body: {\n          type: 'string',\n          description: 'Description/body of the Pull Request.',\n        },\n        base: {\n          type: 'string',\n          description: 'Base branch to merge into (e.g., \"main\").',\n        },\n        head: { type: 'string', description: 'Branch containing changes.' },\n      },\n      required: ['title', 'base', 'head'],\n    },\n    riskLevel: 'confirm',\n    category: 'git',\n  },\n];\n\n// â”€â”€â”€ Tool Executors (with Store Bridge) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport function registerGitExecutors(service: AgentService): void {\n  // git_status â€” reads live state from git-store\n  service.registerToolExecutor('git_status', async () => {\n    try {\n      const { useGitStore } = await import('@/lib/stores/git-store');\n      const store = useGitStore.getState();\n\n      return {\n        success: true,\n        data: {\n          isRepo: store.isRepo,\n          currentBranch: store.currentBranch,\n          remoteUrl: store.remoteUrl,\n          modifiedFiles: store.modifiedFiles || [],\n          stagedFiles: store.stagedFiles || [],\n          commitCount: (store.commitHistory || []).length,\n          latestCommits: (store.commitHistory || [])\n            .slice(0, 5)\n            .map((c: any) => ({\n              message: c.message || c.commit?.message,\n              sha: (c.sha || c.oid || '').slice(0, 7),\n            })),\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // git_diff â€” shows actual content differences\n  service.registerToolExecutor('git_diff', async (args) => {\n    try {\n      const { useGitStore } = await import('@/lib/stores/git-store');\n      const store = useGitStore.getState();\n      const filePath = args.filePath as string | undefined;\n\n      const modifiedFiles = filePath\n        ? (store.modifiedFiles || []).filter((f: string) => f === filePath)\n        : store.modifiedFiles || [];\n\n      // Try to get actual diff content from the store\n      const diffs: Array<{ file: string; status: string; diff?: string }> = [];\n\n      for (const file of modifiedFiles) {\n        let diffContent: string | undefined;\n\n        // Try to get diff via store method if available\n        if (typeof (store as any).getDiff === 'function') {\n          try {\n            diffContent = await (store as any).getDiff(file);\n          } catch {\n            /* fallback below */\n          }\n        }\n\n        // If no diff method, try reading current file content\n        if (!diffContent) {\n          try {\n            const { readFileByPath } = await import('@/lib/db/file-operations');\n            const currentFile = await readFileByPath(file);\n            diffContent = `[Current content - ${(currentFile.content || '').length} chars]\\n${(currentFile.content || '').slice(0, 500)}`;\n          } catch {\n            /* file might not exist in DB */\n          }\n        }\n\n        diffs.push({\n          file,\n          status: 'modified',\n          diff: diffContent || '[diff unavailable]',\n        });\n      }\n\n      return {\n        success: true,\n        data: {\n          totalModified: modifiedFiles.length,\n          files: diffs,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // â”€â”€ NEW EXECUTOR: git_log â€” Show recent commit history â”€â”€\n  service.registerToolExecutor('git_log', async (args) => {\n    try {\n      const { useGitStore } = await import('@/lib/stores/git-store');\n      const store = useGitStore.getState();\n      const maxCount = (args.maxCount as number) || 10;\n\n      const history = (store.commitHistory || []).slice(0, maxCount);\n\n      const commits = history.map((c: any) => {\n        const commit = c.commit || c;\n        const author = commit.author || c.author || {};\n        return {\n          sha: (c.sha || c.oid || '').slice(0, 7),\n          fullSha: c.sha || c.oid || '',\n          message: commit.message || c.message || '',\n          author: author.name || author.login || '',\n          email: author.email || '',\n          date: author.date || author.timestamp || c.date || '',\n        };\n      });\n\n      return {\n        success: true,\n        data: {\n          branch: store.currentBranch || 'unknown',\n          count: commits.length,\n          commits,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // git_stage â€” stages files then refreshes state\n  service.registerToolExecutor('git_stage', async (args) => {\n    try {\n      const { useGitStore } = await import('@/lib/stores/git-store');\n      const paths = args.paths as string[];\n\n      for (const path of paths) {\n        await useGitStore.getState().stageFile(path);\n      }\n\n      // â˜… Refresh git state so UI updates\n      await refreshGitState();\n\n      await sendNotification(\n        `ğŸ¤– ØªÙ… ØªØ¬Ù‡ÙŠØ² ${paths.length} Ù…Ù„Ù(Ø§Øª) Ù„Ù„Ø­ÙØ¸`,\n        'info'\n      );\n\n      return {\n        success: true,\n        data: { staged: paths, message: `${paths.length} file(s) staged` },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // git_commit â€” commits then refreshes\n  service.registerToolExecutor('git_commit', async (args) => {\n    try {\n      const { useGitStore } = await import('@/lib/stores/git-store');\n      const message = args.message as string;\n\n      await useGitStore.getState().commit(message);\n\n      // â˜… Refresh git state\n      await refreshGitState();\n\n      await sendNotification(`ğŸ¤– ØªÙ… Ø§Ù„Ø­ÙØ¸: ${message}`, 'success');\n\n      return {\n        success: true,\n        data: { message: `Committed: ${message}` },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // git_push â€” pushes then refreshes\n  service.registerToolExecutor('git_push', async () => {\n    try {\n      const { useGitStore } = await import('@/lib/stores/git-store');\n      await useGitStore.getState().push();\n\n      // â˜… Refresh git state\n      await refreshGitState();\n\n      await sendNotification('ğŸ¤– ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¥Ù„Ù‰ GitHub Ø¨Ù†Ø¬Ø§Ø­', 'success');\n\n      return {\n        success: true,\n        data: { message: 'Changes pushed to remote successfully' },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // git_create_branch â€” creates branch then refreshes\n  service.registerToolExecutor('git_create_branch', async (args) => {\n    try {\n      const { useGitStore } = await import('@/lib/stores/git-store');\n      const name = args.name as string;\n\n      await useGitStore.getState().createBranch(name);\n\n      // â˜… Refresh git state\n      await refreshGitState();\n\n      await sendNotification(`ğŸ¤– ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙØ±Ø¹: ${name}`, 'success');\n\n      return {\n        success: true,\n        data: { branch: name, message: `Branch '${name}' created` },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // git_create_pr â€” creates PR via GitHub API\n  service.registerToolExecutor('git_create_pr', async (args) => {\n    try {\n      const { useAuthStore } = await import('@/lib/stores/auth-store');\n      const { useGitStore } = await import('@/lib/stores/git-store');\n      const token = useAuthStore.getState().token;\n      const remoteUrl = useGitStore.getState().remoteUrl;\n\n      if (!token) {\n        return { success: false, error: 'Not authenticated with GitHub' };\n      }\n      if (!remoteUrl) {\n        return { success: false, error: 'No remote repository configured' };\n      }\n\n      const match = remoteUrl.match(/github\\.com\\/([^/]+)\\/([^/.]+)/);\n      if (!match) {\n        return { success: false, error: 'Invalid GitHub remote URL' };\n      }\n\n      const [, owner, repo] = match;\n\n      const response = await fetch(\n        `https://api.github.com/repos/${owner}/${repo}/pulls`,\n        {\n          method: 'POST',\n          headers: {\n            Authorization: `Bearer ${token}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            title: args.title as string,\n            body: (args.body as string) || '',\n            base: args.base as string,\n            head: args.head as string,\n          }),\n        }\n      );\n\n      if (!response.ok) {\n        const error = await response.json();\n        return {\n          success: false,\n          error: error.message || 'Failed to create PR',\n        };\n      }\n\n      const pr = await response.json();\n\n      await sendNotification(\n        `ğŸ¤– ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ PR #${pr.number}: ${pr.title}`,\n        'success'\n      );\n\n      return {\n        success: true,\n        data: {\n          number: pr.number,\n          url: pr.html_url,\n          title: pr.title,\n          message: `PR #${pr.number} created: ${pr.html_url}`,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\tools\\github-tools.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'getGitHubToken' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 21,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 21,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” GitHub API Tools\n * Agent tools for direct GitHub repository operations.\n * Uses GitHub REST API with Personal Access Token.\n *\n * 25 tools: create_repo, delete_repo, list_repos, push_file, push_files,\n *           read_file, edit_file, delete_file, list_files, create_branch,\n *           list_branches, delete_branch, create_pull_request, list_pull_requests,\n *           get_pull_request, merge_pull_request, create_issue, list_issues,\n *           update_issue, add_comment, get_repo_info, get_user_info,\n *           search_repos, search_code, get_commit_history.\n *\n * Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ø´ØªØ±ÙƒØ© Ù…Ø³ØªØ®Ø±Ø¬Ø© ÙÙŠ: github/shared.ts\n */\n\nimport type { ToolDefinition } from '../types';\nimport type { AgentService } from '../agent-service';\nimport { sendNotification } from '../bridge';\nimport {\n  TOOL_LIMITATIONS,\n  getGitHubToken,\n  getAuthenticatedUsername,\n  githubFetch,\n  githubFetchRaw,\n  GitHubApiError,\n} from './github/shared';\n\n// Re-export shared utilities for backward compatibility\nexport { TOOL_LIMITATIONS } from './github/shared';\n\n// â”€â”€â”€ Tool Definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport const githubTools: ToolDefinition[] = [\n  // ============== REPOSITORY TOOLS ==============\n  {\n    name: 'github_create_repo',\n    description:\n      'Create a new GitHub repository. Can create public or private repos with optional initialization (README, .gitignore, license).',\n    parameters: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Repository name (e.g., \"my-project\").',\n        },\n        description: {\n          type: 'string',\n          description: 'Short description of the repository.',\n        },\n        isPrivate: {\n          type: 'boolean',\n          description:\n            'Whether the repo should be private. Defaults to false (public).',\n        },\n        autoInit: {\n          type: 'boolean',\n          description: 'Initialize with a README. Defaults to true.',\n        },\n        gitignoreTemplate: {\n          type: 'string',\n          description: 'Gitignore template (e.g., \"Node\", \"Python\"). Optional.',\n        },\n      },\n      required: ['name'],\n    },\n    riskLevel: 'confirm',\n    category: 'github',\n  },\n  {\n    name: 'github_delete_repo',\n    description:\n      'Delete a GitHub repository permanently. This action is IRREVERSIBLE and will delete all code, issues, PRs, and settings. Requires user confirmation. The owner is auto-detected from the GitHub token if not provided or incorrect.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: {\n          type: 'string',\n          description:\n            'Repository owner (username or org). Auto-detected from token if empty or incorrect.',\n        },\n        repo: { type: 'string', description: 'Repository name to delete.' },\n      },\n      required: ['repo'],\n    },\n    riskLevel: 'confirm',\n    category: 'github',\n  },\n  {\n    name: 'github_list_repos',\n    description:\n      'List GitHub repositories for the authenticated user. Returns repo names, URLs, and basic info.',\n    parameters: {\n      type: 'object',\n      properties: {\n        sort: {\n          type: 'string',\n          description: 'Sort by: \"created\", \"updated\", \"pushed\", \"full_name\".',\n          enum: ['created', 'updated', 'pushed', 'full_name'],\n        },\n        perPage: {\n          type: 'number',\n          description: 'Number of repos to return (max 100). Defaults to 10.',\n        },\n      },\n      required: [],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n  {\n    name: 'github_get_repo_info',\n    description:\n      'Get detailed information about a GitHub repository including stats, default branch, and description.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n      },\n      required: ['owner', 'repo'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n  {\n    name: 'github_search_repos',\n    description:\n      'Search for GitHub repositories by keyword, language, topic, or other criteria.',\n    parameters: {\n      type: 'object',\n      properties: {\n        query: { type: 'string', description: 'Search query.' },\n        sort: {\n          type: 'string',\n          description: 'Sort by.',\n          enum: ['stars', 'forks', 'updated', 'help-wanted-issues'],\n        },\n        perPage: {\n          type: 'number',\n          description: 'Number of results (max 30). Defaults to 5.',\n        },\n      },\n      required: ['query'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n\n  // ============== FILE TOOLS ==============\n  {\n    name: 'github_push_file',\n    description: 'Create or update a single file in a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        path: { type: 'string', description: 'File path in the repo.' },\n        content: { type: 'string', description: 'File content.' },\n        message: { type: 'string', description: 'Commit message.' },\n        branch: { type: 'string', description: 'Branch. Defaults to \"main\".' },\n      },\n      required: ['owner', 'repo', 'path', 'content', 'message'],\n    },\n    riskLevel: 'notify',\n    category: 'github',\n  },\n  {\n    name: 'github_push_files',\n    description:\n      'Push multiple files to a GitHub repository in a single commit.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        files: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              path: { type: 'string', description: 'File path.' },\n              content: { type: 'string', description: 'File content.' },\n            },\n            required: ['path', 'content'],\n          },\n          description: 'Array of files to push.',\n        },\n        message: { type: 'string', description: 'Commit message.' },\n        branch: { type: 'string', description: 'Branch. Defaults to \"main\".' },\n      },\n      required: ['owner', 'repo', 'files', 'message'],\n    },\n    riskLevel: 'confirm',\n    category: 'github',\n  },\n  {\n    name: 'github_read_file',\n    description: 'Read the content of a file from a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        path: { type: 'string', description: 'File path.' },\n        branch: { type: 'string', description: 'Branch. Defaults to \"main\".' },\n      },\n      required: ['owner', 'repo', 'path'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n  {\n    name: 'github_edit_file',\n    description:\n      'Edit an existing file by replacing a specific text section. ALWAYS read the file first.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        path: { type: 'string', description: 'File path.' },\n        old_str: {\n          type: 'string',\n          description: 'Exact text to find and replace.',\n        },\n        new_str: { type: 'string', description: 'Replacement text.' },\n        branch: { type: 'string', description: 'Branch. Defaults to \"main\".' },\n        message: { type: 'string', description: 'Commit message.' },\n      },\n      required: ['owner', 'repo', 'path', 'old_str', 'new_str', 'message'],\n    },\n    riskLevel: 'notify',\n    category: 'github',\n  },\n  {\n    name: 'github_delete_file',\n    description: 'Delete a file from a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        path: { type: 'string', description: 'File path to delete.' },\n        message: { type: 'string', description: 'Commit message.' },\n        branch: { type: 'string', description: 'Branch. Defaults to \"main\".' },\n      },\n      required: ['owner', 'repo', 'path', 'message'],\n    },\n    riskLevel: 'confirm',\n    category: 'github',\n  },\n  {\n    name: 'github_list_files',\n    description: 'List files and directories in a path of a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        path: {\n          type: 'string',\n          description: 'Directory path. Defaults to root.',\n        },\n        branch: { type: 'string', description: 'Branch. Defaults to \"main\".' },\n      },\n      required: ['owner', 'repo'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n\n  // ============== BRANCH TOOLS ==============\n  {\n    name: 'github_create_branch',\n    description: 'Create a new branch in a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        branch: { type: 'string', description: 'Name of the new branch.' },\n        fromBranch: {\n          type: 'string',\n          description: 'Source branch. Defaults to \"main\".',\n        },\n      },\n      required: ['owner', 'repo', 'branch'],\n    },\n    riskLevel: 'notify',\n    category: 'github',\n  },\n  {\n    name: 'github_list_branches',\n    description: 'List all branches in a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n      },\n      required: ['owner', 'repo'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n  {\n    name: 'github_delete_branch',\n    description: 'Delete a branch from a GitHub repository. Irreversible.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        branch: { type: 'string', description: 'Branch name to delete.' },\n      },\n      required: ['owner', 'repo', 'branch'],\n    },\n    riskLevel: 'confirm',\n    category: 'github',\n  },\n\n  // ============== PULL REQUEST TOOLS ==============\n  {\n    name: 'github_create_pull_request',\n    description: 'Create a Pull Request in a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        title: { type: 'string', description: 'PR title.' },\n        body: { type: 'string', description: 'PR description.' },\n        head: { type: 'string', description: 'Branch with changes.' },\n        base: { type: 'string', description: 'Target branch.' },\n        draft: { type: 'boolean', description: 'Create as draft.' },\n      },\n      required: ['owner', 'repo', 'title', 'head', 'base'],\n    },\n    riskLevel: 'notify',\n    category: 'github',\n  },\n  {\n    name: 'github_list_pull_requests',\n    description: 'List pull requests in a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        state: {\n          type: 'string',\n          description: 'Filter by state.',\n          enum: ['open', 'closed', 'all'],\n        },\n      },\n      required: ['owner', 'repo'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n  {\n    name: 'github_get_pull_request',\n    description: 'Get detailed information about a specific pull request.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        pullNumber: { type: 'number', description: 'Pull request number.' },\n      },\n      required: ['owner', 'repo', 'pullNumber'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n  {\n    name: 'github_merge_pull_request',\n    description: 'Merge a pull request in a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        pullNumber: { type: 'number', description: 'Pull request number.' },\n        mergeMethod: {\n          type: 'string',\n          description: 'Merge method.',\n          enum: ['merge', 'squash', 'rebase'],\n        },\n        commitTitle: {\n          type: 'string',\n          description: 'Custom merge commit title.',\n        },\n        commitMessage: {\n          type: 'string',\n          description: 'Custom merge commit message.',\n        },\n      },\n      required: ['owner', 'repo', 'pullNumber'],\n    },\n    riskLevel: 'confirm',\n    category: 'github',\n  },\n\n  // ============== ISSUE TOOLS ==============\n  {\n    name: 'github_create_issue',\n    description: 'Create a new issue in a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        title: { type: 'string', description: 'Issue title.' },\n        body: { type: 'string', description: 'Issue description.' },\n        labels: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Labels to add.',\n        },\n      },\n      required: ['owner', 'repo', 'title'],\n    },\n    riskLevel: 'notify',\n    category: 'github',\n  },\n  {\n    name: 'github_list_issues',\n    description: 'List issues in a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        state: {\n          type: 'string',\n          description: 'Filter by state.',\n          enum: ['open', 'closed', 'all'],\n        },\n        labels: { type: 'string', description: 'Comma-separated labels.' },\n        sort: {\n          type: 'string',\n          description: 'Sort by.',\n          enum: ['created', 'updated', 'comments'],\n        },\n        perPage: {\n          type: 'number',\n          description: 'Number of issues. Defaults to 10.',\n        },\n      },\n      required: ['owner', 'repo'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n  {\n    name: 'github_update_issue',\n    description: 'Update an existing issue.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        issueNumber: { type: 'number', description: 'Issue number.' },\n        title: { type: 'string', description: 'New title.' },\n        body: { type: 'string', description: 'New body.' },\n        state: {\n          type: 'string',\n          description: 'New state.',\n          enum: ['open', 'closed'],\n        },\n        labels: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Updated labels.',\n        },\n        assignees: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Updated assignees.',\n        },\n      },\n      required: ['owner', 'repo', 'issueNumber'],\n    },\n    riskLevel: 'notify',\n    category: 'github',\n  },\n  {\n    name: 'github_add_comment',\n    description: 'Add a comment to an issue or pull request.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        issueNumber: { type: 'number', description: 'Issue or PR number.' },\n        body: { type: 'string', description: 'Comment text.' },\n      },\n      required: ['owner', 'repo', 'issueNumber', 'body'],\n    },\n    riskLevel: 'notify',\n    category: 'github',\n  },\n\n  // ============== SEARCH TOOLS ==============\n  {\n    name: 'github_search_code',\n    description: 'Search for code patterns across a GitHub repository.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        query: { type: 'string', description: 'Search query.' },\n        fileExtension: { type: 'string', description: 'Filter by extension.' },\n        path: { type: 'string', description: 'Filter by directory.' },\n        perPage: {\n          type: 'number',\n          description: 'Results (max 30). Defaults to 10.',\n        },\n      },\n      required: ['owner', 'repo', 'query'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n\n  // ============== HISTORY TOOLS ==============\n  {\n    name: 'github_get_commit_history',\n    description: 'Retrieve commit history for a branch.',\n    parameters: {\n      type: 'object',\n      properties: {\n        owner: { type: 'string', description: 'Repository owner.' },\n        repo: { type: 'string', description: 'Repository name.' },\n        branch: {\n          type: 'string',\n          description: 'Branch name. Defaults to \"main\".',\n        },\n        path: { type: 'string', description: 'Filter by file path.' },\n        perPage: {\n          type: 'number',\n          description: 'Number of commits (max 100). Defaults to 10.',\n        },\n      },\n      required: ['owner', 'repo'],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n\n  // ============== USER TOOLS ==============\n  {\n    name: 'github_get_user_info',\n    description: 'Get profile information about the authenticated GitHub user.',\n    parameters: {\n      type: 'object',\n      properties: {},\n      required: [],\n    },\n    riskLevel: 'auto',\n    category: 'github',\n  },\n];\n\n// â”€â”€â”€ Tool Executors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nexport function registerGitHubExecutors(service: AgentService): void {\n  // ============== REPOSITORY EXECUTORS ==============\n\n  service.registerToolExecutor('github_create_repo', async (args) => {\n    try {\n      const result = await githubFetch('/user/repos', {\n        method: 'POST',\n        body: JSON.stringify({\n          name: args.name as string,\n          description: (args.description as string) || '',\n          private: (args.isPrivate as boolean) ?? false,\n          auto_init: (args.autoInit as boolean) ?? true,\n          gitignore_template: (args.gitignoreTemplate as string) || undefined,\n        }),\n      });\n      await sendNotification(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªÙˆØ¯Ø¹: ${result.full_name}`, 'success');\n      return {\n        success: true,\n        data: {\n          name: result.name,\n          fullName: result.full_name,\n          url: result.html_url,\n          cloneUrl: result.clone_url,\n          isPrivate: result.private,\n          defaultBranch: result.default_branch,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  // DELETE REPO â€” with auto-owner resolution\n  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n  service.registerToolExecutor('github_delete_repo', async (args) => {\n    let owner = (args.owner as string) || '';\n    const repo = args.repo as string;\n    const limitation = TOOL_LIMITATIONS.github_delete_repo;\n\n    // â”€â”€ Step 1: Auto-resolve owner if missing or suspicious â”€â”€\n    if (\n      !owner ||\n      owner === 'unknown' ||\n      owner === 'undefined' ||\n      owner.includes(' ')\n    ) {\n      const resolvedUsername = await getAuthenticatedUsername();\n      if (resolvedUsername) {\n        owner = resolvedUsername;\n        console.log(`[github_delete_repo] Auto-resolved owner to: ${owner}`);\n      } else {\n        return {\n          success: false,\n          error:\n            'Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ø§Ù„Ùƒ Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ (owner) ÙˆÙ„Ù… Ù†ØªÙ…ÙƒÙ† Ù…Ù† Ø§Ø³ØªØ®Ø±Ø§Ø¬Ù‡ Ù…Ù† Ø§Ù„ØªÙˆÙƒÙ†. ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù€ owner ÙŠØ¯ÙˆÙŠØ§Ù‹.',\n        };\n      }\n    }\n\n    // â”€â”€ Step 2: Verify the repo exists before attempting delete â”€â”€\n    try {\n      await githubFetch(`/repos/${owner}/${repo}`);\n    } catch (checkError) {\n      if (checkError instanceof GitHubApiError && checkError.isNotFound()) {\n        // Maybe wrong owner â€” try with authenticated user\n        const authUsername = await getAuthenticatedUsername();\n        if (authUsername && authUsername !== owner) {\n          try {\n            await githubFetch(`/repos/${authUsername}/${repo}`);\n            // Found under authenticated user!\n            owner = authUsername;\n            console.log(`[github_delete_repo] Corrected owner to: ${owner}`);\n          } catch {\n            return {\n              success: false,\n              error:\n                `Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ ${repo} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ØªØ­Øª ${owner} ÙˆÙ„Ø§ ØªØ­Øª ${authUsername}.\\n` +\n                `ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹.`,\n            };\n          }\n        } else {\n          return {\n            success: false,\n            error: `Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ ${owner}/${repo} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.`,\n          };\n        }\n      }\n      // Other errors (network, etc.) â€” continue and let the delete call handle it\n    }\n\n    // â”€â”€ Step 3: Attempt deletion â”€â”€\n    try {\n      await githubFetch(`/repos/${owner}/${repo}`, { method: 'DELETE' });\n      await sendNotification(\n        `âš ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹: ${owner}/${repo} Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹`,\n        'success'\n      );\n      return {\n        success: true,\n        data: {\n          deleted: `${owner}/${repo}`,\n          message: `ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ ${owner}/${repo} Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ù†Ø¬Ø§Ø­.`,\n        },\n      };\n    } catch (error) {\n      if (error instanceof GitHubApiError) {\n        if (error.isPermissionError()) {\n          await sendNotification(\n            `âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù ${owner}/${repo} â€” ØµÙ„Ø§Ø­ÙŠØ© delete_repo Ù…Ø·Ù„ÙˆØ¨Ø©`,\n            'error'\n          );\n          return {\n            success: false,\n            error:\n              `${limitation.userMessage}\\n\\n` +\n              `${limitation.fallbackInstructions}\\n\\n` +\n              `Ø§Ù„Ø®Ø·Ø£ Ø§Ù„Ø£ØµÙ„ÙŠ: ${error.message}`,\n          };\n        }\n\n        if (error.isNotFound()) {\n          return {\n            success: false,\n            error: `Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ ${owner}/${repo} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ Ø§Ù„ØªÙˆÙƒÙ† Ù„Ø§ ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ© Ø±Ø¤ÙŠØªÙ‡.`,\n          };\n        }\n      }\n\n      return {\n        success: false,\n        error:\n          `ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹ ${owner}/${repo}.\\n\\n` +\n          `${limitation.fallbackInstructions}\\n\\n` +\n          `Ø§Ù„Ø®Ø·Ø£: ${(error as Error).message}`,\n      };\n    }\n  });\n\n  service.registerToolExecutor('github_list_repos', async (args) => {\n    try {\n      const sort = (args.sort as string) || 'updated';\n      const perPage = (args.perPage as number) || 10;\n      const result = await githubFetch(\n        `/user/repos?sort=${sort}&per_page=${perPage}&direction=desc`\n      );\n      const repos = (result as unknown as Array<Record<string, unknown>>).map(\n        (r) => ({\n          name: r.name,\n          fullName: r.full_name,\n          url: r.html_url,\n          description: r.description || '',\n          isPrivate: r.private,\n          language: r.language,\n          stars: r.stargazers_count,\n          updatedAt: r.updated_at,\n        })\n      );\n      return { success: true, data: { count: repos.length, repos } };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_get_repo_info', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const result = await githubFetch(`/repos/${owner}/${repo}`);\n      return {\n        success: true,\n        data: {\n          name: result.name,\n          fullName: result.full_name,\n          description: result.description,\n          url: result.html_url,\n          cloneUrl: result.clone_url,\n          defaultBranch: result.default_branch,\n          isPrivate: result.private,\n          language: result.language,\n          stars: result.stargazers_count,\n          forks: result.forks_count,\n          openIssues: result.open_issues_count,\n          size: result.size,\n          createdAt: result.created_at,\n          updatedAt: result.updated_at,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_search_repos', async (args) => {\n    try {\n      const query = encodeURIComponent(args.query as string);\n      const sort = (args.sort as string) || 'stars';\n      const perPage = (args.perPage as number) || 5;\n      const result = await githubFetch(\n        `/search/repositories?q=${query}&sort=${sort}&per_page=${perPage}`\n      );\n      const items = (\n        (result.items || []) as Array<Record<string, unknown>>\n      ).map((r) => ({\n        name: r.name,\n        fullName: r.full_name,\n        url: r.html_url,\n        description: r.description || '',\n        language: r.language,\n        stars: r.stargazers_count,\n        forks: r.forks_count,\n        updatedAt: r.updated_at,\n      }));\n      return {\n        success: true,\n        data: { totalCount: result.total_count, repos: items },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // ============== FILE EXECUTORS ==============\n\n  service.registerToolExecutor('github_push_file', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const path = args.path as string;\n      const content = args.content as string;\n      const message = args.message as string;\n      const branch = (args.branch as string) || 'main';\n\n      let sha: string | undefined;\n      try {\n        const existing = await githubFetch(\n          `/repos/${owner}/${repo}/contents/${path}?ref=${branch}`\n        );\n        sha = existing.sha as string;\n      } catch {\n        /* file doesn't exist */\n      }\n\n      const base64Content = btoa(unescape(encodeURIComponent(content)));\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/contents/${path}`,\n        {\n          method: 'PUT',\n          body: JSON.stringify({\n            message,\n            content: base64Content,\n            branch,\n            ...(sha ? { sha } : {}),\n          }),\n        }\n      );\n      const commitData = result.commit as Record<string, unknown> | undefined;\n      await sendNotification(\n        `ØªÙ… ${sha ? 'ØªØ­Ø¯ÙŠØ«' : 'Ø¥Ù†Ø´Ø§Ø¡'}: ${path} ÙÙŠ ${owner}/${repo}`,\n        'success'\n      );\n      return {\n        success: true,\n        data: {\n          path,\n          action: sha ? 'updated' : 'created',\n          commitSha: commitData?.sha || '',\n          commitUrl: commitData?.html_url || '',\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_push_files', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const files = args.files as Array<{ path: string; content: string }>;\n      const message = args.message as string;\n      const branch = (args.branch as string) || 'main';\n\n      const refData = await githubFetch(\n        `/repos/${owner}/${repo}/git/ref/heads/${branch}`\n      );\n      const latestCommitSha = (refData.object as Record<string, unknown>)\n        .sha as string;\n      const commitData = await githubFetch(\n        `/repos/${owner}/${repo}/git/commits/${latestCommitSha}`\n      );\n      const baseTreeSha = (commitData.tree as Record<string, unknown>)\n        .sha as string;\n\n      const tree = [];\n      for (const file of files) {\n        const blob = await githubFetch(`/repos/${owner}/${repo}/git/blobs`, {\n          method: 'POST',\n          body: JSON.stringify({ content: file.content, encoding: 'utf-8' }),\n        });\n        tree.push({\n          path: file.path,\n          mode: '100644',\n          type: 'blob',\n          sha: blob.sha,\n        });\n      }\n\n      const newTree = await githubFetch(`/repos/${owner}/${repo}/git/trees`, {\n        method: 'POST',\n        body: JSON.stringify({ base_tree: baseTreeSha, tree }),\n      });\n      const newCommit = await githubFetch(\n        `/repos/${owner}/${repo}/git/commits`,\n        {\n          method: 'POST',\n          body: JSON.stringify({\n            message,\n            tree: newTree.sha,\n            parents: [latestCommitSha],\n          }),\n        }\n      );\n      await githubFetch(`/repos/${owner}/${repo}/git/refs/heads/${branch}`, {\n        method: 'PATCH',\n        body: JSON.stringify({ sha: newCommit.sha }),\n      });\n\n      await sendNotification(\n        `ØªÙ… Ø¯ÙØ¹ ${files.length} Ù…Ù„Ù(Ø§Øª) Ø¥Ù„Ù‰ ${owner}/${repo}`,\n        'success'\n      );\n      return {\n        success: true,\n        data: {\n          filesCount: files.length,\n          commitSha: newCommit.sha,\n          commitUrl: newCommit.html_url,\n          branch,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_read_file', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const path = args.path as string;\n      const branch = (args.branch as string) || 'main';\n      const content = await githubFetchRaw(\n        `/repos/${owner}/${repo}/contents/${path}?ref=${branch}`\n      );\n      return {\n        success: true,\n        data: {\n          path,\n          content:\n            content.length > 50000\n              ? content.slice(0, 50000) + '\\n\\n... [ØªÙ… Ø§Ù‚ØªØ·Ø§Ø¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰]'\n              : content,\n          size: content.length,\n          truncated: content.length > 50000,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_edit_file', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const path = args.path as string;\n      const oldStr = args.old_str as string;\n      const newStr = args.new_str as string;\n      const branch = (args.branch as string) || 'main';\n      const message = args.message as string;\n\n      const fileData = await githubFetch(\n        `/repos/${owner}/${repo}/contents/${path}?ref=${branch}`\n      );\n      const sha = fileData.sha as string;\n      const currentContentB64 = fileData.content as string;\n      const currentContent = decodeURIComponent(\n        escape(atob(currentContentB64.replace(/\\n/g, '')))\n      );\n\n      if (!currentContent.includes(oldStr)) {\n        return {\n          success: false,\n          error: `Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø§Ø³ØªØ¨Ø¯Ø§Ù„Ù‡ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ø§Ù„Ù…Ù„Ù ${path}.`,\n        };\n      }\n\n      const matchCount = currentContent.split(oldStr).length - 1;\n      if (matchCount > 1) {\n        return {\n          success: false,\n          error: `ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${matchCount} ØªØ·Ø§Ø¨Ù‚Ø§Øª ÙÙŠ ${path}. ÙŠØ±Ø¬Ù‰ ØªÙ‚Ø¯ÙŠÙ… Ù†Øµ Ø£ÙƒØ«Ø± ØªØ­Ø¯ÙŠØ¯Ø§Ù‹.`,\n        };\n      }\n\n      const newContent = currentContent.replace(oldStr, newStr);\n      const base64Content = btoa(unescape(encodeURIComponent(newContent)));\n\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/contents/${path}`,\n        {\n          method: 'PUT',\n          body: JSON.stringify({\n            message,\n            content: base64Content,\n            branch,\n            sha,\n          }),\n        }\n      );\n\n      const commitData = result.commit as Record<string, unknown> | undefined;\n      const linesChanged =\n        newStr.split('\\n').length - oldStr.split('\\n').length;\n\n      await sendNotification(\n        `ØªÙ… ØªØ¹Ø¯ÙŠÙ„ ${path} â€” ${Math.abs(linesChanged)} Ø³Ø·Ø± ${linesChanged >= 0 ? 'Ø£ÙØ¶ÙŠÙ' : 'Ø£ÙØ²ÙŠÙ„'}`,\n        'success'\n      );\n      return {\n        success: true,\n        data: {\n          path,\n          action: 'edited',\n          linesAdded: newStr.split('\\n').length,\n          linesRemoved: oldStr.split('\\n').length,\n          netChange: linesChanged,\n          commitSha: commitData?.sha || '',\n          commitUrl: commitData?.html_url || '',\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_delete_file', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const path = args.path as string;\n      const message = args.message as string;\n      const branch = (args.branch as string) || 'main';\n\n      const existing = await githubFetch(\n        `/repos/${owner}/${repo}/contents/${path}?ref=${branch}`\n      );\n      const sha = existing.sha as string;\n      if (!sha) return { success: false, error: `Ø§Ù„Ù…Ù„Ù ${path} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.` };\n\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/contents/${path}`,\n        {\n          method: 'DELETE',\n          body: JSON.stringify({ message, sha, branch }),\n        }\n      );\n      await sendNotification(\n        `ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù: ${path} Ù…Ù† ${owner}/${repo}`,\n        'success'\n      );\n      return {\n        success: true,\n        data: {\n          deleted: path,\n          commitSha: (result.commit as Record<string, unknown>)?.sha || '',\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_list_files', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const path = (args.path as string) || '';\n      const branch = (args.branch as string) || 'main';\n\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/contents/${path}?ref=${branch}`\n      );\n      const items = (result as unknown as Array<Record<string, unknown>>).map(\n        (item) => ({\n          name: item.name,\n          type: item.type,\n          size: item.size || 0,\n          path: item.path,\n          downloadUrl: item.download_url || null,\n        })\n      );\n      return {\n        success: true,\n        data: { path: path || '/', count: items.length, items },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // ============== BRANCH EXECUTORS ==============\n\n  service.registerToolExecutor('github_create_branch', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const branch = args.branch as string;\n      const fromBranch = (args.fromBranch as string) || 'main';\n\n      const refData = await githubFetch(\n        `/repos/${owner}/${repo}/git/ref/heads/${fromBranch}`\n      );\n      const sha = (refData.object as Record<string, unknown>).sha as string;\n      await githubFetch(`/repos/${owner}/${repo}/git/refs`, {\n        method: 'POST',\n        body: JSON.stringify({ ref: `refs/heads/${branch}`, sha }),\n      });\n      await sendNotification(\n        `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ ÙØ±Ø¹: ${branch} Ù…Ù† ${fromBranch}`,\n        'success'\n      );\n      return { success: true, data: { branch, fromBranch, sha } };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_list_branches', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/branches?per_page=30`\n      );\n      const branches = (\n        result as unknown as Array<Record<string, unknown>>\n      ).map((b) => ({\n        name: b.name,\n        protected: b.protected,\n        commitSha: (\n          ((b.commit as Record<string, unknown>)?.sha as string) || ''\n        ).slice(0, 7),\n      }));\n      return { success: true, data: { count: branches.length, branches } };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_delete_branch', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const branch = args.branch as string;\n\n      const repoInfo = await githubFetch(`/repos/${owner}/${repo}`);\n      if (repoInfo.default_branch === branch) {\n        return {\n          success: false,\n          error: `Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø§Ù„ÙØ±Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ \"${branch}\".`,\n        };\n      }\n\n      await githubFetch(`/repos/${owner}/${repo}/git/refs/heads/${branch}`, {\n        method: 'DELETE',\n      });\n      await sendNotification(\n        `âš ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„ÙØ±Ø¹: ${branch} Ù…Ù† ${owner}/${repo}`,\n        'success'\n      );\n      return {\n        success: true,\n        data: { deleted: branch, repo: `${owner}/${repo}` },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // ============== PULL REQUEST EXECUTORS ==============\n\n  service.registerToolExecutor('github_create_pull_request', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const result = await githubFetch(`/repos/${owner}/${repo}/pulls`, {\n        method: 'POST',\n        body: JSON.stringify({\n          title: args.title as string,\n          body: (args.body as string) || '',\n          head: args.head as string,\n          base: args.base as string,\n          draft: (args.draft as boolean) ?? false,\n        }),\n      });\n      await sendNotification(\n        `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ PR #${result.number}: ${result.title}`,\n        'success'\n      );\n      return {\n        success: true,\n        data: {\n          number: result.number,\n          url: result.html_url,\n          title: result.title,\n          state: result.state,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_list_pull_requests', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const state = (args.state as string) || 'open';\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/pulls?state=${state}&per_page=10`\n      );\n      const prs = (result as unknown as Array<Record<string, unknown>>).map(\n        (pr) => ({\n          number: pr.number,\n          title: pr.title,\n          url: pr.html_url,\n          state: pr.state,\n          author: (pr.user as Record<string, unknown>)?.login || '',\n          createdAt: pr.created_at,\n        })\n      );\n      return { success: true, data: { count: prs.length, pullRequests: prs } };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_get_pull_request', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const pullNumber = args.pullNumber as number;\n      const pr = await githubFetch(\n        `/repos/${owner}/${repo}/pulls/${pullNumber}`\n      );\n      const user = (pr.user as Record<string, unknown>) || {};\n      const head = (pr.head as Record<string, unknown>) || {};\n      const base = (pr.base as Record<string, unknown>) || {};\n      return {\n        success: true,\n        data: {\n          number: pr.number,\n          title: pr.title,\n          body: pr.body || '',\n          state: pr.state,\n          url: pr.html_url,\n          author: user.login || '',\n          headBranch: head.ref || '',\n          baseBranch: base.ref || '',\n          isDraft: pr.draft || false,\n          mergeable: pr.mergeable,\n          additions: pr.additions,\n          deletions: pr.deletions,\n          changedFiles: pr.changed_files,\n          commits: pr.commits,\n          createdAt: pr.created_at,\n          updatedAt: pr.updated_at,\n          mergedAt: pr.merged_at,\n          closedAt: pr.closed_at,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_merge_pull_request', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const pullNumber = args.pullNumber as number;\n      const mergeMethod = (args.mergeMethod as string) || 'merge';\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/pulls/${pullNumber}/merge`,\n        {\n          method: 'PUT',\n          body: JSON.stringify({\n            merge_method: mergeMethod,\n            commit_title: (args.commitTitle as string) || undefined,\n            commit_message: (args.commitMessage as string) || undefined,\n          }),\n        }\n      );\n      await sendNotification(`ØªÙ… Ø¯Ù…Ø¬ PR #${pullNumber} Ø¨Ù†Ø¬Ø§Ø­`, 'success');\n      return {\n        success: true,\n        data: {\n          merged: true,\n          sha: result.sha,\n          message: result.message,\n          pullNumber,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // ============== ISSUE EXECUTORS ==============\n\n  service.registerToolExecutor('github_create_issue', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const result = await githubFetch(`/repos/${owner}/${repo}/issues`, {\n        method: 'POST',\n        body: JSON.stringify({\n          title: args.title as string,\n          body: (args.body as string) || '',\n          labels: (args.labels as string[]) || [],\n        }),\n      });\n      await sendNotification(\n        `ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Issue #${result.number}: ${result.title}`,\n        'success'\n      );\n      return {\n        success: true,\n        data: {\n          number: result.number,\n          url: result.html_url,\n          title: result.title,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_list_issues', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const state = (args.state as string) || 'open';\n      const sort = (args.sort as string) || 'created';\n      const perPage = (args.perPage as number) || 10;\n      const labels = (args.labels as string) || '';\n\n      let url = `/repos/${owner}/${repo}/issues?state=${state}&sort=${sort}&per_page=${perPage}&direction=desc`;\n      if (labels) url += `&labels=${encodeURIComponent(labels)}`;\n\n      const result = await githubFetch(url);\n      const issues = (result as unknown as Array<Record<string, unknown>>)\n        .filter((i) => !i.pull_request)\n        .map((i) => ({\n          number: i.number,\n          title: i.title,\n          url: i.html_url,\n          state: i.state,\n          labels: ((i.labels || []) as Array<Record<string, unknown>>).map(\n            (l) => l.name\n          ),\n          author: (i.user as Record<string, unknown>)?.login || '',\n          comments: i.comments,\n          createdAt: i.created_at,\n        }));\n      return { success: true, data: { count: issues.length, issues } };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_update_issue', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const issueNumber = args.issueNumber as number;\n\n      const updatePayload: Record<string, unknown> = {};\n      if (args.title !== undefined) updatePayload.title = args.title;\n      if (args.body !== undefined) updatePayload.body = args.body;\n      if (args.state !== undefined) updatePayload.state = args.state;\n      if (args.labels !== undefined) updatePayload.labels = args.labels;\n      if (args.assignees !== undefined)\n        updatePayload.assignees = args.assignees;\n\n      if (Object.keys(updatePayload).length === 0) {\n        return { success: false, error: 'Ù„Ù… ÙŠØªÙ… ØªÙ‚Ø¯ÙŠÙ… Ø£ÙŠ Ø­Ù‚ÙˆÙ„ Ù„Ù„ØªØ­Ø¯ÙŠØ«.' };\n      }\n\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/issues/${issueNumber}`,\n        {\n          method: 'PATCH',\n          body: JSON.stringify(updatePayload),\n        }\n      );\n\n      const updatedFields = Object.keys(updatePayload).join(', ');\n      await sendNotification(\n        `ØªÙ… ØªØ­Ø¯ÙŠØ« Issue #${issueNumber} (${updatedFields})`,\n        'success'\n      );\n      return {\n        success: true,\n        data: {\n          number: result.number,\n          title: result.title,\n          state: result.state,\n          url: result.html_url,\n          updatedFields,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  service.registerToolExecutor('github_add_comment', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const issueNumber = args.issueNumber as number;\n      const body = args.body as string;\n\n      const result = await githubFetch(\n        `/repos/${owner}/${repo}/issues/${issueNumber}/comments`,\n        {\n          method: 'POST',\n          body: JSON.stringify({ body }),\n        }\n      );\n\n      await sendNotification(`ØªÙ… Ø¥Ø¶Ø§ÙØ© ØªØ¹Ù„ÙŠÙ‚ Ø¹Ù„Ù‰ #${issueNumber}`, 'success');\n      return {\n        success: true,\n        data: { id: result.id, url: result.html_url, issueNumber },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // ============== SEARCH EXECUTORS ==============\n\n  service.registerToolExecutor('github_search_code', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const query = args.query as string;\n      const fileExtension = args.fileExtension as string | undefined;\n      const path = args.path as string | undefined;\n      const perPage = (args.perPage as number) || 10;\n\n      let searchQuery = `${query}+repo:${owner}/${repo}`;\n      if (fileExtension) searchQuery += `+extension:${fileExtension}`;\n      if (path) searchQuery += `+path:${path}`;\n\n      const result = await githubFetch(\n        `/search/code?q=${encodeURIComponent(searchQuery)}&per_page=${perPage}`,\n        { headers: { Accept: 'application/vnd.github.text-match+json' } }\n      );\n\n      const items = (\n        (result.items || []) as Array<Record<string, unknown>>\n      ).map((item) => {\n        const textMatches =\n          (item.text_matches as Array<Record<string, unknown>>) || [];\n        return {\n          name: item.name,\n          path: item.path,\n          url: item.html_url,\n          matches: textMatches.map((m) => ({\n            fragment: m.fragment,\n            property: m.property,\n          })),\n        };\n      });\n\n      return {\n        success: true,\n        data: {\n          totalCount: result.total_count,\n          resultCount: items.length,\n          query,\n          items,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // ============== HISTORY EXECUTORS ==============\n\n  service.registerToolExecutor('github_get_commit_history', async (args) => {\n    try {\n      const owner = args.owner as string;\n      const repo = args.repo as string;\n      const branch = (args.branch as string) || 'main';\n      const path = args.path as string | undefined;\n      const perPage = (args.perPage as number) || 10;\n\n      let url = `/repos/${owner}/${repo}/commits?sha=${branch}&per_page=${perPage}`;\n      if (path) url += `&path=${encodeURIComponent(path)}`;\n\n      const result = await githubFetch(url);\n      const commits = (result as unknown as Array<Record<string, unknown>>).map(\n        (c) => {\n          const commit = (c.commit as Record<string, unknown>) || {};\n          const author = (commit.author as Record<string, unknown>) || {};\n          const committer = (commit.committer as Record<string, unknown>) || {};\n          return {\n            sha: ((c.sha as string) || '').slice(0, 7),\n            fullSha: c.sha,\n            message: commit.message,\n            author:\n              author.name || (c.author as Record<string, unknown>)?.login || '',\n            authorEmail: author.email,\n            date: author.date || committer.date,\n            url: c.html_url,\n          };\n        }\n      );\n\n      return {\n        success: true,\n        data: { branch, count: commits.length, commits },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n\n  // ============== USER EXECUTORS ==============\n\n  service.registerToolExecutor('github_get_user_info', async () => {\n    try {\n      const result = await githubFetch('/user');\n      return {\n        success: true,\n        data: {\n          login: result.login,\n          name: result.name,\n          bio: result.bio,\n          avatarUrl: result.avatar_url,\n          profileUrl: result.html_url,\n          publicRepos: result.public_repos,\n          followers: result.followers,\n          following: result.following,\n          createdAt: result.created_at,\n        },\n      };\n    } catch (error) {\n      return { success: false, error: (error as Error).message };\n    }\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\tools\\github\\shared.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\tools\\index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\tools\\utility-tools.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\agent\\types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\analytics\\__tests__\\analytics-service.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\analytics\\analytics-service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\analytics\\web-vitals-reporter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\db\\file-operations.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\db\\indexeddb.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\db\\schema.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\hooks\\use-performance.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useMemo was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies.",
        "line": 81,
        "column": 44,
        "nodeType": "Identifier",
        "endLine": 81,
        "endColumn": 48,
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "react-hooks/exhaustive-deps",
        "severity": 1,
        "message": "React Hook useMemo has a missing dependency: 'data'. Either include it or remove the dependency array.",
        "line": 81,
        "column": 44,
        "nodeType": "Identifier",
        "endLine": 81,
        "endColumn": 48,
        "suggestions": [
          {
            "desc": "Update the dependencies array to be: [data]",
            "fix": { "range": [2103, 2107], "text": "[data]" }
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\hooks\\useAnnouncer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\hooks\\useAutoSave.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\hooks\\useFocusTrap.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\hooks\\useKeyboardNavigation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\hooks\\useKeyboardShortcuts.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\hooks\\useMonacoEditor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monaco\\code-actions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monaco\\language-providers.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 15,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 15,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [549, 552], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [549, 552], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 15,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 15,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [568, 571], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [568, 571], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 51,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 51,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1555, 1558], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1555, 1558], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 51,
        "column": 54,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 51,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1568, 1571], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1568, 1571], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 75,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 75,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2248, 2251], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2248, 2251], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 75,
        "column": 52,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 75,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2260, 2263], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2260, 2263], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 105,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 105,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3140, 3143], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3140, 3143], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 105,
        "column": 54,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 105,
        "endColumn": 57,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3153, 3156], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3153, 3156], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 131,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 131,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3908, 3911], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3908, 3911], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 131,
        "column": 58,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 131,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3927, 3930], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3927, 3930], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monaco\\model-cache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monaco\\monaco-config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monaco\\theme-config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monitoring\\__tests__\\error-logger.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monitoring\\__tests__\\health-monitor.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monitoring\\error-logger.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\monitoring\\health-monitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\security\\csp.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\services\\file-system.service.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'FileNode' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 7,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 102,
        "column": 38,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 102,
        "endColumn": 41,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2979, 2982], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2979, 2982], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 114,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 114,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3433, 3436], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3433, 3436], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” File System Service\n * Provides file system access using the File System Access API\n * with graceful fallback for unsupported browsers.\n */\n\nimport type { FileNode } from '@/lib/db/schema';\nimport {\n  createFile as dbCreateFile,\n  createFolder as dbCreateFolder,\n  clearAllFiles,\n  getAllNodes,\n} from '@/lib/db/file-operations';\nimport { useFilesStore } from '@/lib/stores/files-store';\n\n/** Check if File System Access API is available */\nexport function isFileSystemAccessSupported(): boolean {\n  return 'showDirectoryPicker' in window;\n}\n\n/**\n * Open a native directory picker and import all files into IndexedDB.\n * Falls back to <input type=\"file\"> with webkitdirectory for unsupported browsers.\n */\nexport async function openFolder(): Promise<{\n  imported: number;\n  rootName: string;\n}> {\n  if (isFileSystemAccessSupported()) {\n    return openFolderNative();\n  }\n  return openFolderFallback();\n}\n\n/** Native File System Access API implementation */\nasync function openFolderNative(): Promise<{\n  imported: number;\n  rootName: string;\n}> {\n  // @ts-expect-error â€” showDirectoryPicker is not in all TS libs yet\n  const dirHandle: FileSystemDirectoryHandle = await window.showDirectoryPicker(\n    {\n      mode: 'read',\n    }\n  );\n\n  // Clear existing files before import\n  await clearAllFiles();\n\n  let imported = 0;\n\n  // Create root folder\n  const root = await dbCreateFolder(dirHandle.name, null);\n\n  // Recursively import directory\n  async function importDir(\n    handle: FileSystemDirectoryHandle,\n    parentId: string\n  ) {\n    for await (const entry of handle.values()) {\n      if (entry.kind === 'file') {\n        const fileHandle = entry as FileSystemFileHandle;\n        const file = await fileHandle.getFile();\n        const content = await file.text();\n        const lang = detectLanguage(entry.name);\n        await dbCreateFile(entry.name, parentId, content, lang);\n        imported++;\n      } else if (entry.kind === 'directory') {\n        const folder = await dbCreateFolder(entry.name, parentId);\n        await importDir(entry as FileSystemDirectoryHandle, folder.id);\n      }\n    }\n  }\n\n  await importDir(dirHandle, root.id);\n\n  // Reload file tree\n  await useFilesStore.getState().loadFileTree();\n\n  return { imported, rootName: dirHandle.name };\n}\n\n/** Fallback for browsers without File System Access API */\nfunction openFolderFallback(): Promise<{ imported: number; rootName: string }> {\n  return new Promise((resolve, reject) => {\n    const input = document.createElement('input');\n    input.type = 'file';\n    input.setAttribute('webkitdirectory', '');\n    input.setAttribute('directory', '');\n    input.multiple = true;\n\n    input.onchange = async () => {\n      const files = input.files;\n      if (!files || files.length === 0) {\n        reject(new Error('No files selected'));\n        return;\n      }\n\n      await clearAllFiles();\n\n      // Extract root folder name from first file's path\n      const firstPath = (files[0] as any).webkitRelativePath || files[0].name;\n      const rootName = firstPath.split('/')[0] || 'imported-project';\n      const root = await dbCreateFolder(rootName, null);\n\n      // Track created folders to avoid duplicates\n      const folderMap = new Map<string, string>();\n      folderMap.set(rootName, root.id);\n\n      let imported = 0;\n\n      for (let i = 0; i < files.length; i++) {\n        const file = files[i];\n        const relativePath = (file as any).webkitRelativePath || file.name;\n        const parts = relativePath.split('/');\n\n        // Ensure parent folders exist\n        let parentId = root.id;\n        for (let j = 1; j < parts.length - 1; j++) {\n          const folderPath = parts.slice(0, j + 1).join('/');\n          if (!folderMap.has(folderPath)) {\n            const folder = await dbCreateFolder(parts[j], parentId);\n            folderMap.set(folderPath, folder.id);\n          }\n          parentId = folderMap.get(folderPath)!;\n        }\n\n        // Create file\n        const content = await file.text();\n        const lang = detectLanguage(file.name);\n        await dbCreateFile(file.name, parentId, content, lang);\n        imported++;\n      }\n\n      await useFilesStore.getState().loadFileTree();\n      resolve({ imported, rootName });\n    };\n\n    input.oncancel = () => reject(new Error('Folder selection cancelled'));\n    input.click();\n  });\n}\n\n/**\n * Export the entire project as a downloadable ZIP-like structure.\n * Uses a simple approach: creates a Blob with JSON containing all files.\n */\nexport async function exportProject(): Promise<void> {\n  const nodes = await getAllNodes();\n\n  const data = JSON.stringify(\n    {\n      version: 1,\n      exportedAt: new Date().toISOString(),\n      files: nodes,\n    },\n    null,\n    2\n  );\n\n  const blob = new Blob([data], { type: 'application/json' });\n  const url = URL.createObjectURL(blob);\n\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = 'codeforge-project.json';\n  a.click();\n\n  URL.revokeObjectURL(url);\n}\n\n/**\n * Import a previously exported project from JSON file.\n */\nexport async function importProject(): Promise<{ imported: number }> {\n  return new Promise((resolve, reject) => {\n    const input = document.createElement('input');\n    input.type = 'file';\n    input.accept = '.json';\n\n    input.onchange = async () => {\n      const file = input.files?.[0];\n      if (!file) {\n        reject(new Error('No file selected'));\n        return;\n      }\n\n      try {\n        const text = await file.text();\n        const data = JSON.parse(text);\n\n        if (!data.files || !Array.isArray(data.files)) {\n          throw new Error('Invalid project file format');\n        }\n\n        await clearAllFiles();\n\n        const { getDBManager } = await import('@/lib/db/indexeddb');\n        const db = getDBManager();\n\n        for (const node of data.files) {\n          await db.put(node);\n        }\n\n        await useFilesStore.getState().loadFileTree();\n        resolve({ imported: data.files.length });\n      } catch (err) {\n        reject(err);\n      }\n    };\n\n    input.click();\n  });\n}\n\n/** Simple language detection by file extension */\nfunction detectLanguage(filename: string): string {\n  const ext = filename.split('.').pop()?.toLowerCase() || '';\n  const map: Record<string, string> = {\n    ts: 'typescript',\n    tsx: 'typescript',\n    js: 'javascript',\n    jsx: 'javascript',\n    py: 'python',\n    rs: 'rust',\n    go: 'go',\n    java: 'java',\n    c: 'c',\n    h: 'c',\n    cpp: 'cpp',\n    hpp: 'cpp',\n    cc: 'cpp',\n    cs: 'csharp',\n    rb: 'ruby',\n    php: 'php',\n    swift: 'swift',\n    kt: 'kotlin',\n    dart: 'dart',\n    html: 'html',\n    htm: 'html',\n    css: 'css',\n    scss: 'scss',\n    sass: 'scss',\n    less: 'less',\n    json: 'json',\n    xml: 'xml',\n    svg: 'xml',\n    yaml: 'yaml',\n    yml: 'yaml',\n    md: 'markdown',\n    mdx: 'markdown',\n    sql: 'sql',\n    sh: 'shell',\n    bash: 'shell',\n    zsh: 'shell',\n    dockerfile: 'dockerfile',\n    toml: 'toml',\n    ini: 'ini',\n    env: 'plaintext',\n    txt: 'plaintext',\n    gitignore: 'plaintext',\n  };\n  return map[ext] || 'plaintext';\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\services\\github-write.service.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\services\\github.service.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'FileNode' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 7,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 7,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” GitHub Service\n * Complete GitHub API integration for browser-based IDE.\n * Uses fetch-based API calls (no server dependency).\n */\n\nimport type { FileNode } from '@/lib/db/schema';\nimport {\n  createFile as dbCreateFile,\n  createFolder as dbCreateFolder,\n  clearAllFiles,\n} from '@/lib/db/file-operations';\nimport { useFilesStore } from '@/lib/stores/files-store';\n\n/* ------------------------------------------------------------------ */\n/*  Types                                                              */\n/* ------------------------------------------------------------------ */\n\nexport interface GitHubUser {\n  login: string;\n  avatar_url: string;\n  name: string | null;\n  bio: string | null;\n  public_repos: number;\n  html_url: string;\n}\n\nexport interface GitHubRepo {\n  id: number;\n  name: string;\n  full_name: string;\n  description: string | null;\n  html_url: string;\n  default_branch: string;\n  private: boolean;\n  language: string | null;\n  stargazers_count: number;\n  updated_at: string;\n}\n\nexport interface GitHubTreeItem {\n  path: string;\n  mode: string;\n  type: 'blob' | 'tree';\n  sha: string;\n  size?: number;\n  url: string;\n}\n\nexport interface GitHubTree {\n  sha: string;\n  url: string;\n  tree: GitHubTreeItem[];\n  truncated: boolean;\n}\n\n/* ------------------------------------------------------------------ */\n/*  Core API helper                                                    */\n/* ------------------------------------------------------------------ */\n\nconst GITHUB_API = 'https://api.github.com';\n\nasync function ghFetch<T>(\n  path: string,\n  token: string,\n  options: RequestInit = {}\n): Promise<T> {\n  const res = await fetch(`${GITHUB_API}${path}`, {\n    ...options,\n    headers: {\n      Accept: 'application/vnd.github+json',\n      Authorization: `Bearer ${token}`,\n      'X-GitHub-Api-Version': '2022-11-28',\n      ...((options.headers as Record<string, string>) || {}),\n    },\n  });\n\n  if (!res.ok) {\n    const body = await res.text().catch(() => '');\n    throw new GitHubServiceError(\n      `GitHub API ${res.status}: ${res.statusText}`,\n      res.status,\n      body\n    );\n  }\n\n  return res.json() as Promise<T>;\n}\n\nexport class GitHubServiceError extends Error {\n  constructor(\n    message: string,\n    public status: number,\n    public body?: string\n  ) {\n    super(message);\n    this.name = 'GitHubServiceError';\n  }\n}\n\n/* ------------------------------------------------------------------ */\n/*  Auth                                                               */\n/* ------------------------------------------------------------------ */\n\n/** Validate a Personal Access Token by fetching the authenticated user. */\nexport async function validateToken(token: string): Promise<GitHubUser> {\n  return ghFetch<GitHubUser>('/user', token);\n}\n\n/* ------------------------------------------------------------------ */\n/*  Repositories                                                       */\n/* ------------------------------------------------------------------ */\n\n/** List repos for the authenticated user (sorted by update). */\nexport async function listRepos(\n  token: string,\n  page = 1,\n  perPage = 30\n): Promise<GitHubRepo[]> {\n  return ghFetch<GitHubRepo[]>(\n    `/user/repos?sort=updated&per_page=${perPage}&page=${page}`,\n    token\n  );\n}\n\n/** Search public repositories. */\nexport async function searchRepos(\n  query: string,\n  token: string,\n  page = 1\n): Promise<{ items: GitHubRepo[] }> {\n  return ghFetch(\n    `/search/repositories?q=${encodeURIComponent(query)}&per_page=20&page=${page}`,\n    token\n  );\n}\n\n/** Get a single repo by owner/name. */\nexport async function getRepo(\n  owner: string,\n  repo: string,\n  token: string\n): Promise<GitHubRepo> {\n  return ghFetch<GitHubRepo>(`/repos/${owner}/${repo}`, token);\n}\n\n/* ------------------------------------------------------------------ */\n/*  Clone (tree-based)                                                 */\n/* ------------------------------------------------------------------ */\n\n/**\n * Clone a repository into the local IndexedDB file system.\n * Uses the Git Trees API to fetch the full tree in one call,\n * then fetches blob content for each file.\n */\nexport async function cloneRepository(\n  owner: string,\n  repo: string,\n  token: string,\n  branch?: string,\n  onProgress?: (msg: string, pct: number) => void\n): Promise<{ imported: number; repoName: string }> {\n  const report = onProgress || (() => {});\n\n  // 1. Get repo info to resolve default branch\n  report('Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹â€¦', 5);\n  const repoInfo = await getRepo(owner, repo, token);\n  const ref = branch || repoInfo.default_branch;\n\n  // 2. Fetch the full tree recursively\n  report(`Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø´Ø¬Ø±Ø© Ø§Ù„Ù…Ù„ÙØ§Øª (${ref})â€¦`, 15);\n  const tree = await ghFetch<GitHubTree>(\n    `/repos/${owner}/${repo}/git/trees/${ref}?recursive=1`,\n    token\n  );\n\n  if (tree.truncated) {\n    console.warn('Repository tree was truncated â€” some files may be missing.');\n  }\n\n  // 3. Clear existing files\n  report('ØªØ­Ø¶ÙŠØ± Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ù„ÙØ§Øªâ€¦', 20);\n  await clearAllFiles();\n\n  // 4. Create root folder\n  const root = await dbCreateFolder(repoInfo.name, null);\n\n  // 5. Create folder structure first\n  const folderMap = new Map<string, string>();\n  folderMap.set('', root.id); // root\n\n  const folders = tree.tree\n    .filter((item) => item.type === 'tree')\n    .sort((a, b) => a.path.localeCompare(b.path));\n\n  for (const folder of folders) {\n    const parts = folder.path.split('/');\n    const parentPath = parts.slice(0, -1).join('/');\n    const parentId = folderMap.get(parentPath) || root.id;\n    const created = await dbCreateFolder(parts[parts.length - 1], parentId);\n    folderMap.set(folder.path, created.id);\n  }\n\n  // 6. Fetch and create files\n  const blobs = tree.tree.filter(\n    (item) => item.type === 'blob' && (item.size || 0) < 500_000 // skip files > 500KB\n  );\n\n  let imported = 0;\n  const total = blobs.length;\n\n  for (const blob of blobs) {\n    const pct = 25 + Math.round((imported / total) * 70);\n    report(`Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ ${blob.path}â€¦`, pct);\n\n    try {\n      // Fetch blob content\n      const blobData = await ghFetch<{ content: string; encoding: string }>(\n        `/repos/${owner}/${repo}/git/blobs/${blob.sha}`,\n        token\n      );\n\n      let content = '';\n      if (blobData.encoding === 'base64') {\n        try {\n          content = atob(blobData.content.replace(/\\n/g, ''));\n        } catch {\n          content = `[Binary file â€” ${blob.size || 0} bytes]`;\n        }\n      } else {\n        content = blobData.content;\n      }\n\n      // Determine parent folder\n      const parts = blob.path.split('/');\n      const parentPath = parts.slice(0, -1).join('/');\n      const parentId = folderMap.get(parentPath) || root.id;\n      const fileName = parts[parts.length - 1];\n\n      await dbCreateFile(fileName, parentId, content, detectLang(fileName));\n      imported++;\n    } catch (err) {\n      console.warn(`Skipped ${blob.path}:`, err);\n    }\n  }\n\n  // 7. Reload tree\n  report('Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ø§Ø³ØªÙ†Ø³Ø§Ø®!', 100);\n  await useFilesStore.getState().loadFileTree();\n\n  return { imported, repoName: repoInfo.name };\n}\n\n/* ------------------------------------------------------------------ */\n/*  Branches                                                           */\n/* ------------------------------------------------------------------ */\n\nexport interface GitHubBranch {\n  name: string;\n  commit: { sha: string };\n  protected: boolean;\n}\n\nexport async function listBranches(\n  owner: string,\n  repo: string,\n  token: string\n): Promise<GitHubBranch[]> {\n  return ghFetch<GitHubBranch[]>(`/repos/${owner}/${repo}/branches`, token);\n}\n\n/* ------------------------------------------------------------------ */\n/*  Helpers                                                            */\n/* ------------------------------------------------------------------ */\n\nfunction detectLang(filename: string): string {\n  const ext = filename.split('.').pop()?.toLowerCase() || '';\n  const map: Record<string, string> = {\n    ts: 'typescript',\n    tsx: 'typescript',\n    js: 'javascript',\n    jsx: 'javascript',\n    py: 'python',\n    rs: 'rust',\n    go: 'go',\n    java: 'java',\n    c: 'c',\n    cpp: 'cpp',\n    cs: 'csharp',\n    rb: 'ruby',\n    php: 'php',\n    swift: 'swift',\n    kt: 'kotlin',\n    dart: 'dart',\n    html: 'html',\n    htm: 'html',\n    css: 'css',\n    scss: 'scss',\n    less: 'less',\n    json: 'json',\n    xml: 'xml',\n    svg: 'xml',\n    yaml: 'yaml',\n    yml: 'yaml',\n    md: 'markdown',\n    mdx: 'markdown',\n    sql: 'sql',\n    sh: 'shell',\n    bash: 'shell',\n    dockerfile: 'dockerfile',\n    toml: 'toml',\n    txt: 'plaintext',\n    gitignore: 'plaintext',\n  };\n  return map[ext] || 'plaintext';\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\__tests__\\agent-store.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\__tests__\\editor-store.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\__tests__\\extensions-store.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\__tests__\\files-store.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\__tests__\\git-store.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\__tests__\\notification-store.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\__tests__\\search-store.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\__tests__\\settings-store.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\agent-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\auth-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\editor-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\extensions-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\files-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\git-store.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'FileNode' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 12,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 12,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'useFilesStore' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 15,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 15,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * CodeForge IDE â€” Git Store\n * Source control state management.\n *\n * Tracks file changes (modified/added/deleted) compared to the\n * cloned snapshot, and orchestrates push operations using the\n * Git Data API for atomic multi-file commits.\n */\n\nimport { create } from 'zustand';\nimport { logger } from '@/lib/monitoring/error-logger';\nimport type { FileNode } from '@/lib/db/schema';\nimport { getAllNodes } from '@/lib/db/file-operations';\nimport { useAuthStore } from './auth-store';\nimport { useFilesStore } from './files-store';\nimport {\n  pushChanges,\n  type FileChange,\n  type CommitResult,\n} from '@/lib/services/github-write.service';\nimport { cloneRepository } from '@/lib/services/github.service';\n\n/* ------------------------------------------------------------------ */\n/*  Types                                                              */\n/* ------------------------------------------------------------------ */\n\nexport type FileStatus = 'modified' | 'added' | 'deleted';\n\nexport interface TrackedChange {\n  path: string;\n  status: FileStatus;\n  originalContent?: string;\n  currentContent?: string;\n  staged: boolean;\n}\n\nexport interface RepoContext {\n  owner: string;\n  repo: string;\n  branch: string;\n  clonedAt: number;\n}\n\nexport interface GitState {\n  /** Current repository context (set after clone) */\n  repoContext: RepoContext | null;\n\n  /** Snapshot of files at clone time (path â†’ content) */\n  snapshot: Map<string, string>;\n\n  /** Tracked changes */\n  changes: TrackedChange[];\n\n  /** Commit message input */\n  commitMessage: string;\n\n  /** Operation states */\n  isPushing: boolean;\n  isPulling: boolean;\n  pushProgress: { msg: string; pct: number };\n  pullProgress: { msg: string; pct: number };\n  lastPushResult: CommitResult | null;\n  error: string | null;\n\n  /** Actions */\n  setRepoContext: (ctx: RepoContext) => void;\n  takeSnapshot: () => Promise<void>;\n  detectChanges: () => Promise<void>;\n  stageFile: (path: string) => void;\n  unstageFile: (path: string) => void;\n  stageAll: () => void;\n  unstageAll: () => void;\n  setCommitMessage: (msg: string) => void;\n  push: () => Promise<CommitResult>;\n  pull: () => Promise<void>;\n  clearError: () => void;\n  getStagedChanges: () => TrackedChange[];\n  getChangeCount: () => { total: number; staged: number };\n}\n\n/* ------------------------------------------------------------------ */\n/*  Store                                                              */\n/* ------------------------------------------------------------------ */\n\nexport const useGitStore = create<GitState>((set, get) => ({\n  repoContext: null,\n  snapshot: new Map(),\n  changes: [],\n  commitMessage: '',\n  isPushing: false,\n  isPulling: false,\n  pushProgress: { msg: '', pct: 0 },\n  pullProgress: { msg: '', pct: 0 },\n  lastPushResult: null,\n  error: null,\n\n  setRepoContext: (ctx) => set({ repoContext: ctx }),\n\n  /**\n   * Take a snapshot of all current files.\n   * Called right after cloning to establish the \"baseline\".\n   */\n  takeSnapshot: async () => {\n    try {\n      const allNodes = await getAllNodes();\n      const snapshot = new Map<string, string>();\n\n      for (const node of allNodes) {\n        if (node.type === 'file' && node.content !== undefined) {\n          // Store path relative to root (remove leading /repoName/)\n          const parts = node.path.split('/');\n          const relativePath =\n            parts.length > 2 ? parts.slice(2).join('/') : node.name;\n          snapshot.set(relativePath, node.content);\n        }\n      }\n\n      set({ snapshot, changes: [] });\n    } catch (error) {\n      const message =\n        error instanceof Error ? error.message : 'ÙØ´Ù„ Ø£Ø®Ø° Ù„Ù‚Ø·Ø© Ø§Ù„Ù…Ù„ÙØ§Øª';\n      logger.error(\n        'ÙØ´Ù„ Ø£Ø®Ø° Ù„Ù‚Ø·Ø© Ø§Ù„Ù…Ù„ÙØ§Øª',\n        error instanceof Error ? error : undefined,\n        { source: 'GitStore.takeSnapshot' }\n      );\n      set({ error: message });\n    }\n  },\n\n  /**\n   * Compare current files against the snapshot to detect changes.\n   */\n  detectChanges: async () => {\n    const { snapshot } = get();\n    const allNodes = await getAllNodes();\n    const changes: TrackedChange[] = [];\n    const currentPaths = new Set<string>();\n\n    for (const node of allNodes) {\n      if (node.type !== 'file') continue;\n\n      const parts = node.path.split('/');\n      const relativePath =\n        parts.length > 2 ? parts.slice(2).join('/') : node.name;\n      currentPaths.add(relativePath);\n\n      const originalContent = snapshot.get(relativePath);\n      const currentContent = node.content || '';\n\n      if (originalContent === undefined) {\n        // New file\n        changes.push({\n          path: relativePath,\n          status: 'added',\n          currentContent,\n          staged: false,\n        });\n      } else if (originalContent !== currentContent) {\n        // Modified file\n        changes.push({\n          path: relativePath,\n          status: 'modified',\n          originalContent,\n          currentContent,\n          staged: false,\n        });\n      }\n    }\n\n    // Detect deleted files\n    for (const [path, content] of snapshot) {\n      if (!currentPaths.has(path)) {\n        changes.push({\n          path,\n          status: 'deleted',\n          originalContent: content,\n          staged: false,\n        });\n      }\n    }\n\n    // Preserve staged status from previous state\n    const prevChanges = get().changes;\n    const prevStaged = new Set(\n      prevChanges.filter((c) => c.staged).map((c) => c.path)\n    );\n\n    for (const change of changes) {\n      if (prevStaged.has(change.path)) {\n        change.staged = true;\n      }\n    }\n\n    set({ changes });\n  },\n\n  stageFile: (path) => {\n    if (!path || typeof path !== 'string') {\n      logger.warn('Ø§Ù„Ù…Ø³Ø§Ø± Ù…Ø·Ù„ÙˆØ¨ Ù„Ø¹Ù…Ù„ÙŠØ© stage', {\n        source: 'GitStore.stageFile',\n      });\n      return;\n    }\n    set((state) => ({\n      changes: state.changes.map((c) =>\n        c.path === path ? { ...c, staged: true } : c\n      ),\n    }));\n  },\n\n  unstageFile: (path) => {\n    if (!path || typeof path !== 'string') {\n      logger.warn('Ø§Ù„Ù…Ø³Ø§Ø± Ù…Ø·Ù„ÙˆØ¨ Ù„Ø¹Ù…Ù„ÙŠØ© unstage', {\n        source: 'GitStore.unstageFile',\n      });\n      return;\n    }\n    set((state) => ({\n      changes: state.changes.map((c) =>\n        c.path === path ? { ...c, staged: false } : c\n      ),\n    }));\n  },\n\n  stageAll: () => {\n    set((state) => ({\n      changes: state.changes.map((c) => ({ ...c, staged: true })),\n    }));\n  },\n\n  unstageAll: () => {\n    set((state) => ({\n      changes: state.changes.map((c) => ({ ...c, staged: false })),\n    }));\n  },\n\n  setCommitMessage: (msg) => set({ commitMessage: msg }),\n\n  getStagedChanges: () => get().changes.filter((c) => c.staged),\n\n  getChangeCount: () => {\n    const changes = get().changes;\n    return {\n      total: changes.length,\n      staged: changes.filter((c) => c.staged).length,\n    };\n  },\n\n  /**\n   * Push all staged changes to GitHub in a single atomic commit.\n   */\n  push: async () => {\n    const { repoContext, commitMessage, changes } = get();\n    const { token } = useAuthStore.getState();\n\n    if (!repoContext) throw new Error('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªÙˆØ¯Ø¹ Ù…ØªØµÙ„.');\n    if (!token) throw new Error('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹.');\n\n    const staged = changes.filter((c) => c.staged);\n    if (staged.length === 0) throw new Error('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª Ù…Ø­Ø¯Ø¯Ø© Ù„Ù„Ø¯ÙØ¹.');\n    if (!commitMessage.trim()) throw new Error('Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù€ commit Ù…Ø·Ù„ÙˆØ¨Ø©.');\n\n    set({\n      isPushing: true,\n      error: null,\n      pushProgress: { msg: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø¯Ø¡â€¦', pct: 0 },\n    });\n\n    try {\n      // Convert tracked changes to FileChange format\n      const fileChanges: FileChange[] = staged.map((change) => {\n        if (change.status === 'deleted') {\n          return { path: change.path, action: 'delete' as const };\n        }\n        return {\n          path: change.path,\n          content: change.currentContent || '',\n          action:\n            change.status === 'added'\n              ? ('create' as const)\n              : ('update' as const),\n        };\n      });\n\n      const result = await pushChanges(\n        repoContext.owner,\n        repoContext.repo,\n        repoContext.branch,\n        commitMessage.trim(),\n        fileChanges,\n        token,\n        (msg, pct) => set({ pushProgress: { msg, pct } })\n      );\n\n      // After successful push: update snapshot with new state\n      const newSnapshot = new Map(get().snapshot);\n      for (const change of staged) {\n        if (change.status === 'deleted') {\n          newSnapshot.delete(change.path);\n        } else {\n          newSnapshot.set(change.path, change.currentContent || '');\n        }\n      }\n\n      // Remove pushed changes from the list\n      const stagedPaths = new Set(staged.map((c) => c.path));\n      const remainingChanges = get().changes.filter(\n        (c) => !stagedPaths.has(c.path)\n      );\n\n      set({\n        isPushing: false,\n        lastPushResult: result,\n        commitMessage: '',\n        snapshot: newSnapshot,\n        changes: remainingChanges,\n        pushProgress: { msg: 'ØªÙ… Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­! âœ“', pct: 100 },\n      });\n\n      return result;\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'ÙØ´Ù„ Ø§Ù„Ø¯ÙØ¹';\n      set({ isPushing: false, error: message });\n      throw err;\n    }\n  },\n\n  /**\n   * Pull latest changes (re-clone the repository).\n   */\n  pull: async () => {\n    const { repoContext } = get();\n    const { token } = useAuthStore.getState();\n\n    if (!repoContext) throw new Error('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªÙˆØ¯Ø¹ Ù…ØªØµÙ„.');\n    if (!token) throw new Error('ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹.');\n\n    set({\n      isPulling: true,\n      error: null,\n      pullProgress: { msg: 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø³Ø­Ø¨â€¦', pct: 0 },\n    });\n\n    try {\n      await cloneRepository(\n        repoContext.owner,\n        repoContext.repo,\n        token,\n        repoContext.branch,\n        (msg, pct) => set({ pullProgress: { msg, pct } })\n      );\n\n      // Re-take snapshot after pull\n      await get().takeSnapshot();\n\n      set({\n        isPulling: false,\n        changes: [],\n        pullProgress: { msg: 'ØªÙ… Ø§Ù„Ø³Ø­Ø¨ Ø¨Ù†Ø¬Ø§Ø­! âœ“', pct: 100 },\n      });\n    } catch (err) {\n      const message = err instanceof Error ? err.message : 'ÙØ´Ù„ Ø§Ù„Ø³Ø­Ø¨';\n      set({ isPulling: false, error: message });\n      throw err;\n    }\n  },\n\n  clearError: () => set({ error: null }),\n}));\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\notification-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\search-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\settings-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\stores\\ui-store.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\types\\editor.types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\types\\file.types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\types\\github.types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\__tests__\\crypto.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\__tests__\\rate-limiter.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\__tests__\\sanitize.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\cn.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\constants.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\crypto.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\file-icons.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\file-path-detect.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\git-log.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\initial-files.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\markdown-parser.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\mock-files.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\monaco-init-wrapper.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\monaco-loader.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\rate-limiter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\sanitize.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\lib\\utils\\theme.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\middleware.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'request' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 5,
        "column": 28,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 35
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { buildCspString, SECURITY_HEADERS } from '@/lib/security/csp';\n\nexport function middleware(request: NextRequest) {\n  const response = NextResponse.next();\n\n  // CSP + Security headers â€” Ù…ØµØ¯Ø± ÙˆØ§Ø­Ø¯ Ù…Ø´ØªØ±Ùƒ Ù…Ø¹ next.config.mjs\n  response.headers.set('Content-Security-Policy', buildCspString());\n\n  for (const [key, value] of Object.entries(SECURITY_HEADERS)) {\n    response.headers.set(key, value);\n  }\n\n  return response;\n}\n\nexport const config = {\n  // Previously excluded /api â€” now all routes receive security headers.\n  // Only static Next.js internals and favicon are excluded.\n  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\next-env.d.ts",
    "messages": [
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Delete `â`",
        "line": 1,
        "column": 31,
        "nodeType": null,
        "messageId": "delete",
        "endLine": 1,
        "endColumn": 32,
        "fix": { "range": [30, 31], "text": "" }
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Delete `â`",
        "line": 2,
        "column": 50,
        "nodeType": null,
        "messageId": "delete",
        "endLine": 2,
        "endColumn": 51,
        "fix": { "range": [81, 82], "text": "" }
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Delete `â`",
        "line": 3,
        "column": 1,
        "nodeType": null,
        "messageId": "delete",
        "endLine": 3,
        "endColumn": 2,
        "fix": { "range": [83, 84], "text": "" }
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Delete `â`",
        "line": 4,
        "column": 40,
        "nodeType": null,
        "messageId": "delete",
        "endLine": 4,
        "endColumn": 41,
        "fix": { "range": [124, 125], "text": "" }
      },
      {
        "ruleId": "prettier/prettier",
        "severity": 2,
        "message": "Delete `â`",
        "line": 5,
        "column": 106,
        "nodeType": null,
        "messageId": "delete",
        "endLine": 5,
        "endColumn": 107,
        "fix": { "range": [231, 232], "text": "" }
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 5,
    "fixableWarningCount": 0,
    "source": "/// <reference types=\"next\" />\r\n/// <reference types=\"next/image-types/global\" />\r\n\r\n// NOTE: This file should not be edited\r\n// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\tailwind.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\tests\\setup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\tests\\unit\\example.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\tests\\unit\\layout.test.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\tests\\unit\\monaco.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'disposeModel' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 5,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 5,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 2,
        "message": "'clearAllModels' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 6,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 6,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 41,
        "column": 21,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 41,
        "endColumn": 24,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1252, 1255], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1252, 1255], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "ï»¿import { describe, it, expect, vi } from 'vitest';\nimport { detectLanguage, supportedLanguages } from '@/lib/monaco/monaco-config';\nimport {\n  getOrCreateModel,\n  disposeModel,\n  clearAllModels,\n} from '@/lib/monaco/model-cache';\n\ndescribe('Monaco Config', () => {\n  it('detects language from file extension', () => {\n    expect(detectLanguage('test.ts')).toBe('typescript');\n    expect(detectLanguage('test.js')).toBe('javascript');\n    expect(detectLanguage('index.html')).toBe('html');\n    expect(detectLanguage('styles.css')).toBe('css');\n    expect(detectLanguage('data.json')).toBe('json');\n    expect(detectLanguage('README.md')).toBe('markdown');\n    expect(detectLanguage('unknown.xyz')).toBe('plaintext');\n  });\n\n  it('supports 10+ languages', () => {\n    expect(supportedLanguages.length).toBeGreaterThanOrEqual(10);\n  });\n});\n\ndescribe('Monaco Model Cache', () => {\n  it('creates and retrieves models', () => {\n    const mockMonaco = {\n      editor: {\n        createModel: vi.fn(() => ({\n          getValue: () => 'const x = 1;',\n          setValue: vi.fn(),\n          dispose: vi.fn(),\n        })),\n      },\n      Uri: {\n        file: vi.fn((path: string) => path),\n      },\n    };\n\n    const model = getOrCreateModel(\n      mockMonaco as any,\n      'test.ts',\n      'const x = 1;',\n      'typescript'\n    );\n    expect(model).toBeDefined();\n    expect(mockMonaco.editor.createModel).toHaveBeenCalledWith(\n      'const x = 1;',\n      'typescript',\n      'test.ts'\n    );\n  });\n});\n\ndescribe('Mock Data', () => {\n  it('provides 3 sample tabs', async () => {\n    const { mockTabs } = await import('@/lib/utils/mock-files');\n    expect(mockTabs).toHaveLength(3);\n    expect(mockTabs[0].language).toBe('typescript');\n    expect(mockTabs[2].language).toBe('markdown');\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Revexn\\codeforge-ide\\vitest.config.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
